/** macro updates **/
DROP PROCEDURE if exists yyyymmddToDate;
delete from macro_names where formula = 'yyyymmddToDate';

drop procedure if exists dateyyyymmddTimeToDateTime;
delete from macro_names where formula = 'dateyyyymmddTimeToDateTime';

drop procedure if exists if1Con1ElseNull;
delete from macro_names where formula = 'if1Con1ElseNull';

drop procedure if exists if1Con1ElseCon2;
delete from macro_names where formula = 'if1Con1ElseCon2';

drop procedure if exists cat2Concat3ColsDelimNoSpaces;
delete from  macro_names where formula = 'cat2Concat3ColsDelimNoSpaces';

delete from  macro_names where formula = 'cat2Concat2ColsDelimNoSpaces';
drop procedure if exists cat2Concat2ColsDelimNoSpaces;

delete from  macro_names where formula = 'cat2DelTransWhenNull';
drop procedure if exists cat2DelTransWhenNull;

delete from  macro_names where formula = 'CleanTranslatedListTable';
drop procedure if exists CleanTranslatedListTable;

delete from  macro_names where formula = 'cat2ApplyCWTranslatedList';
drop procedure if exists cat2ApplyCWTranslatedList;

delete from macro_names where formula = 'addCharToString';
drop procedure if exists addCharToString;

DROP PROCEDURE if exists yyyymmddToDate;
delete from macro_names where formula = 'yyyymmddToDate';

drop procedure if exists dateyyyymmddTimeToDateTime;
delete from macro_names where formula = 'dateyyyymmddTimeToDateTime';

delete from macro_names where formula = 'addDelimiterEvery2Characters';
drop procedure if exists addDelimiterEvery2Characters;

drop procedure if exists ifDateCon1ElseNull;
delete from macro_names where formula = 'ifDateCon1ElseNull';

UPDATE `universaltranslatorca`.`macro_Names` SET `Con1_Question`='Please enter source SF\'s date value separator.  e.g. -, ., /', `Con2_Question`='Please enter target SF\'s date value separator.  e.g. -, ., /' WHERE `ID`='68';
UPDATE `universaltranslatorca`.`macro_Names` SET `Con1_Question`='Please enter source SF\'s date value separator.  e.g. -, ., /', `Con2_Question`='Please enter target SF\'s date value separator.  e.g. -, ., /' WHERE `ID`='69';

UPDATE `universaltranslatorca`.`macro_Names` SET `Macro_Name`='Date - yyyy*mm*dd to mm*dd*yyyy' WHERE `ID`='68';
UPDATE `universaltranslatorca`.`macro_Names` SET `Macro_Name`='Date - mm*dd*yyyy to yyyy*mm*dd' WHERE `ID`='69';

UPDATE `universaltranslatorca`.`macro_names` SET `FieldB_Question`='Handle MySQL 2 digit year limitations for 2 digit years ending in 30-69. (Y/N)', `Con1_Question`='Please enter the inbound string\'s date format', `Con2_Question`='Please enter the outbound string\'s date format' WHERE `ID`='112';

drop procedure if exists yyyymmddstripTime;
delete from macro_names where formula = 'yyyymmddstripTime';

drop procedure if exists ifNonDateSetNull;
delete from macro_names where formula = 'ifNonDateSetNull';

delete from macro_names where formula = 'dateYYYYMMDDHHMMSSMSToYYYYMMDDHHMMSS';
drop procedure if exists dateYYYYMMDDHHMMSSMSToYYYYMMDDHHMMSS;


/** Still TO DO **/
UPDATE `universaltranslatorca`.`macro_names` SET `FieldA_Question`='Please enter value you would like to prepend', `FieldB_Question`='Prepend if the field is blank (Y/N).', `Con1_Question`='Please enter value you would like to append', `Con2_Question`='Append if the field is blank (Y/N).' WHERE `ID`='102';

update configurationdatatranslations set macroId = 76 where macroId = 110;

drop procedure if exists IfSFLen0orNullReplaceValue;


drop procedure if exists concatColumnsToList;
delete from macro_names where formula = 'concatColumnsToList';

drop procedure if exists IfSFLen0orNullReplaceValue;
delete from macro_names where formula = 'IfSFLen0orNullReplaceValue';

/** ***** **/
/**  20200917 **/
 
drop procedure if exists ArithmeticForSFAndFAUpdateFB;
delete from macro_names where formula = 'ArithmeticForSFAndFAUpdateFB';

drop procedure if exists DeleteTransactionWhenFieldIsNull;
delete from macro_names where formula = 'DeleteTransactionWhenFieldIsNull';

/** 20200920 **/
USE `universaltranslatorca`;
DROP procedure IF EXISTS `futureDateCheck`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `futureDateCheck`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

set @stmt = concat("select group_concat(id) from " , @translatedTable, " where
 ((Date(",srcField,") is null and length(",srcField,") > 0)
 or (curdate() >= ", srcField , " = 0))
 and  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

if (@errorIds is not null) then
	begin
		set @stmt = concat("update " , @translatedTable, "  set forCW = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
	end;
end if;

set @errorIds = '';


end proc_main$$

DELIMITER ;

/** 20200921 **/

drop procedure if exists GreaterThanEqualFieldAUpdateFieldB;
delete from macro_names where formula = 'GreaterThanEqualFieldAUpdateFieldB';


drop procedure if exists lessThanEqualFieldAUpdateFieldB;
delete from macro_names where formula = 'lessThanEqualFieldAUpdateFieldB';

drop procedure if exists countListSize;
delete from macro_names where formula = 'countListSize';


INSERT INTO `macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Formula`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`) VALUES ('197', '1', 'Compare Two Fields and Update SF to Con2', 'Compare Two Fields and Update SF to Con2', 'CompareTwoFieldsAndUpdateSFWithCon2', 'Please enter field to compare source field to', ' ', 'Please enter comparison (< , <=, =, >, >=, !=)', 'Please enter value to update SF to');

USE `universaltranslatorca`;
DROP procedure IF EXISTS `CompareTwoFieldsAndUpdateSFWithCon2`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `CompareTwoFieldsAndUpdateSFWithCon2`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

/** 
this macro compares SF and FA using con1 operator
and will update to con2

**/

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


	/** allowed comparison >, >=, =, <, <=, != **/
      if con1 != '>'  and  con1 != '>='  and con1!='=' and con1 != '<' and con1 != '<=' and con1 != '!=' then
					begin
			
							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'CompareTwoFieldsAndUpdateSF con1 - ", con1," is not a valid comparison.'",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
           
			leave proc_main;
        end;
      end if;


	-- leaving it for now, nulls are ignored by default. In case we need to handle issues comparing null and values, we will update this 
	set @sqlBlanks = '';
	
    /** MySql doesn't compare integers and decimals well
		we create a temp table and insert those into a table that specifics them as float
    **/
    set @stmt = concat("drop table if exists transactionnumericcompare_", batchId);
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
    
    
    set @stmt = concat("CREATE TABLE transactionnumericcompare_",batchId," (
			  id int(11) NOT NULL AUTO_INCREMENT,
			  transactionId int(11) DEFAULT NULL,
			  compareResult bit(1) NOT NULL DEFAULT b'0',
			  col1Data FLOAT(20,10) DEFAULT NULL,
			  col2Data FLOAT(20,10) DEFAULT NULL,
			  PRIMARY KEY (id),
			  KEY numCompResult (compareResult)
			  ) ENGINE=InnoDB DEFAULT CHARSET=latin1;");
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
    
	/** now we insert the numeric values and compare those **/
    set @stmt = concat("insert into transactionnumericcompare_",batchId," 
    (transactionId, col1Data, col2Data)
    select ",@translateCol,", ",srcField,", ",fieldA," from ", @translatedTable, 
    " where ",srcField, "  REGEXP '^[+-]?[0-9]*[.]{0,1}[0-9]*$' = 1
    and ",fieldA, "  REGEXP '^[+-]?[0-9]*[.]{0,1}[0-9]*$' = 1 
    and length(",srcField, ") > 0 and length(",fieldA, ") > 0",
	@sqlBlanks);
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
	
	/** this way it will compare better **/
    set @stmt = concat("update ",@translatedTable, " join 
	(select col1data ", con1 ," col2data comparedResults , transactionId from transactionnumericcompare_",batchId,") t2
	on transactionId = ",@translateCol,"
	set forCW = 'compared', ",srcField," = case when comparedResults then '",con2,"' else ",srcField," end ");
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
    
		
	 /** we compare and update **/
     set @stmt = concat("update  ",@translatedTable, " t1 join 
		(select ",srcField, " " , con1, " ",fieldA," comparedResults , ",@translateCol," 
		from  ",@translatedTable, " where forCW is null or forCW != 'compared') t2
		on t1.",@translateCol," = t2.",@translateCol,"
		set ",srcField," = case when comparedResults then '",con2,"' else ",srcField," end");
	 
     PREPARE stmt from @stmt;
     EXECUTE stmt;
     DEALLOCATE PREPARE stmt;
     
     
	set @stmt = concat("drop table if exists transactionnumericcompare_", batchId);
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;

end proc_main$$

DELIMITER ;

update macro_names set fieldA_Question = '', fieldB_Question = '' where formula = 'stringToDate';


USE `universaltranslatorca`;
DROP procedure IF EXISTS `stringToDate`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `stringToDate`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


		set @mysqlDateFormat = concat('%Y-%m-%d');

		set @inboundDateFormat = con1;
        
		if (length(con2) > 0) then
			set @outboundDateFormat = concat(con2);
		else 
			set @outboundDateFormat = concat('%Y-%m-%d');
		end if;



		set @errorIds = "";
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(",srcField,", '",@inboundDateFormat,"') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

	if (@errorIds is not null) then

		begin
				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
						
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
		end;
	end if;

	set @stmt = concat("update ",@translatedTable, " set ",srcField," = str_to_date(",srcField,", '",@inboundDateFormat,"') where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 	
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
            
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
      


	set @errorIds = "";
	set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(",srcField,") is null
					and ",srcField," is not null and length(",srcField,") > 0  and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
       
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

if (@errorIds is not null) then

begin	
		set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
		
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;

	
set @goodIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where  ",srcField," is not null and length(",srcField,") > 0  and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @goodIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
		
		if (@goodIds is not null) then

			begin
					-- fix two digit years
					-- check to make sure %y is in the inbound to handle
                    select year(curdate()) into @currYear;
                    
					if  (@inboundDateFormat like BINARY '%\%y%' && @outboundDateFormat not like BINARY '%\%y%') then 
					
					select year(curdate()) into @currYear;

					set @stmt = concat("update ",@translatedTable, " set ",srcField," =  DATE_ADD(",srcField,", INTERVAL -100 Year) where id in (",@goodIds,") 
					and year(",srcField,") > ",@currYear,"");
					
					PREPARE stmt from @stmt;
					EXECUTE stmt;
					DEALLOCATE PREPARE stmt;
                    
                    -- translate to final format
                    set @stmt = concat("update ",@translatedTable, " set ",srcField," = date_format(",srcField,", '",@outboundDateFormat,"') where id in (",@goodIds,") ");
					
					PREPARE stmt from @stmt;
					EXECUTE stmt;
					DEALLOCATE PREPARE stmt;
		end if;
                    
			end;
		end if;
        
        

end proc_main$$

DELIMITER ;

drop procedure if exists populateWithBatchUploadId;
delete from macro_names where formula = 'populateWithBatchUploadId';

drop procedure if exists ifNonDateAndNotBlankReject;
delete from macro_names where formula = 'ifNonDateAndNotBlankReject';

UPDATE `universaltranslatorca`.`macro_names` SET `Macro_Short_Name`='ifNotBlankError', `Formula`='ifNotBlankError' WHERE `ID`='150';

drop procedure if exists ifNotBlankReject;

USE `universaltranslatorca`;
DROP procedure IF EXISTS `ZipCodeCheck`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `ZipCodeCheck`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
SELECT 
    @translatedTable,
    @transactionTable,
    @batchTable,
    @batchIdType,
    @errorTable,
    @translateCol
INTO @translatedTable , @transactionTable , @batchTable , @batchIdType , @errorTable, @translateCol;

call getFinalStatusIds;
SELECT @finalStatusIds INTO @finalStatusIds;

				
                set @proceed = true;
                
                
                if (length(con1) > 0) then
					begin
						
                        if con1 REGEXP '^[0-9]{5}$' = 0 then 
                        
							set @proceed = false;
                            
							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, fieldValue, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'Default zip code ",con1," is not a valid value'",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            
                            leave proc_main;
						end if;
					end;
                end if;

				if (@proceed) then 
								begin
								
								set @whereStmt =  concat(" and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");
								set @whereClause = concat("  (",srcField," REGEXP '^[0-9]{5}$' != 1) 
								and ",srcField," is not null and length(",srcField,") > 0 ");
							    set @whereString = concat(@whereClause , @whereStmt);

								set @stmt = concat("update  ", @translatedTable , " set forcw = ",srcField);
								PREPARE stmt from @stmt;
								EXECUTE stmt;
								DEALLOCATE PREPARE stmt;

								set @stmt = concat("update  ", @translatedTable , " set ",srcField," = replace(",srcField,", '-', '') where (length(", srcField,") != 0 or ",srcField," is not null )", @whereStmt);
								PREPARE stmt from @stmt;
								EXECUTE stmt;
								DEALLOCATE PREPARE stmt;
								
								
								
								set @stmt = concat("update  ", @translatedTable , " set ",srcField," = 
								case 
								when (length(",srcField,") = 4 or length(",srcField,") = 8) then concat('0', ",srcField,") 
								when (length(",srcField,") = 3 or length(",srcField,") = 7)  then concat('00', ",srcField,") 
								when (length(",srcField,") = 2  or length(",srcField,") = 6)  then concat('000', ",srcField,") 
								when length(",srcField,") = 1 then concat('0000', ",srcField,") 
								else ",srcField," end where length(",srcField,") != 5 ", @whereStmt);
								
								PREPARE stmt from @stmt;
								EXECUTE stmt;
								DEALLOCATE PREPARE stmt;
							   
								set @stmt = concat("update  ", @translatedTable , " set ",srcField," = left(",srcField,", 5) where length(", srcField,") > 5", @whereStmt);
								 
								PREPARE stmt from @stmt;
								EXECUTE stmt;
								DEALLOCATE PREPARE stmt;
                                
								
								set @stmt = concat("update  ", @translatedTable , " set forcw = 'MACRO_ERROR' where  ", @whereString);
                               
								PREPARE stmt from @stmt;
								EXECUTE stmt;
								DEALLOCATE PREPARE stmt;
							   
								if (length(con1) > 0) then
												
													set @stmt = concat("update  ", @translatedTable , " set forcw='BlankVar', ",srcField," = '",con1,"' where (length(", srcField,") = 0 or ",srcField," is null )  ", @whereStmt);
													
                                                    PREPARE stmt from @stmt;
													EXECUTE stmt;
													DEALLOCATE PREPARE stmt;
								end if;
							   
				

			end;
	end if;
				
end proc_main$$

DELIMITER ;


USE `universaltranslatorca`;
DROP procedure IF EXISTS `ifNotBlankError`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `ifNotBlankError`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

	call setInboundOutBoundTables (foroutboundProcessing,batchId);
	select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn
	into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn;

	call getFinalStatusIds;
	select @finalStatusIds into @finalStatusIds;

    set @stmt = concat("update  ", @translatedTable , " set forcw = 'MACRO_ERROR' where ",
    srcField," is not null and length(",srcField,") > 0 ",
    " and  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");

	PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

end proc_main$$

DELIMITER ;

USE `universaltranslatorca`;
DROP procedure IF EXISTS `rejectNonYearMonthTransactions`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `rejectNonYearMonthTransactions`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin



call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn;


call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

set @whereClause = concat(" and  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") ");

set @totalCount1 = 0;
set @yearMonthToUse1 = 0;

set @stmt = concat("select count(*) totalCount, 
DATE_FORMAT(",srcField,",'%Y%m') monthYearForFile from ",@translatedTable," where ",srcField," is not null ", @whereClause,"
group by 
DATE_FORMAT(",srcField,",'%Y%m')
order by totalCount desc limit 0, 1 into @totalCount1, @yearMonthToUse1
;");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


set @totalCount2 = 0;
set @yearMonthToUse2 = 0;

set @stmt = concat("select count(*) totalCount, 
DATE_FORMAT(",srcField,",'%Y%m') monthYearForFile from ",@translatedTable," where ",srcField," is not null ", @whereClause,"
group by 
DATE_FORMAT(",srcField,",'%Y%m')
order by totalCount desc limit 1, 1 into @totalCount2, @yearMonthToUse2
;");


PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


if (@totalCount1 = @totalCount2) then
 
	BEGIN
			set @stmt = concat("insert into ", @errorTable , " (" , @batchIdColumn, ", configId, " , @transactionTable, 
			"Id, fieldNo, errorId, macroId, stackTrace, required) select batchId, configId, ", @transactionTable, "id, replace('",srcField,"', 'F', ''), ", 8, 
			", ",macroId, ", 'Macro rejectNonYearMonthTransactions - Could not determine which date to use:  "  "Year Month - ",@yearMonthToUse1, " and ",@yearMonthToUse2," have the same numbers of transactions - ",@totalCount1, "'",
            ", true from ", @translatedTable, " where ",
			srcField," is not null and length(",srcField,") > 0 ", @whereClause, ";");
            
		
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
	END;
end if;
		
		if (@totalCount1 > @totalCount2) then
				BEGIN
                
					
					set @stmt = concat("insert into ", @errorTable , " (" , @batchIdColumn, ", configId, " , @transactionTable, 
					"Id, fieldNo, errorId, macroId, stacktrace, required) select batchId, configId, ", @transactionTable, "id, replace('",srcField,"', 'F', ''), '", con2, "',",
                    macroId,", concat('Year and month of ', DATE_FORMAT(",srcField,",'%Y%m'), ' for ',",srcField,", ' does not match year and month ',",@yearMonthToUse1,",' used for processing.'), true from ", @translatedTable, " where ",
					srcField," is not null and length(",srcField,") > 0 ",
                    " and DATE_FORMAT(",srcField,",'%Y%m') != ", @yearMonthToUse1, " ", 
                    @whereClause, ";");
					
					PREPARE stmt from @stmt;
					EXECUTE stmt;
					DEALLOCATE PREPARE stmt;
                
                END;
		end if;

select '';
end proc_main$$

DELIMITER ;

UPDATE `universaltranslatorca`.`macro_names` SET `CategoryId`='0', `Macro_Short_Name`='errorNonYearMonthTransactions', `Formula`='errorNonYearMonthTransactions' WHERE `ID`='152';

USE `universaltranslatorca`;
DROP procedure IF EXISTS `rejectNonYearMonthTransactions`;

USE `universaltranslatorca`;
DROP procedure IF EXISTS `errorNonYearMonthTransactions`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `errorNonYearMonthTransactions`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin



call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @translateCol;


call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

set @whereClause = concat(" and  configId = ",configId," and ", @batchIdColumn," = ",batchId," and statusId not in (",@finalStatusIds ,") ");

set @totalCount1 = 0;
set @yearMonthToUse1 = 0;

set @stmt = concat("select count(*) totalCount, 
DATE_FORMAT(",srcField,",'%Y%m') monthYearForFile from ",@translatedTable," where ",srcField," is not null ", @whereClause,"
group by 
DATE_FORMAT(",srcField,",'%Y%m')
order by totalCount desc limit 0, 1 into @totalCount1, @yearMonthToUse1
;");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

set @totalCount2 = 0;
set @yearMonthToUse2 = 0;

set @stmt = concat("select count(*) totalCount, 
DATE_FORMAT(",srcField,",'%Y%m') monthYearForFile from ",@translatedTable," where ",srcField," is not null ", @whereClause,"
group by 
DATE_FORMAT(",srcField,",'%Y%m')
order by totalCount desc limit 1, 1 into @totalCount2, @yearMonthToUse2
;");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;



set @stmt = concat("select fieldDesc from configurationformfields where configId = ",configId," 
and fieldNo = replace('",srcField,"', 'F', '') 
into @fieldLabel;");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;



if (@totalCount1 = @totalCount2) then
 
	BEGIN
			set @stmt = concat("insert into ", @errorTable , " (" , @batchIdColumn, ", configId, " , @translateCol, 
			", fieldNo, errorId, macroId, stackTrace, required, fieldLabel, fieldValue) select ",batchId,", ",configId,", ",@translateCol, ", replace('",srcField,"', 'F', ''), ", 8, 
			", ",macroId, ", 'Macro rejectNonYearMonthTransactions - Could not determine which date to use:  "  "Year Month - ",@yearMonthToUse1, " and ",@yearMonthToUse2," have the same numbers of transactions - ",@totalCount1, "'",
            ", true, '",@fieldLabel,"', ",srcField," from ", @translatedTable, " where ",
			srcField," is not null and length(",srcField,") > 0 ", @whereClause, ";");
            
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
	END;
end if;



		
		if (@totalCount1 > @totalCount2) then
				BEGIN
                
					
					set @stmt = concat("insert into ", @errorTable , " (" , @batchIdColumn, ", configId, " , @translateCol, 
					", fieldNo, errorId, macroId, stacktrace, required,fieldLabel, fieldValue) select ",batchId,", ",configId,", ", @translateCol, ", replace('",srcField,"', 'F', ''), 60,",
                    macroId,", concat('Year and month of ', DATE_FORMAT(",srcField,",'%Y%m'), ' for ',",srcField,", ' does not match year and month ',",@yearMonthToUse1,",' used for processing.')
                    , true, '",@fieldLabel,"', ",srcField,"  from ", @translatedTable, " where ",
					srcField," is not null and length(",srcField,") > 0 ",
                    " and DATE_FORMAT(",srcField,",'%Y%m') != ", @yearMonthToUse1, " ", 
                    @whereClause, ";");
					
                    PREPARE stmt from @stmt;
					EXECUTE stmt;
					DEALLOCATE PREPARE stmt;
                
                END;
		end if;


end proc_main$$

DELIMITER ;

delete from macro_names where formula = 'StringToDateFor2DigitYears';
drop procedure if exists StringToDateFor2DigitYears;

delete from macro_names where formula = 'prependStringWithCon2IfLengthMataches';
drop procedure if exists prependStringWithCon2IfLengthMataches;

delete from macro_names where formula = 'CopyColumnTTItoTIR';
drop procedure if exists CopyColumnTTItoTIR;

USE `universaltranslatorca`;
DROP procedure IF EXISTS `regExCheck`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `regExCheck`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
SELECT 
    @translatedTable,
    @transactionTable,
    @batchTable,
    @batchIdType,
    @errorTable,
    @translateCol
INTO @translatedTable , @transactionTable , @batchTable , @batchIdType , @errorTable, @translateCol;

call getFinalStatusIds;
SELECT @finalStatusIds INTO @finalStatusIds;


set @whereClause  = concat("  (",srcField," REGEXP '",con1,"' != 1 or ",srcField," REGEXP '^[",con1,"]*$' is null)
            and ",srcField," is not null and  length(",srcField,") > 0 and ");
            
set @whereString = concat(@whereClause, "  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");

			set @stmt = concat("update  ", @translatedTable , " set forcw = 'MACRO_ERROR'  where ",@whereString);

			PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;


end proc_main$$

DELIMITER ;

USE `universaltranslatorca`;
DROP procedure IF EXISTS `applyCWTranslatedListNoTrackDroppedValues`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `applyCWTranslatedListNoTrackDroppedValues`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin 

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @listTable, @translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @listTable, @translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

if (transactionId = 0) then
	set @whereString = concat(" and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");
end if;

if (transactionId != 0) then
	set @whereString = concat(" and ",	@transactionTable,".id = ", transactionId,";");
end if;

set @fcol = replace(lcase(srcField), 'f', '');
set @stmt = concat("delete from ", @listTable," where fcol = ",@fcol," and ",@batchIdType," = ", batchId ,";");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


		

		set @stmt = concat("
		SELECT max(CHAR_LENGTH(",srcField,") - CHAR_LENGTH( REPLACE ( ",srcField,", ',', '') )  + 1) from ",@translatedTable, " into @maxListLength");
		
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
         
        if (@maxListLength is null) then
			set @maxListLength = 108;
        end if;
       
		set @stmt = concat("
    insert into ", @listTable," (",@batchIdType,", ",@translateCol,", invalue, fcol)
    SELECT ",@batchIdType,", ",@translateCol,", IFNULL(trim(SUBSTRING_INDEX(SUBSTRING_INDEX(t.",srcField,", ',', n.n), ',', -1)),'') value, ",@fcol,"
	FROM ",@translatedTable ," t CROSS JOIN (
    SELECT distinct a.N + b.N * 10 + 1 n FROM  
   (select id N from ref_numbers where id <=",@maxListLength,") a
   ,(select id N from ref_numbers where id <=",@maxListLength,") b
    ORDER BY n) n  WHERE n.n <= 1 + (LENGTH(t.",srcField,") - LENGTH(REPLACE(t.",srcField,", ',', ''))) ", @whereString);
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

    
    set @stmt = concat("update ",@listTable," set invalue = replace(replace(invalue, '\n',''), '\r', '')");
	 
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    
    set @stmt2 = "";
	set @stmt1 = concat("update ",@listTable," join (select id, sourcevalue, targetvalue from rel_crosswalkdata where crosswalkid = ", con1 ,") cwdata
	on invalue = sourcevalue set translatedvalue = targetvalue where ",@batchIdType," = ", batchId);
 
	set @stmt = concat(@stmt1, @stmt2);
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
	if (passClear = 1) then
	
	set @stmt1 = concat("update ",@listTable, " set translatedvalue = invalue where translatedvalue is null ");

	set @stmt = concat(@stmt1, @stmt2);
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
	end if;
  
  
  
	set @selDistinct = '';
    
    if (con2 = 'Y') then
		begin
			set @selDistinct = ' distinct ';
        end;
    end if;
  
    set @stmt = concat("update ",@translatedTable," join  (select ",@translateCol," as matchId, 
    group_concat(",@selDistinct," translatedValue order by id) label from  ",@listTable,"
	where ",@batchIdType," = ",batchid, " and fcol = ",@fCol," group by ",@translateCol," ) cwmatch on ",@translateCol," = matchid set ",srcField," = label ");
	   
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    

    set @stmt = concat("delete from ", @listTable, " where ",@batchIdType," = ",batchId," and fcol = ",@fcol);
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;


end proc_main$$

DELIMITER ;


drop procedure if exists ArithmeticConstantStoreInFA;
delete from macro_names where formula = 'ArithmeticConstantStoreInFA';

DROP PROCEDURE `universaltranslatorca`.`CompareTwoFieldsAndReject`;
UPDATE `universaltranslatorca`.`macro_names` SET `Macro_Name`='Conditional: Compare Two Non-Blank Fields and Insert Error when criteria is not met', `Macro_Short_Name`='CompareTwoFieldsAndError', `Formula`='CompareTwoFieldsAndError' WHERE `ID`='146';


USE `universaltranslatorca`;
DROP procedure IF EXISTS `CompareTwoFieldsAndError`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `CompareTwoFieldsAndError`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

/** 
this macro compares SF and FA using con1 operator
Conditional: Compare Two Non-Blank Fields and Insert Error when criteria is not met

**/

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


	/** allowed comparison >, >=, =, <, <=, != **/
      if con1 != '>'  and  con1 != '>='  and con1!='=' and con1 != '<' and con1 != '<=' and con1 != '!=' then
					begin
			
							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'CompareTwoFieldsAndError con1 - ", con1," is not a valid comparison.'",", ",true);
                            
							
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
           
			leave proc_main;
        end;
      end if;


	-- This macro compares non-blank fields
    set @sqlBlanks = concat("  ", fieldA," is not null and ",srcField," is not null 
    and length(", fieldA,") > 0 and length(",srcField,") > 0 
    ");
	
    
    /** MySql doesn't compare integers and decimals well
		we create a temp table and insert those into a table that specifics them as float
    **/
    set @stmt = concat("drop table if exists transactionnumericcompare_", batchId);
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
    
    
    set @stmt = concat("CREATE TABLE transactionnumericcompare_",batchId," (
			  id int(11) NOT NULL AUTO_INCREMENT,
			  transactionId int(11) DEFAULT NULL,
			  compareResult bit(1) NOT NULL DEFAULT b'0',
			  col1Data FLOAT(20,10) DEFAULT NULL,
			  col2Data FLOAT(20,10) DEFAULT NULL,
			  PRIMARY KEY (id),
			  KEY numCompResult (compareResult)
			  ) ENGINE=InnoDB DEFAULT CHARSET=latin1;");
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
    
	/** now we insert the numeric values and compare those **/
    set @stmt = concat("insert into transactionnumericcompare_",batchId," 
    (transactionId, col1Data, col2Data)
    select ",@translateCol,", ",srcField,", ",fieldA," from ", @translatedTable, 
    " where ",srcField, "  REGEXP '^[+-]?[0-9]*[.]{0,1}[0-9]*$' = 1
    and ",fieldA, "  REGEXP '^[+-]?[0-9]*[.]{0,1}[0-9]*$' = 1 
    and length(",srcField, ") > 0 and length(",fieldA, ") > 0 and ",
	@sqlBlanks);
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
	
	/** this way it will compare better **/
    set @stmt = concat("update ",@translatedTable, " join 
	(select col1data ", con1 ," col2data comparedResults , transactionId from transactionnumericcompare_",batchId,") t2
	on transactionId = ",@translateCol,"
	set forCW = case when comparedResults = true then 'compared' else 'MACRO_ERROR' end where", @sqlBlanks);
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
    
		
	 /** we compare and update **/
     set @stmt = concat("update  ",@translatedTable, " t1 join 
		(select ",srcField, " " , con1, " ",fieldA," comparedResults , ",@translateCol," 
		from  ",@translatedTable, " where forCW is null or forCW != 'compared') t2
		on t1.",@translateCol," = t2.",@translateCol,"
		set forCW = case when comparedResults then '' else 'MACRO_ERROR' end where", @sqlBlanks);
	 
     
     PREPARE stmt from @stmt;
     EXECUTE stmt;
     DEALLOCATE PREPARE stmt;

	set @stmt = concat("drop table if exists transactionnumericcompare_", batchId);
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;

end proc_main$$

DELIMITER ;

USE `universaltranslatorca`;
DROP procedure IF EXISTS `CompareTwoFieldsAndUpdateSFWithCon2`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `CompareTwoFieldsAndUpdateSFWithCon2`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

/** 
this macro compares SF and FA using con1 operator
and will update to con2

**/

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


	/** allowed comparison >, >=, =, <, <=, != **/
      if con1 != '>'  and  con1 != '>='  and con1!='=' and con1 != '<' and con1 != '<=' and con1 != '!=' then
					begin
			
							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'CompareTwoFieldsAndUpdateSF con1 - ", con1," is not a valid comparison.'",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
           
			leave proc_main;
        end;
      end if;


	-- we only compare non-empty fields
    set @sqlBlanks = concat("  ", fieldA," is not null and ",srcField," is not null 
    and length(", fieldA,") > 0 and length(",srcField,") > 0 
    ");
	
    /** MySql doesn't compare integers and decimals well
		we create a temp table and insert those into a table that specifics them as float
    **/
    set @stmt = concat("drop table if exists transactionnumericcompare_", batchId);
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
    
    
    set @stmt = concat("CREATE TABLE transactionnumericcompare_",batchId," (
			  id int(11) NOT NULL AUTO_INCREMENT,
			  transactionId int(11) DEFAULT NULL,
			  compareResult bit(1) NOT NULL DEFAULT b'0',
			  col1Data FLOAT(20,10) DEFAULT NULL,
			  col2Data FLOAT(20,10) DEFAULT NULL,
			  PRIMARY KEY (id),
			  KEY numCompResult (compareResult)
			  ) ENGINE=InnoDB DEFAULT CHARSET=latin1;");
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
    
	/** now we insert the numeric values and compare those **/
    set @stmt = concat("insert into transactionnumericcompare_",batchId," 
    (transactionId, col1Data, col2Data)
    select ",@translateCol,", ",srcField,", ",fieldA," from ", @translatedTable, 
    " where ",srcField, "  REGEXP '^[+-]?[0-9]*[.]{0,1}[0-9]*$' = 1
    and ",fieldA, "  REGEXP '^[+-]?[0-9]*[.]{0,1}[0-9]*$' = 1 
    and length(",srcField, ") > 0 and length(",fieldA, ") > 0 and ",
	@sqlBlanks);
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
	
	/** this way it will compare better **/
    set @stmt = concat("update ",@translatedTable, " join 
	(select col1data ", con1 ," col2data comparedResults , transactionId from transactionnumericcompare_",batchId,") t2
	on transactionId = ",@translateCol,"
	set forCW = 'compared', ",srcField," = case when comparedResults then '",con2,"' else ",srcField," end where ", @sqlBlanks);
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
    
		
	 /** we compare and update **/
     set @stmt = concat("update  ",@translatedTable, " t1 join 
		(select ",srcField, " " , con1, " ",fieldA," comparedResults , ",@translateCol," 
		from  ",@translatedTable, " where forCW is null or forCW != 'compared') t2
		on t1.",@translateCol," = t2.",@translateCol,"
		set ",srcField," = case when comparedResults then '",con2,"' else ",srcField," end where ", @sqlBlanks);
	 
     PREPARE stmt from @stmt;
     EXECUTE stmt;
     DEALLOCATE PREPARE stmt;
     
     
	set @stmt = concat("drop table if exists transactionnumericcompare_", batchId);
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;

end proc_main$$

DELIMITER ;

USE `universaltranslatorca`;
DROP procedure IF EXISTS `ifNotNumericSetToCon1`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `ifNotNumericSetToCon1`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

set @whereclause = concat(" and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
set @stmt1 = concat("update ",@translatedTable, " set ",srcField, " = '", con1 , "' where  ",srcField ," REGEXP  '^-?[0-9]+[.]?[0-9]*$|^-?[.][0-9]+$' = 0 ");


set @stmt = concat(@stmt1, @whereclause, ";");
PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


end proc_main$$

DELIMITER ;






