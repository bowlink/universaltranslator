/** macro updates 10282020 **/

delete from macro_names where id = 1;
drop procedure if exists MatchSFtoCon1UpdateFBtoCon2;

USE `universaltranslatorca`;
DROP procedure IF EXISTS `substringToAnotherField`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `substringToAnotherField`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

	call setInboundOutBoundTables (foroutboundProcessing,batchId);
	SELECT 
		@translatedTable,
		@transactionTable,
		@batchTable,
		@batchIdType,
		@errorTable
	INTO @translatedTable , @transactionTable , @batchTable , @batchIdType , @errorTable;

	call getFinalStatusIds;
	SELECT @finalStatusIds INTO @finalStatusIds;

	-- check to make sure con1 and con2 are numeric
    
	if con1 REGEXP '^[]?[0-9]*[]{0,1}[0-9]*$' = 0 or   con2 REGEXP '^[]?[0-9]*[]{0,1}[0-9]*$' = 0 then 
					begin
			
							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, fieldValue, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'substringToAnotherField macro Either - Con1 - \"",con1,"\"  or Con2 - \"",con2,"\" is not a numeric value'",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							 
							PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
           
			leave proc_main;
        end;
      end if;
		
        /** 
			we only update if there are enough characters. 
			for example, abcd, extract position 2 (con1), 3 characters, cd is only 2 so it won't be updated.
        **/
        
		set @stmt = concat("update ",@translatedTable, " set ",fieldA," =  ",
		" substring(" , srcField, ", ", con1,",", con2,")  
        where  (length(substring(" , srcField, ", ", con1,",", con2,")) >= ",con2,") = true and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");
		
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


end proc_main$$

DELIMITER ;

use universaltranslatorca;

drop procedure if exists PopulateFPRaceIdAndFields;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `PopulateFPRaceIdAndFields`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @listTable, @translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @listTable, @translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

-- defaulting con1 to Y
set con1 = 'Y';
			
            set @whereString = concat("  where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
			
            
            -- we need to keep original value, store it in forcw first
            set @stmt = concat("
				update ",@translatedTable, " set forcw = ",srcField,";
			");
            
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt; 
            
			set @stmt = concat("
				select length(concat_ws('', F17,F18,F19,F20,F21,F22,F23,F30)) fieldLen from ",@translatedTable, @whereString, " order by fieldLen desc limit 1 into @fieldLen;
			");
            
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
         
    
        if (@fieldLen = 0) then
    
    
		begin
				set @stmt = concat("update ",@translatedTable," set F17 = case when concat(',', ",srcField,", ',') like '%,1,%' then '",con1,"' else '' end",@whereString,";");
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
				set @stmt = concat("update ",@translatedTable," set F18 = case when concat(',', ",srcField,", ',') like '%,2,%' then '",con1,"' else '' end",@whereString,";");
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
                
				set @stmt = concat("update ",@translatedTable," set F19 = case when concat(',', ",srcField,", ',') like '%,3,%' then '",con1,"' else '' end",@whereString,";");
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
                
                set @stmt = concat("update ",@translatedTable," set F20 = case when concat(',', ",srcField,", ',') like '%,4,%' then '",con1,"' else '' end",@whereString,";");
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
                
                set @stmt = concat("update ",@translatedTable," set F21 = case when concat(',', ",srcField,", ',') like '%,5,%' then '",con1,"'  else '' end",@whereString,";");
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
                
                set @stmt = concat("update ",@translatedTable," set F22 = case when concat(',', ",srcField,", ',') like '%,7,%' then '",con1,"'  else '' end",@whereString,";");
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
                
                set @stmt = concat("update ",@translatedTable," set F23 = case when concat(',', ",srcField,", ',') like '%,6,%' then '",con1,"' else '' end",@whereString,";");
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
                
                set @stmt = concat("update ",@translatedTable," set F30 = case when concat(',', ",srcField,", ',') like '%,8,%' then'",con1,"'  else '' end ",@whereString,";");
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
	
    end;
    
    end if;
				
                set @stmt = concat("
				update ",@translatedTable," set ",srcField," =  case 
				when ( length(concat_ws('', F17,F18,F19,F20,F21,F23)) > 1)  and  (length(concat_ws('', F22, F30)) = 0) then 6 
				when (F22 = '",con1,"' and length(concat_ws('', F17,F18,F19,F20,F21, F23, F30)) = 0) then 7
				when (F30 ='",con1,"' and length(concat_ws('', F17,F18,F19,F20, F21, F23, F22)) = 0) then 8
				when (F17 = '",con1,"' and length(concat_ws('', F22,F30)) = 0) then 1  when (F18 = '",con1,"' and length(concat_ws('', F22,F30)) = 0) then 2 
				when (F19 = '",con1,"' and length(concat_ws('', F22,F30)) = 0) then 3 when (F20 = '",con1,"' and length(concat_ws('', F22,F30)) = 0)then 4 
				when (F21 = '",con1,"' and length(concat_ws('', F22,F30)) = 0)then 5 when (F23 = '",con1,"' and length(concat_ws('', F22,F30)) = 0)  then 6
				else '' end ",@whereString,"
			");
            
            
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
            
			   
				-- put back forcw value so it can be passed
                -- track the ids that are changed
                
                set @errorIds = '';
                
                set @stmt = concat("
				select  group_concat(id) from ",@translatedTable, "
                where length(forcw) > 0 and (",srcField," is null or length(",srcField,") = 0)
				into @errorIds");
                
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt; 
                
                if (@errorIds is not null) then 
                
					begin
						set @stmt = concat("
						update ",@translatedTable, " set ",srcField," = forcw
						where id in (",@errorIds,")");
				
						PREPARE stmt from @stmt;
						EXECUTE stmt;
						DEALLOCATE PREPARE stmt; 
						
						set @stmt = concat("
						update ",@translatedTable, " set forcw = 'MACRO_ERROR'
						where id in (",@errorIds,")");
			
						PREPARE stmt from @stmt;
						EXECUTE stmt;
						DEALLOCATE PREPARE stmt; 
					
					end;
                end if;
                
                
end proc_main$$
DELIMITER ;

UPDATE `universaltranslatorca`.`macro_names` SET `Con1_Question`='' WHERE `ID`='174';


