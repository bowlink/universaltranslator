/** config change **/
UPDATE `universaltranslator`.`configurationmessagespecs` SET `rptField1`='4', `rptField2`='5', `rptField3`='13', `rptField4`='6' WHERE `id`='22';

/** macro change **/
drop procedure if exists futureDateCheck;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `futureDateCheck`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;


call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


if (transactionId = 0) then
	BEGIN
	set @stmt = concat("insert into ", @errorTable , " (" , @batchIdColumn, ", configId, " , @translateCol, 
    ", fieldNo, errorId, macroId, fieldValue) select " , @batchIdColumn, ", configId, id, replace('",srcField,"', 'F', ''), ", con2, 
    ", ",macroId,",",srcField," from ", @translatedTable, " where Date(", srcField,") is not null ",
    " and curdate() >= ", srcField , " = 0 ",
    " and  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");
	END;
	END if;

if (transactionId != 0) then
	BEGIN
	set @stmt = concat("insert into ", @errorTable , " (" , @batchIdColumn, ", configId, " , @translateCol, 
    ", fieldNo, errorId, macroId, fieldValue) select " , @batchIdColumn, ", configId, id, replace('",srcField,"', 'F', ''), ", con2, 
    ", ",macroId,",",srcField," from ", @translatedTable, " where Date(", srcField,") is not null ",
    " and curdate() >= ", srcField , " = 0 ",
    "  and ",@transactionTable,"Id = ", transactionId, ";");
	END;
	END if;
    

PREPARE stmt from @stmt;
EXECUTE stmt;

select '';
end proc_main$$
DELIMITER ;


/** SP change **/

drop procedure if exists populateAuditReport;
DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `populateAuditReport`(in inConfigId int, in inBatchId int)
proc_main:begin

SET @stmt = CONCAT('delete from transactionindetailauditerrors_',inBatchId,' where configId = ',inConfigId);
PREPARE stmt from @stmt;
EXECUTE stmt;

SELECT concat('F',rptField1),concat('F',rptField2),concat('F',rptField3),concat('F',rptField4) INTO @rptField1, @rptField2,@rptField3,@rptField4 
FROM configurationmessagespecs where configId = inConfigId LIMIT 1;

if(@rptField1 = 'F0') then 
	set @rptField1 = "F1";
end if;

if(@rptField2 = 'F0') then 
	set @rptField2 = "F2";
end if;

if(@rptField3 = 'F0') then 
	set @rptField3 = "F3";
end if;

if(@rptField4 = 'F0') then 
	set @rptField4 = "F4";
end if;


SET @stmt = CONCAT('insert into transactionindetailauditerrors_',inBatchId,' 
(batchUploadId, configId, transactionInRecordsId, fieldNo, errorId, transactionInErrorId,errorData, reportField1Data, reportField2Data, reportField3Data, reportField4Data)
select a.batchUploadId,a.configId,a.transactionInRecordsId,a.fieldno,a.errorId,a.id,a.fieldValue,b.',@rptField1,',b.',@rptField2,',b.',@rptField3,',b.',@rptField4,'
from transactioninerrors_',inBatchId,' a inner join 
transactioninrecords_',inBatchId,' b on a.transactionInRecordsId = b.id
where a.configId = ',inConfigId);

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


SET @stmt = CONCAT('UPDATE transactionIndetailauditerrors_',inBatchId,' JOIN (select fieldNo matchid, macro_Name as label 
from macro_names, transactioninerrors_',inBatchId,' where macro_Names.id = transactioninerrors_',inBatchId,'.macroId) tbl_concat
     ON transactionIndetailauditerrors_',inBatchId,'.fieldNo = tbl_concat.matchid
SET transactionIndetailauditerrors_',inBatchId,'.errorDetails = tbl_concat.label WHERE errorId = 4');

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


SET @stmt = CONCAT('UPDATE transactionindetailauditerrors_',inBatchId,'
  JOIN (select fieldNo matchid, name as label 
from crosswalks, transactioninerrors_',inBatchId,' where crosswalks.id = transactioninerrors_',inBatchId,'.cwId) tbl_concat
     ON transactionIndetailauditerrors_',inBatchId,'.fieldNo = tbl_concat.matchid
SET transactionIndetailauditerrors_',inBatchId,'.errorDetails = tbl_concat.label WHERE errorId = 3');

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

SET @stmt = CONCAT('UPDATE transactionIndetailauditerrors_',inBatchId,'
  JOIN (select fieldNo matchid, validationType as label 
from ref_validationtypes, transactioninerrors_',inBatchId,' where ref_validationtypes.id = transactioninerrors_',inBatchId,'.validationTypeId) tbl_concat
     ON transactionIndetailauditerrors_',inBatchId,'.fieldNo = tbl_concat.matchid
SET transactionIndetailauditerrors_',inBatchId,'.errorDetails = tbl_concat.label WHERE errorId = 2');

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


SET @stmt = CONCAT('UPDATE transactionIndetailauditerrors_',inBatchId,'
  JOIN (select fieldNo as matchid, fieldDesc as label from configurationformfields where configId = ',inConfigId,') tbl_concat
     ON transactionIndetailauditerrors_',inBatchId,'.fieldNo = tbl_concat.matchid
SET transactionIndetailauditerrors_',inBatchId,'.fieldName = tbl_concat.label');

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

-- this part updates the field
-- get our fields

SET @stmt = CONCAT("select group_concat(distinct concat('F', fieldNo)) from transactionindetailauditerrors_",inBatchId," 
where batchUPloadId = ",inBatchId,"  and errorData is null and configId = ",inConfigId," into @fieldNos;
");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;



-- build our update statements 
if (@fieldNos is not null) then

	begin
    
    SET @stmt = CONCAT("
		select distinct group_concat(concat('when fieldNo = ', fieldNo , ' then ', concat('F', fieldNo)) separator ' ' ) from transactionindetailauditerrors_",inBatchId,"
        where batchUPloadId = ",inBatchId," and errorData is null and configId = ",inConfigId," into @updateStmts;
	 ");

		
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
       
        
   if (@updateStmts is not null) then 
    begin
   
	   SET @stmt = CONCAT("
			update transactionindetailauditerrors_",inBatchId," tiae join (
			select id, ", @fieldNos," from transactioninrecords_",inBatchId,") tir
			on tiae.transactionInRecordsId = tir.id
			set errordata = case ",@updateStmts," end
			where batchUPloadId = ",inBatchId,"  and errorData is null  and configId = ",inConfigId," ;
		");
			
            
			PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
	end;
    end if;
    

	end;

end if;


SET @stmt = CONCAT('INSERT INTO batchuploadauditerrors (batchuploadId, configId, fieldNo, fieldName, errorId, errorDetails, errorData, reportField1Data, reportField2Data, reportField3Data, reportField4Data, rownumber) 
select batchUploadId, configId, fieldNo, fieldName, errorId, errorDetails, errorData, reportField1Data, reportField2Data, reportField3Data, reportField4Data, transactionInRecordsId 
from transactionIndetailauditerrors_',inBatchId);

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

select '';

end proc_main$$
DELIMITER ;


/** Macro Update 20200220 **/
USE `universaltranslator`;
DROP procedure IF EXISTS `AlphaNumericCheck`;

DELIMITER $$
USE `universaltranslator`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `AlphaNumericCheck`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing,batchId);
SELECT 
    @translatedTable,
    @transactionTable,
    @batchTable,
    @batchIdType,
    @errorTable,
    @translateCol
INTO @translatedTable , @transactionTable , @batchTable , @batchIdType , @errorTable, @translateCol;

call getFinalStatusIds;
SELECT @finalStatusIds INTO @finalStatusIds;

set @updateString = concat("update ",@translatedTable, " set ", fieldB ," =  ");

if (transactionId = 0) then
	set @whereString = concat("  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");
end if;

if (transactionId != 0) then
	set @whereString = concat("  ",	@transactionTable,".Id = ", transactionId,";");
end if;


set @stmt = concat(@updateString, "null where ",@whereString);

PREPARE stmt from @stmt;
EXECUTE stmt;


set @stmt = concat(@updateString, 
fieldA, " where ", fieldA, " REGEXP '^[a-zA-Z0-9]*$' and ", 
@whereString);

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


	
if (con1 = 'Y') then

	if (transactionId = 0) then
		BEGIN
			set @stmt = concat("insert into ", @errorTable , " (" , @batchIdType, ", configId, " , @translateCol, 
			", fieldNo, errorId, macroId, fieldValue) select " , @batchIdType, ", configId, id, replace('",srcField,"', 'F', ''), ", con2, 
			", ",macroId,",",srcField," from ", @translatedTable, " where (",fieldB," is null or length(",fieldB,") = 0) and ",
			@whereString);
		END;
	END if;

if (transactionId != 0) then
	BEGIN
		set @stmt = concat("insert into ", @errorTable , " (" , @batchIdType, ", configId, " , @translateCol, 
		", fieldNo, errorId, macroId, fieldValue) select " , @batchIdType, ", configId, id, replace('",srcField,"', 'F', ''), ", con2, 
		", ",macroId,",",srcField," from ", @translatedTable, " where (",fieldB," is null or length(",fieldB,") = 0) and ", @whereString);
		
	END;
END if;
	
PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

end if;
     

if (passClear = 2) THEN
BEGIN
 
		set @stmt = concat("update ",@translatedTable, " set ", fieldA ," = ", fieldB , " where " , @whereString);
		PREPARE stmt from @stmt;
		EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
END;
END IF;


select '';
end proc_main$$

DELIMITER ;

/** outbound SP Change **/

USE `universaltranslator`;
DROP procedure IF EXISTS `createTempErrorTable`;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `createTempErrorTable`(in inBatchId int)
proc_main:begin

-- drop the table first
SET @stmt = CONCAT("drop TABLE if exists transactionoutdetailauditerrorsforinbound_",inBatchId);

			PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;


SET @stmt = CONCAT("
CREATE TABLE transactionoutdetailauditerrorsforinbound_",inBatchId," (
  id int(11) NOT NULL AUTO_INCREMENT,
  batchDownloadId int(11) NOT NULL,
  configId int(11) NOT NULL,
  transactionOutRecordsId int(11) NOT NULL,
  fieldNo int(11) NOT NULL,
  fieldName varchar(45) DEFAULT NULL,
  errorId int(11) NOT NULL,
  errorDetails varchar(200) DEFAULT NULL COMMENT 'This field is used to update cw name, validation type name, macro name',
  errorData text,
  reportField1Data varchar(45) DEFAULT NULL,
  reportField2Data varchar(45) DEFAULT NULL,
  reportField3Data varchar(45) DEFAULT NULL,
  reportField4Data varchar(45) DEFAULT NULL,
  transactionOutErrorId int(11) DEFAULT '0',
  PRIMARY KEY (id),
  KEY ttoauditKey",inBatchId,"Error_idx (batchDownloadId)
  ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=latin1;
");

			PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;


end proc_main$$
DELIMITER ;

/** 20200221 **/

USE `universaltranslator`;
DROP procedure IF EXISTS `populateOutboundAuditReport`;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `populateOutboundAuditReport`(in inConfigId int, in inBatchId int, in inBatchUpoadId int, in inBatchUploadConfigId int)
proc_main:begin


SET @stmt = CONCAT('delete from transactionoutdetailauditerrors_',inBatchId,' where configId = ',inConfigId);

--  INSERT INTO sqlstmts (sqlstmt) values (@stmt);

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

SELECT concat('F',rptField1),concat('F',rptField2),concat('F',rptField3),concat('F',rptField4) INTO @rptField1, @rptField2,@rptField3,@rptField4 
FROM configurationmessagespecs where configId = inConfigId LIMIT 1;

SELECT populateInboundAuditReport INTO @populateInboundAuditReport
FROM configurationtransportdetails where configId = inConfigId LIMIT 1;

--  INSERT INTO sqlstmts (sqlstmt) values (@populateInboundAuditReport);

if(@rptField1 = 'F0') then 
	set @rptField1 = "F1";
end if;

if(@rptField2 = 'F0') then 
	set @rptField2 = "F2";
end if;

if(@rptField3 = 'F0') then 
	set @rptField3 = "F3";
end if;

if(@rptField4 = 'F0') then 
	set @rptField4 = "F4";
end if;

SET @stmt = CONCAT('insert into transactionoutdetailauditerrors_',inBatchId,' 
(batchDownloadId, configId, transactionOutRecordsId, fieldNo, errorId, transactionOutErrorId,errorData, reportField1Data, reportField2Data, reportField3Data, reportField4Data)
select a.batchDownloadId,a.configId,a.transactionOutRecordsId,a.fieldno,a.errorId,a.id,a.fieldValue,b.',@rptField1,',b.',@rptField2,',b.',@rptField3,',b.',@rptField4,'
from transactionouterrors_',inBatchId,' a inner join 
transactionoutrecords_',inBatchId,' b on a.transactionOutRecordsId = b.id
where a.configId = ',inConfigId);

--  INSERT INTO sqlstmts (sqlstmt) values (@stmt);

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

SET @stmt = CONCAT('UPDATE transactionoutdetailauditerrors_',inBatchId,' JOIN (select fieldNo matchid, macro_Name as label 
from macro_names, transactionouterrors_',inBatchId,' where macro_Names.id = transactionouterrors_',inBatchId,'.macroId) tbl_concat
     ON transactionoutdetailauditerrors_',inBatchId,'.fieldNo = tbl_concat.matchid
SET transactionoutdetailauditerrors_',inBatchId,'.errorDetails = tbl_concat.label WHERE errorId = 4');

--  INSERT INTO sqlstmts (sqlstmt) values (@stmt);

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

SET @stmt = CONCAT('UPDATE transactionoutdetailauditerrors_',inBatchId,'
  JOIN (select fieldNo matchid, name as label 
from crosswalks, transactionouterrors_',inBatchId,' where crosswalks.id = transactionouterrors_',inBatchId,'.cwId) tbl_concat
     ON transactionoutdetailauditerrors_',inBatchId,'.fieldNo = tbl_concat.matchid
SET transactionoutdetailauditerrors_',inBatchId,'.errorDetails = tbl_concat.label WHERE errorId = 3');

--  INSERT INTO sqlstmts (sqlstmt) values (@stmt);

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

SET @stmt = CONCAT('UPDATE transactionoutdetailauditerrors_',inBatchId,'
  JOIN (select fieldNo matchid, validationType as label 
from ref_validationtypes, transactionouterrors_',inBatchId,' where ref_validationtypes.id = transactionouterrors_',inBatchId,'.validationTypeId) tbl_concat
     ON transactionoutdetailauditerrors_',inBatchId,'.fieldNo = tbl_concat.matchid
SET transactionoutdetailauditerrors_',inBatchId,'.errorDetails = tbl_concat.label WHERE errorId = 2');

--  INSERT INTO sqlstmts (sqlstmt) values (@stmt);

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

SET @stmt = CONCAT('UPDATE transactionoutdetailauditerrors_',inBatchId,'
  JOIN (select fieldNo as matchid, fieldDesc as label from configurationformfields where configId = ',inConfigId,') tbl_concat
     ON transactionoutdetailauditerrors_',inBatchId,'.fieldNo = tbl_concat.matchid
SET transactionoutdetailauditerrors_',inBatchId,'.fieldName = tbl_concat.label');


PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

-- populate missing errorData
-- this part updates the field
-- get our fields

SET @stmt = CONCAT("select group_concat(distinct concat('F', fieldNo)) from transactionoutdetailauditerrors_",inBatchId," 
where batchDownloadId = ",inBatchId,"  and errorData is null and configId = ",inConfigId," into @fieldNos;
");


PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;



-- build our update statements 
if (@fieldNos is not null) then
	
	begin
    
    SET @stmt = CONCAT("
		select distinct group_concat(concat('when fieldNo = ', fieldNo , ' then ', concat('F', fieldNo)) separator ' ' ) from transactionoutdetailauditerrors_",inBatchId,"
        where batchDownloadId = ",inBatchId," and errorData is null and configId = ",inConfigId," into @updateStmts;
	 ");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
       
        
   if (@updateStmts is not null) then 
    begin
   
	   SET @stmt = CONCAT("
			update transactionoutdetailauditerrors_",inBatchId," tiae join (
			select id, ", @fieldNos," from transactionoutrecords_",inBatchId,") tir
			on tiae.transactionoutRecordsId = tir.id
			set errordata = case ",@updateStmts," end
			where batchDownloadId = ",inBatchId,"  and errorData is null  and configId = ",inConfigId," ;
		");
			
            
			PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
	end;
    end if;
    

	end;

end if;



-- clean

delete from batchdownloadauditerrors where batchdownloadId = inBatchid and configId = inConfigId;

--  Populate the batchUploadauditerrors table
SET @stmt = CONCAT('INSERT INTO batchdownloadauditerrors (batchDownloadId, configId, fieldNo, fieldName, errorId, errorDetails, errorData, reportField1Data, reportField2Data, reportField3Data, reportField4Data, rownumber) 
select batchDownloadId, configId, fieldNo, fieldName, errorId, errorDetails, errorData, reportField1Data, reportField2Data, reportField3Data, reportField4Data, transactionOutRecordsId 
from transactionoutdetailauditerrors_',inBatchId);


PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

--  If the target configuration needs to update the inbound audit report
if (@populateInboundAuditReport) then
	
    begin
    
    -- need temp table to hold data needed
    call  createTempErrorTable(inBatchId);
	
    SET @stmt = CONCAT("
			insert into transactionoutdetailauditerrorsforinbound_",inBatchId," 
			select * from transactionoutdetailauditerrors_",inBatchId,";
			");
			
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
            
	        
			SET @stmt = CONCAT("
				ALTER TABLE transactionoutdetailauditerrorsforinbound_",inBatchId,"  
				ADD COLUMN transactionInRecordsId INT NULL AFTER transactionOutErrorId,
				ADD COLUMN inFieldNo  INT NULL  AFTER transactionInRecordsId;
			");
            
            
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;      

			-- get our table data ready
            SET @stmt = CONCAT("
				update transactionoutdetailauditerrorsforinbound_",inBatchId," auditTable join (
				select populateErrorFieldNo, mt.* from configurationconnectionfieldmappings  join 
				( select auditId, transactionInRecordsId, fieldno  from transactionoutrecords_",inBatchId," tir 
				join ( select id as auditId, transactionoutrecordsId, fieldNo from transactionoutdetailauditerrorsforinbound_",inBatchId,") errorTable 
				on tir.id = errorTable.transactionoutrecordsId) mt on mt.fieldNo = configurationconnectionfieldmappings.fieldNo) infoTable
				on infotable.auditid = auditTable.id
				set auditTable.transactionInRecordsId = infoTable.transactionInRecordsId, inFieldNo = populateErrorFieldNo;
			");
            
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;      
            
    
		-- run update to populate the data according to the populateFromFieldNo Id
		SET @stmt = CONCAT("
				select group_concat(distinct concat('F', inFieldNo)) from transactionoutdetailauditerrorsforinbound_",inBatchId,"  where infieldNo != 0  into @inboundFields;
			 ");
            
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;  
           
            
		if (@inboundFields is not null) then 
        
			begin
			
            SET @stmt = CONCAT("
					select group_concat(distinct concat('when infieldNo = ', inFieldNo , ' then ',  concat('F', inFieldNo)) separator ' ' ) 
                    from transactionoutdetailauditerrorsforinbound_",inBatchId," where infieldNo != 0 into @inUpdateFields;
				");
                
			PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;  
            
            
            SELECT concat('F',rptField1),concat('F',rptField2),concat('F',rptField3),concat('F',rptField4) INTO @rptInField1, @rptInField2,@rptInField3,@rptInField4 
			FROM configurationmessagespecs where configId = inBatchUploadConfigId LIMIT 1;
			
            
            	if (@rptInField1 = 'F0') then 
					set @rptInField1 = "F1";
				end if;

				if (@rptInField2 = 'F0') then 
					set @rptInField2 = "F2";
				end if;

				if (@rptInField3 = 'F0') then 
					set @rptInField3 = "F3";
				end if;

				if(@rptInField4 = 'F0') then 
					set @rptInField4 = "F4";
				end if;
            

			SET @stmt = CONCAT("
				update  transactionoutdetailauditerrorsforinbound_",inBatchId," tir join (
				select ",@rptInField1," reportField1Data, ",@rptInField2," reportField2Data, ",@rptInField3," reportField3Data, ",@rptInField4," reportField4Data, 
                transactionInRecordsId, ",@inboundFields," from transactioninrecords_",inBatchUpoadId," tir join 
				(select distinct transactionInRecordsId from transactionoutdetailauditerrorsforinbound_",inBatchId,") auditTable
				on transactionInRecordsId = tir.id) infotable
				on infotable.transactionInRecordsId = tir.transactionInRecordsId
				set errorData = case 
				",@inUpdateFields,"
                end, 
                tir.reportField1Data = infotable.reportField1Data, tir.reportField2Data = infotable.reportField2Data,
                tir.reportField3Data = infotable.reportField3Data, tir.reportField4Data = infotable.reportField4Data
            ");
            
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;  
			
            SET @stmt = CONCAT("
				delete from batchuploadauditerrors where fromOutboundConfig = true and batchUploadId = ",inBatchUpoadId," and configId = ",inBatchUploadConfigId,"
			");
			
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
            
            
            
            SET @stmt = CONCAT("insert into batchuploadauditerrors (batchUploadId, configId, fieldNo, fieldName, errorId, errorDetails, errorData, reportField1Data, 
							reportField2Data, reportField3Data, reportField4Data, rownumber, fromOutboundConfig)
							select ",inBatchUpoadId,", ",inBatchUploadConfigId,", inFieldNo, fieldName,  errorId, errorDetails, errorData, reportField1Data, 
							reportField2Data, reportField3Data, reportField4Data, transactionInRecordsId, true from 
							transactionoutdetailauditerrorsforinbound_",inBatchId,"; ");
    
			PREPARE stmt from @stmt;
			EXECUTE stmt;
            DEALLOCATE PREPARE stmt; 
    
			
            SET @stmt = CONCAT("drop table transactionoutdetailauditerrorsforinbound_",inBatchId,"; ");
    
			PREPARE stmt from @stmt;
			EXECUTE stmt;
            DEALLOCATE PREPARE stmt; 
            
            end;
    end if;
    end;
end if;

select '';

end proc_main$$
DELIMITER ;


/** macro update, referencing wrong field when updating **/
USE `universaltranslator`;
DROP procedure IF EXISTS `concatFieldToList`;

DELIMITER $$
USE `universaltranslator`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `concatFieldToList`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin





call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

set @fields = concat('F', replace(replace(con2, ' ', ''), ',', ',F'));
set @sql = concat("concat_ws('",con1,"', " , @fields , ")");

if (transactionId = 0) then
	BEGIN
		set @stmt = concat("update " ,@translatedTable,  " set ", fieldA, " = ", @sql , 
		" where configId = ",configId," and ",@batchIdType," = ",batchId," and statusId not in (",@finalStatusIds,");");
	end;
end if;


if (transactionId != 0) then
	BEGIN
		set @stmt = concat("update ",@translatedTable, " set ", fieldA," = ", @sql , " where ", @transactionTable,"Id = ", transactionId, ";");
	end;
end if;

PREPARE stmt from @stmt;
EXECUTE stmt;

select '';

end proc_main$$

DELIMITER ;

/** 20200222 new macro **/
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Formula`, `FieldA_Question`, `Con1_Question`, `Con2_Question`, `populateFieldA`) VALUES ('172', '1', 'If List Length is greater than expected length then Error', 'CheckListLengthIfGTError', 'CheckListLengthIfGTError', 'Please enter field to check', 'Please enter number the list length should be', 'Please enter error code to insert', True);

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `CheckListLengthIfGTError`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
SELECT 
    @translatedTable,
    @transactionTable,
    @batchTable,
    @batchIdType,
    @errorTable,
    @translateCol
INTO @translatedTable , @transactionTable , @batchTable , @batchIdType , @errorTable, @translateCol;

call getFinalStatusIds;
SELECT @finalStatusIds INTO @finalStatusIds;


if (transactionId = 0) then
	set @whereString = concat("  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");
end if;

if (transactionId != 0) then
	set @whereString = concat("  ",	@transactionTable,"Id = ", transactionId,";");
end if;


    

	set @stmt = concat("insert into ", @errorTable , " (" , @batchIdColumn, ", configId, " , @translateCol, 
    ", fieldNo, errorId, macroId, fieldValue) select ",@batchIdType,", configId, id, replace('",fieldA,"', 'F', ''), ", con2, 
    ", ",macroId,",",srcField," from ", @translatedTable, " where  LENGTH(",fieldA,") - LENGTH(REPLACE( ",fieldA,", ',', '')) + 1 > ",con1," and ", 
    @whereString);
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
     
     

if (passClear = 2) THEN
BEGIN

END;
END IF;


select '';
end proc_main$$
DELIMITER ;


/** check blank fields macro **/
INSERT INTO `universaltranslator`.`macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Formula`, `FieldA_Question`, `FieldB_Question`, `Con2_Question`, `populateFieldA`) VALUES ('173', '1', 'If Fields are blank then error', 'IfFieldsBlankThenError', 'IfFieldsBlankThenError', 'Please enter field no in addition to SF to check ', 'Please enter field no in addition to SF to check ', 'Please enter error code to insert', False);

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `IfFieldsBlankThenError`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
SELECT 
    @translatedTable,
    @transactionTable,
    @batchTable,
    @batchIdType,
    @errorTable,
    @translateCol
INTO @translatedTable , @transactionTable , @batchTable , @batchIdType , @errorTable, @translateCol;

call getFinalStatusIds;
SELECT @finalStatusIds INTO @finalStatusIds;


if (transactionId = 0) then
	set @whereString = concat("  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");
end if;

if (transactionId != 0) then
	set @whereString = concat("  ",	@transactionTable,"Id = ", transactionId,";");
end if;

	set @sqlConstraintS = concat(" (",srcField," is null or length(",srcField,") = 0)");
    set @sqlConstraintA = "";
    set @sqlConstraintB = "";
    
    if (fieldA != 'F') then 
		 set @sqlConstraintA = concat(" and  (",fieldA," is null or length(",fieldA,") = 0)");
    end if;
    
    if (fieldB != 'F') then 
		 set @sqlConstraintB = concat(" and  (",fieldB," is null or length(",fieldB,") = 0)");
    end if;
    

	set @stmt = concat("insert into ", @errorTable , " (" , @batchIdColumn, ", configId, " , @translateCol, 
    ", fieldNo, errorId, macroId) select ",@batchIdType,", configId, id, replace('",srcField,"', 'F', ''), ", con2, 
    ", ",macroId," from ", @translatedTable, " where",@sqlConstraintS,@sqlConstraintA, @sqlConstraintB, "  and ", 
    @whereString);
	

    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
     
     

if (passClear = 2) THEN
BEGIN

END;
END IF;


select '';
end proc_main$$
DELIMITER ;

/** error text update **/
UPDATE `universaltranslator`.`lu_errorcodes` SET `displayText`='Engagement did not have procedure(s) or one visit type.', `description`='Engagement did not have procedure(s) or one visit type.' WHERE `id`='51';
UPDATE `mainefp`.`lu_errorcodes` SET `displayText`='Engagement did not have procedure(s) or one visit type.', `description`='Engagement did not have procedure(s) or one visit type.' WHERE `id`='51';


/** batchdownloaddroppedvalues table 20200303 **/

drop table if exists batchdownloaddroppedvalues;

CREATE TABLE `batchdownloaddroppedvalues` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `fieldNo` int(11) NOT NULL,
  `batchUploadId` int(11) DEFAULT NULL,
  `batchDownloadId` int(11) NOT NULL,
  `configId` int(11) NOT NULL,
  `transactionOutRecordsId` int(11) DEFAULT NULL,
  `fieldName` varchar(255) DEFAULT NULL,
  `fieldValue` text,
  `reportField1Data` varchar(45) DEFAULT NULL,
  `reportField2Data` varchar(45) DEFAULT NULL,
  `reportField3Data` varchar(45) DEFAULT NULL,
  `reportField4Data` varchar(45) DEFAULT NULL,
  `entity3Id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `fk_batchDownload_idx` (`batchDownloadId`),
  CONSTRAINT `fk_batchDownload` FOREIGN KEY (`batchDownloadId`) REFERENCES `batchdownloads` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=latin1;



drop table if exists batchuploaddroppedvalues;
CREATE TABLE `batchuploaddroppedvalues` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `transactionInRecordsId` varchar(45) DEFAULT NULL,
  `fieldNo` int(11) NOT NULL,
  `batchUploadId` int(11) NOT NULL,
  `configId` int(11) NOT NULL,
  `fieldName` varchar(255) DEFAULT NULL,
  `fieldValue` text,
  `reportField1Data` varchar(45) DEFAULT NULL,
  `reportField2Data` varchar(45) DEFAULT NULL,
  `reportField3Data` varchar(45) DEFAULT NULL,
  `reportField4Data` varchar(45) DEFAULT NULL,
  `entity3Id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `fk_batchUpload_idx` (`batchUploadId`),
  CONSTRAINT `fk_batchUpload` FOREIGN KEY (`batchUploadId`) REFERENCES `batchuploads` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=latin1;


drop procedure if exists populateDroppedValues;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `populateDroppedValues`(in inConfigId int, in inBatchId int, in foroutboundProcessing boolean)
proc_main:begin

set @dvTableName = "batchuploaddroppedvalues";
set @recordName = "transactioninrecords";
set @batchIdCol = "batchUploadId";

if (foroutboundProcessing) then
	begin
		set @dvTableName = "batchdownloaddroppedvalues";
		set @recordName = "transactionoutrecords";
        set @batchIdCol = "batchDownloadId";
        
        select batchuploadid into @batchUploadId from batchdownloads where id = inBatchId;
        delete from   batchdownloaddroppedvalues where batchuploadId = @batchUploadId;
    
        
        SET @stmt = CONCAT("
			update  batchdownloaddroppedvalues t1 join (select batchuploadid, id from batchdownloads where id = ",inBatchId," limit 1) t2
			on t1.batchdownloadId = t2.id
			set t1.batchuploadId = t2.batchuploadid;
		");


PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;
        
        
	end;
end if;

select concat('F', fieldNo) into @entity3IdField from configurationformfields where configId = inConfigId and fieldDesc = 'rrEntity3' limit 1;


SELECT concat('F',rptField1),concat('F',rptField2),concat('F',rptField3),concat('F',rptField4) INTO @rptField1, @rptField2,@rptField3,@rptField4 
FROM configurationmessagespecs where configId = inConfigId LIMIT 1;

-- get rrEntity3Id field

if(@rptField1 = 'F0') then 
	set @rptField1 = "F1";
end if;

if(@rptField2 = 'F0') then 
	set @rptField2 = "F2";
end if;

if(@rptField3 = 'F0') then 
	set @rptField3 = "F3";
end if;

if(@rptField4 = 'F0') then 
	set @rptField4 = "F4";
end if;

if(@entity3IdField is null) then 
	set @entity3IdField = "F1";
end if;


SET @stmt = CONCAT("
update  ",@dvTableName," t1 join 
(Select id, ",@rptField1," rptField1, ",@rptField2 ," rptField2, ",@rptField3," rptField3, ",@rptField4 ," rptField4, 
",@entity3IdField," rrEntity3Id from ",@recordName ,"_",inBatchId,") t2
on t1.",@recordName ,"Id = t2.id
set reportField1Data = rptField1,
reportField1Data = rptField1,
reportField1Data = rptField1,
reportField1Data = rptField1,
entity3Id = rrEntity3Id
where t1.",@batchIdCol," = ",inBatchId," and configId = ",inConfigId,";
");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

select '';

end proc_main$$
DELIMITER ;

ALTER TABLE `universaltranslator`.`batchdownloaddroppedvalues` 
ADD INDEX `batchUploadIdIdx` (`batchUploadId` ASC);


ALTER TABLE `universaltranslator`.`batchdownloaddroppedvalues` 
ADD COLUMN `transactionInRecordsId` INT Not NULL AFTER `configId`;

/** new update 20200304 **/
drop procedure if exists applyCWTranslatedList;
DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `applyCWTranslatedList`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin 

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @listTable, @translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @listTable, @translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


if (transactionId = 0) then
	set @whereString = concat(" and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");
end if;

if (transactionId != 0) then
	set @whereString = concat(" and ",	@transactionTable,".id = ", transactionId,";");
end if;


set @fcol = replace(lcase(fieldA), 'f', '');
set @stmt = concat("delete from ", @listTable," where fcol = ",@fcol," and ",@batchIdType," = ", batchId ,";");


PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

	set @stmt = concat("
    insert into ", @listTable," (",@batchIdType,", ",@translateCol,", invalue, fcol)
    SELECT ",@batchIdType,", ",@translateCol,", trim(SUBSTRING_INDEX(SUBSTRING_INDEX(t.",fieldA,", ',', n.n), ',', -1)) value, ",@fcol,"
	FROM ",@translatedTable ," t CROSS JOIN (
    SELECT a.N + b.N * 10 + 1 n FROM  
   (select id N from ref_numbers where id <=50) a
   ,(select id N from ref_numbers where id <=50) b
    ORDER BY n) n  WHERE n.n <= 1 + (LENGTH(t.",fieldA,") - LENGTH(REPLACE(t.",fieldA,", ',', ''))) ", @whereString);
   
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

    
    
    set @stmt2 = "";
	set @stmt1 = concat("update ",@listTable," join (select id, sourcevalue, targetvalue from rel_crosswalkdata where crosswalkid = ", con1 ,") cwdata
	on invalue = sourcevalue set translatedvalue = targetvalue where ",@batchIdType," = ", batchId);
    if (transactionId != 0) then
		set @stmt2 = concat(" and ", @translateCol , " = ", transactionId);
	END if;
    
    
	
    set @stmt = concat(@stmt1, @stmt2);
   
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    
  
	set @selDistinct = ' distinct ';
    
    if (con2 = 'N') then
		begin
			set @selDistinct = '';
        end;
    end if;
  
    set @stmt1 = concat("update ",@translatedTable," join  (select ",@translateCol," as matchId, 
    group_concat(",@selDistinct," translatedValue order by translatedValue) label from  ",@listTable,"
	where ",@batchIdType," = ",batchid, " and fcol = ",@fCol," group by ",@translateCol," ) cwmatch on ",@translateCol," = matchid set ",fieldB," = label ");
	
    set @stmt2="";
	
    if (passClear = 1) then
		set @stmt2= " where label is not null";
	end if;

	
    set @stmt = concat(@stmt1, @stmt2);
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    
	/** track drop and kept values **/
    set @colText = "in";
    if (foroutboundProcessing) then
		set @colText = "out";
    end if;
    

    set @stmt = concat("
		insert into transaction",@colText,"macrodroppedvalues_",batchId," (",@batchIdColumn ,", transaction",@colText,"RecordsId, fieldNo, fieldValue, matchId, configId) 
		select distinct ",batchId,", transaction",@colText,"RecordsId, fcol, invalue,concat(",configId,", '_', fcol, '_', invalue), ",configId," from transactiontranslatedlist",@colText,"_",batchId," where translatedValue is null and length(invalue) > 0;
	");

	PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;


	set @stmt = concat("
		insert into transaction",@colText,"macrokeptvalues_",batchId," (",@batchIdColumn ,", transaction",@colText,"RecordsId, fieldNo, fieldValue, matchId, configId) 
		select distinct ",batchId,", transaction",@colText,"RecordsId, fcol, invalue, concat(",configId,", '_', fcol, '_', invalue), ",configId," from transactiontranslatedlist",@colText,"_",batchId," where translatedValue is not null;
	");
 
	PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

    
	/**
    set @stmt = concat("delete from ", @listTable, " where ",@batchIdType," = ",batchId," and fcol = ",@fcol);
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    **/
   


select '';
end proc_main$$
DELIMITER ;


drop procedure if exists populateDroppedValues;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `populateDroppedValues`(in inConfigId int, in inBatchId int, in foroutboundProcessing boolean)
proc_main:begin

set @dvTableName = "batchuploaddroppedvalues";
set @recordName = "transactioninrecords";
set @batchIdCol = "batchUploadId";
set @colDirection = "in";

if (foroutboundProcessing)  then
		set @dvTableName = "batchdownloaddroppedvalues";
		set @recordName = "transactionoutrecords";
        set @batchIdCol = "batchDownloadId";
        set @colDirection = "out";
end if;

-- clean up first
SET @stmt = CONCAT("
delete dropv from transaction",@colDirection,"macrodroppedvalues_",inBatchId," dropv join (
select matchid from transaction",@colDirection,"macrokeptvalues_",inBatchId,") keptv
on keptv.matchId = dropv.matchId;
");


PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


SET @stmt = CONCAT("
insert into ",@dvTableName ," (",@batchIdCol,", transaction",@colDirection,"recordsId, fieldNo, configId, fieldName, fieldValue)
select distinct ",inBatchId,", t1.transaction",@colDirection,"recordsId, t1.fieldNo, t1.configId, fieldDesc, 
t1.fieldValue from transaction",@colDirection,"macrodroppedvalues_",inBatchId," t1 
join (select * from configurationformfields) t2
on t1.configId = t2.configId
and t1.fieldNo = t2.fieldno;
");


PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


if (foroutboundProcessing) then
	begin
		
         select batchuploadid into @batchUploadId from batchdownloads where id = inBatchId;
        delete from   batchdownloaddroppedvalues where batchuploadId = @batchUploadId;
    
        
        SET @stmt = CONCAT("
			update  batchdownloaddroppedvalues t1 join (select transactionInRecordsId, batchUploadId, batchDownloadId from transactionoutrecords_",inBatchId," t1 
            join (select distinct batchUploadId, id from batchdownloads where id = ",inBatchId,")  t2
			on t1.batchDownloadId = t2.id) t2
			on t1.batchdownloadId = t2.batchDownloadId
			set t1.batchuploadId = t2.batchuploadid,
            t1.transactionInRecordsId = t2.transactionInRecordsId
            where t1.batchdownloadId = ",inBatchId,";
		");


PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;
        
        
	end;
end if;

select concat('F', fieldNo) into @entity3IdField from configurationformfields where configId = inConfigId and fieldDesc = 'rrEntity3' limit 1;


SELECT concat('F',rptField1),concat('F',rptField2),concat('F',rptField3),concat('F',rptField4) INTO @rptField1, @rptField2,@rptField3,@rptField4 
FROM configurationmessagespecs where configId = inConfigId LIMIT 1;

-- get rrEntity3Id field

if(@rptField1 = 'F0') then 
	set @rptField1 = "F1";
end if;

if(@rptField2 = 'F0') then 
	set @rptField2 = "F2";
end if;

if(@rptField3 = 'F0') then 
	set @rptField3 = "F3";
end if;

if(@rptField4 = 'F0') then 
	set @rptField4 = "F4";
end if;

-- rr entity3 on the inbound is  from transactionTranslatedIn table as it is always populated by macros
if(@entity3IdField is null) then 
	set @entity3IdField = "F1";
end if;


SET @stmt = CONCAT("
update  ",@dvTableName," t1 join 
(Select transaction",@colDirection,"RecordsId, t1.",@rptField1," rptField1, t1.",@rptField2," rptField2, t1.",@rptField3," rptField3, t1.",@rptField4," rptField4, 
rrEntity3Id from transaction",@colDirection,"records_",inBatchId," t1 join
(select ",@entity3IdField," rrEntity3Id, transaction",@colDirection,"RecordsId from transactiontranslated",@colDirection,"_",inBatchId,") t2
on t1.id = t2.transaction",@colDirection,"RecordsId) t2
on t1.",@recordName ,"Id = t2.",@recordName,"Id 
set reportField1Data = rptField1,
reportField2Data = rptField2,
reportField3Data = rptField3,
reportField4Data = rptField4,
entity3Id = rrEntity3Id 
where t1.",@batchIdCol," = ",inBatchId," and configId = ",inConfigId,";
");


PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;






select '';

end proc_main$$
DELIMITER ;


drop table if exists batchdownloaddroppedvalues;

CREATE TABLE `batchdownloaddroppedvalues` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `fieldNo` int(11) NOT NULL,
  `batchUploadId` int(11) DEFAULT NULL,
  `batchDownloadId` int(11) NOT NULL,
  `configId` int(11) NOT NULL,
  `transactionInRecordsId` int(11) DEFAULT NULL,
  `transactionOutRecordsId` int(11) DEFAULT NULL,
  `fieldName` varchar(255) DEFAULT NULL,
  `fieldValue` text,
  `reportField1Data` varchar(45) DEFAULT NULL,
  `reportField2Data` varchar(45) DEFAULT NULL,
  `reportField3Data` varchar(45) DEFAULT NULL,
  `reportField4Data` varchar(45) DEFAULT NULL,
  `entity3Id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `fk_batchDownload_idx` (`batchDownloadId`),
  KEY `batchUploadIdIdx` (`batchUploadId`),
  CONSTRAINT `fk_batchDownload` FOREIGN KEY (`batchDownloadId`) REFERENCES `batchdownloads` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION
) ENGINE=InnoDB DEFAULT CHARSET=latin1;

drop table if exists batchuploaddroppedvalues;
CREATE TABLE `batchuploaddroppedvalues` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `transactionInRecordsId` varchar(45) DEFAULT NULL,
  `fieldNo` int(11) NOT NULL,
  `batchUploadId` int(11) NOT NULL,
  `configId` int(11) NOT NULL,
  `fieldName` varchar(255) DEFAULT NULL,
  `fieldValue` text,
  `reportField1Data` varchar(45) DEFAULT NULL,
  `reportField2Data` varchar(45) DEFAULT NULL,
  `reportField3Data` varchar(45) DEFAULT NULL,
  `reportField4Data` varchar(45) DEFAULT NULL,
  `entity3Id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `fk_batchUpload_idx` (`batchUploadId`),
  CONSTRAINT `fk_batchUpload` FOREIGN KEY (`batchUploadId`) REFERENCES `batchuploads` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION
) ENGINE=InnoDB DEFAULT CHARSET=latin1;


USE `universaltranslator`;
DROP procedure IF EXISTS `ifFieldANotInListValuesSetToCon2`;

DELIMITER $$
USE `universaltranslator`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `ifFieldANotInListValuesSetToCon2`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

-- if there is a value in the field that is not in the cw, it should be defaulted to con2

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

	set @leaveBlanks = "";


set @dropTable = "batchuploaddroppedvalues";
set @colDirection = "in";

if (foroutboundProcessing) then

	set @dropTable = "batchdownloaddroppedvalues";
	set @colDirection = "out";
    
end if;

 set @stmt = concat("select fieldDesc into @fieldName from configurationformfields where configId = ",configId," and fieldNo = replace('",fieldA,"', 'F', '') limit 1;");


    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;


if (transactionId = 0) then
	BEGIN
    
    set @stmt1 = concat("
    insert into ",@dropTable,"
    (transaction",@colDirection,"RecordsId, fieldNo, ",@batchIdType ,", configId, fieldName, fieldValue) 
     select transaction",@colDirection,"RecordsId, replace('",fieldA,"', 'F', ''), ",@batchIdType,", configId, '",@fieldName,"', ",fieldA,"
     from ",@translatedTable," where   ",fieldA," is not null and length(",fieldA,") != 0 and 
    ",fieldA ," not in (select sourcevalue from rel_crosswalkdata where crosswalkId = ",con1,")  ",@leaveBlanks,"
    and  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");
    
	set @stmt = concat("update ",@translatedTable, " set ", fieldB, " = '",con2,"' where   ",fieldA," is not null and length(",fieldA,") != 0 and 
    ",fieldA ," not in (select sourcevalue from rel_crosswalkdata where crosswalkId = ",con1,")  ",@leaveBlanks,"
    and  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");
	
	END;
	END if;

if (transactionId != 0) then
	BEGIN
    
        set @stmt1 = concat("
    insert into ",@dropTable,"
    (transaction",@colDirection,"RecordsId, fieldNo, ",@batchIdType ,", configId, fieldName, fieldValue) 
     select transaction",@colDirection,"RecordsId, replace('",fieldA,"', 'F', ''), ",@batchIdType,", configId, '",@fieldName,"', ",fieldA,"
     from ",@translatedTable," where  ",fieldA," is not null and length(",fieldA,") != 0 and  ",FieldA," 
    not in (select sourcevalue from rel_crosswalkdata where crosswalkId = ", con1 ,")",
				 " and ",@transactionTable,"Id = ", transactionId, ";");
    
	set @stmt = concat("update ",@translatedTable, " set ",fieldB, " = '",con2," where  ",fieldA," is not null and length(",fieldA,") != 0 and  ",FieldA," 
    not in (select sourcevalue from rel_crosswalkdata where crosswalkId = ", con1 ,")",
				 " and ",@transactionTable,"Id = ", transactionId, ";");
	
    END;
	END if;
   
	PREPARE stmt1 from @stmt1;
	EXECUTE stmt1;
    DEALLOCATE PREPARE stmt1;
   
   

    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;




select '';
end proc_main$$

DELIMITER ;


