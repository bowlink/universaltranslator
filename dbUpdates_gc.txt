/** gc macro changes 20201008 **/

USE `universaltranslatorca`;
DROP procedure IF EXISTS `CheckLengthAndReplace`;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `CheckLengthAndReplace`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);

SELECT 
    @translatedTable,
    @transactionTable,
    @batchTable,
    @batchIdType,
    @errorTable
INTO @translatedTable , @transactionTable , @batchTable , @batchIdType , @errorTable;

call getFinalStatusIds;
SELECT @finalStatusIds INTO @finalStatusIds;

      -- check to see if con1 is numeric
      if con1 REGEXP '^[]?[0-9]*[]{0,1}[0-9]*$' = 0 then 
					begin
						set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'CheckLengthAndReplace Con1 - ",con1,"  must be a numeric value'",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            -- update all transactions to macro_error
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							 
                             PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
           
			leave proc_main;
        end;
      end if;
      
		
        set @con1is0 = '';
        if (con1 = '0') then 
			set @con1is0 = concat(" or ", srcField," is null");
        end if;
        
      	
		set @stmt = concat("update ",@translatedTable, " set ",srcField," =  '", con2, "'",
		"   where (length(",srcField, ") = ",con1," ", @con1is0, ")  and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end proc_main$$
DELIMITER ;


UPDATE `universaltranslatorca`.`macro_Names` SET `Formula`='copyField' WHERE `ID`='87';

USE `universaltranslatorca`;
DROP procedure IF EXISTS `copyField`;

USE `universaltranslatorca`;
DROP procedure IF EXISTS `copyColumn`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `copyField`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

	set @stmt = concat("update ",@translatedTable, " set ",srcField," = ", fieldB, 
    " where configId = ",configId," and ", @batchIdColumn, " = ",batchId," and statusId not in (",@finalStatusIds,");");	
    
	PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;

end proc_main$$

DELIMITER ;


UPDATE `universaltranslatorca`.`macro_Names` SET `Macro_Name`='Check - Years Difference between Dates, i.e. DOB', `Macro_Short_Name`='yearDiffinsertError', `Formula`='yearDiffinsertError' WHERE `ID`='103';

USE `universaltranslatorca`;
DROP procedure IF EXISTS `DOBCheck`;

USE `universaltranslatorca`;
DROP procedure IF EXISTS `yearDiffinsertError`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `yearDiffinsertError`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

-- check to make sure con1 is a numeric value
 if con1 REGEXP '^-?[0-9]+[.]?[0-9]*$|^-?[.][0-9]+$' = 0 then 
					begin
						set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, fieldValue, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'DOBCheck Con1 - \"",con1,"\"  must be numeric value'",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							 
                             PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
           
			leave proc_main;
        end;
      end if;


-- we expect 4 digit years
set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where forcw is null
					and (
                    (length(",srcField,") = 0 and  length(",fieldA,") > 0)
                    or 
                    (length(",fieldA,") = 0 and  length(",srcField,") > 0)
                    or 
                    (",fieldA," is null and  length(",srcField,") > 0)
                    or 
					(",srcField," is null and  length(",fieldA,") > 0)
                    or  ( length(",srcField,") > 0 and substring(",srcField,",5,1) != '-' )
                    or (length(",fieldA,") > 0 and substring(",fieldA,",5,1) != '-')
                    )
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

-- now we find the ones that are not valid
set @stmt = concat("select group_concat(id) from " , @translatedTable, " where
 ((Date(",srcField,") is null and length(",srcField,") > 0)  or  (Date(",fieldA,") is null and length(",fieldA,") > 0 ))
 or (YEAR(",fieldA,") - YEAR(",srcField,") < ",con1,") 
 or (
 YEAR(",fieldA,") - YEAR(",srcField,") - (DATE_FORMAT(",fieldA,", '%m%d') < DATE_FORMAT(",srcField,", '%m%d')) < ",con1,"
 )
 and  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

if (@errorIds is not null) then

	begin

		set @stmt = concat("update " , @translatedTable, "  set forCW = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
	end;
end if;

set @errorIds = '';


end proc_main$$

DELIMITER ;


/** ifFieldNotCon1ThenNull **/

UPDATE `universaltranslatorca`.`macro_Names` SET `Formula`='ifSFNotCon1ThenClear' WHERE `ID`='148';

USE `universaltranslatorca`;
DROP procedure IF EXISTS `ifFieldNotCon1ThenNull`;

USE `universaltranslatorca`;
DROP procedure IF EXISTS `ifSFNotCon1ThenClear`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `ifSFNotCon1ThenClear`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

	set @stmt = concat("update ",@translatedTable, " set ",srcField, " = '' ",
				" where  ",srcField," != '",con1,"' and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
end proc_main$$

DELIMITER ;


/** IfFACon1AndSFBlankSetSFToCon2 **/

UPDATE `universaltranslatorca`.`macro_Names` SET `Formula`='IfFACon1AndSFBlankSetSFToCon2' WHERE `ID`='108';

USE `universaltranslatorca`;
DROP procedure IF EXISTS `IfMatchFieldAAndSFBlankSetSFValue`;

USE `universaltranslatorca`;
DROP procedure IF EXISTS `IfFACon1AndSFBlankSetSFToCon2`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `IfFACon1AndSFBlankSetSFToCon2`(in configId int,
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255),
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

set @stmt = concat("update ",@translatedTable, " set ",srcField," = '",con2, "'
     where " ,fieldA, " = '",con1, "' and length(",srcField,") = 0 and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");


PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

end proc_main$$

DELIMITER ;


/** ifSFMatchCon1SetFAtoFB **/

UPDATE `universaltranslatorca`.`macro_Names` SET `Formula`='IfSFMatchCon1SetFAtoFB', `FieldB_Question`='Please enter field number to copy to FA', `Con1_Question`='Please enter value to match to SF' WHERE `ID`='99';

USE `universaltranslatorca`;
DROP procedure IF EXISTS `IfMatchSetToValueOfAnotherColumn`;

USE `universaltranslatorca`;
DROP procedure IF EXISTS `IfSFMatchCon1SetFAtoFB`;


DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `IfSFMatchCon1SetFAtoFB`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

	call setInboundOutBoundTables (foroutboundProcessing,batchId);
	select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
	into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

	call getFinalStatusIds;
	select @finalStatusIds into @finalStatusIds;

	set @stmt = concat("update ",@translatedTable, " set ",fieldA," = ",fieldB, " 
     where " ,srcField, " = '",con1, "' and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");

	PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;


end proc_main$$

DELIMITER ;


/**  ifSFMatchCon1ThenCon2ElseClear **/

UPDATE `universaltranslatorca`.`macro_Names` SET `Macro_Short_Name`='ifSFMatchCon1ThenCon2ElseClear', `Formula`='ifSFMatchCon1ThenCon2ElseClear' WHERE `ID`='109';

USE `universaltranslatorca`;
DROP procedure IF EXISTS `ifSFMatchCon1ThenCon2ElseNull`;

USE `universaltranslatorca`;
DROP procedure IF EXISTS `ifSFMatchCon1ThenCon2ElseClear`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `ifSFMatchCon1ThenCon2ElseClear`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set ",srcField, " = case when ", srcField, " = '",con1,"' then '", con2 , "' else '' end",
		" where  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");
		
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


end proc_main$$

DELIMITER ;


/** IfSFBlankSetToFA **/

UPDATE `universaltranslatorca`.`macro_Names` SET `Macro_Short_Name`='If SF is empty, copy FA to SF', `Formula`='IfSFBlankSetToFA' WHERE `ID`='131';

USE `universaltranslatorca`;
DROP procedure IF EXISTS `IfSFNullOrEmptySetToFieldAValue`;

USE `universaltranslatorca`;
DROP procedure IF EXISTS `IfSFBlankSetToFA`;


DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `IfSFBlankSetToFA`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


	set @stmt = concat("update ",@translatedTable, " set ",srcField," = ",fieldA, " 
     where (length(",srcField, ") = 0 or ", srcField ," is null) and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") ");
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;


end proc_main$$

DELIMITER ;

/** ifStartsWithCon1UpdateToCon2 **/

USE `universaltranslatorca`;
DROP procedure IF EXISTS `ifStartsWithCon1UpdateToCon2`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `ifStartsWithCon1UpdateToCon2`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


	set @stmt = concat("update ",@translatedTable, " set ",srcField, " = '", con2, "'    where left(",srcField,", ", length(con1), ") = '",con1,"' ",
				" and  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    if (length(con1) = 0) then
		set @stmt = concat("update ",@translatedTable, " set ",srcField," = '",con2,"' where (",srcField," is null or ",srcField," = '')
		and  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (", @finalStatusIds, ");");

	PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt; 

end if;
    

end proc_main$$

DELIMITER ;


/** MatchFAtoCon1UpdateSFtoCon2 **/
UPDATE `universaltranslatorca`.`macro_Names` SET `Formula`='MatchFAtoCon1UpdateSFtoCon2' WHERE `ID`='2';

USE `universaltranslatorca`;
DROP procedure IF EXISTS `MatchFAUpdateSF`;


USE `universaltranslatorca`;
DROP procedure IF EXISTS `MatchFAtoCon1UpdateSFtoCon2`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `MatchFAtoCon1UpdateSFtoCon2`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


set @stmt = concat("update ",@translatedTable, " set ",srcField," = '",con2,"' where trim(REPLACE(CONVERT(",fieldA," USING ASCII), '?','')) = '",con1,"'
and  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (", @finalStatusIds, ");");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt; 

if (length(con1) = 0) then
	set @stmt = concat("update ",@translatedTable, " set ",srcField," = '",con2,"' where (",fieldA," is null or ",fieldA," = '')
	and  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (", @finalStatusIds, ");");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt; 

end if;

end proc_main$$

DELIMITER ;

/** MatchSFtoCon1UpdateFBtoCon2 **/

UPDATE `universaltranslatorca`.`macro_Names` SET `Formula`='MatchSFtoCon1UpdateFBtoCon2' WHERE `ID`='1';

USE `universaltranslatorca`;
DROP procedure IF EXISTS `MatchSrcFieldUpdateFieldB`;

USE `universaltranslatorca`;
DROP procedure IF EXISTS `MatchSFtoCon1UpdateFBtoCon2`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `MatchSFtoCon1UpdateFBtoCon2`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

	set @stmt = concat("update ",@translatedTable, " set ",fieldB," = '",con2,"' where trim(REPLACE(CONVERT(",srcField," USING ASCII), '?','')) = '",con1,"'
				and  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


if (length(con1) = 0) then
		set @stmt = concat("update ",@translatedTable, " set ",fieldB," = '",con2,"' where (",srcField," is null or ",srcField," = '')
		and  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (", @finalStatusIds, ");");

	PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt; 
    
end if;


end proc_main$$

DELIMITER ;

/** mergeValues **/

USE `universaltranslatorca`;
DROP procedure IF EXISTS `mergeValues`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `mergeValues`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

set @con1 = concat('F', con1);
set @con2 = concat('F', con2);


set @stmt = concat("update ",@translatedTable," set forcw = concat_ws('', ",fieldA,", '_', ",fieldB,", '_', ",@con1,");");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;  


set @stmt = concat("update ",@translatedTable," tt 
join  (select group_concat(",@con2,") mser, forcw from ",@translatedTable," group by forcw)  ms on ms.forcw = tt.forcw set ",@con2," =ms.mser;");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt; 


end proc_main$$

DELIMITER ;


/** overwrite SF **/

UPDATE `universaltranslatorca`.`macro_Names` SET `Formula`='overwriteSF' WHERE `ID`='86';

USE `universaltranslatorca`;
DROP procedure IF EXISTS `overwriteColumn`;

USE `universaltranslatorca`;
DROP procedure IF EXISTS `overwriteSF`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `overwriteSF`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

	call setInboundOutBoundTables (foroutboundProcessing,batchId);
	select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
	into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

	call getFinalStatusIds;
	select @finalStatusIds into @finalStatusIds;

	 set @stmt = concat("update ",@translatedTable, " set ",srcField," = '",con1, "' 
     where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");

	PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;

end proc_main$$

DELIMITER ;

/** overwriteColumnWithRandomNumber **/

UPDATE `universaltranslatorca`.`macro_Names` SET `Formula`='overwriteSFWithRandomNumber' WHERE `ID`='89';

USE `universaltranslatorca`;
DROP procedure IF EXISTS `overwriteColumnWithRandomNumber`;

USE `universaltranslatorca`;
DROP procedure IF EXISTS `overwriteSFWithRandomNumber`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `overwriteSFWithRandomNumber`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

declare _rc varchar(255);
begin
	set _rc = cast(FLOOR(1000000000 + (RAND() * 8999999999)) AS char);
    select _rc;
             
end; 

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn;

	set @stmt = concat("update ",@translatedTable, " set ",srcField," = '",_rc, "' 
    where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");

	PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;

end proc_main$$

DELIMITER ;

/** replaceChars **/

UPDATE `universaltranslatorca`.`macro_Names` SET `Formula`='replaceCon1CharswithCon2' WHERE `ID`='72';

USE `universaltranslatorca`;
DROP procedure IF EXISTS `replaceChars1`;

USE `universaltranslatorca`;
DROP procedure IF EXISTS `replaceChars`;

USE `universaltranslatorca`;
DROP procedure IF EXISTS `replaceCon1CharswithCon2`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `replaceCon1CharswithCon2`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

			if (length(con1) = 0) then
							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'replaceCon1CharswithCon2 Con1 - ",con1,"  cannot be blank'",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            -- update all transactions to macro_error
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							 
                             PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
				leave proc_main;
            end if;



            set @stmt = concat("update ", @translatedTable, " set ",srcField," = replace_ci(",srcField,", '",con1,"','",con2,"') 
			where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");
				
			PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
            
end proc_main$$

DELIMITER ;

/**   setFieldToNull **/
UPDATE `universaltranslatorca`.`macro_Names` SET `Macro_Short_Name`='Clear SF', `Formula`='ClearSF', `Con2_Question`='', `macroDesc`='Clear the field' WHERE `ID`='70';

USE `universaltranslatorca`;
DROP procedure IF EXISTS `setFieldToNull`;

USE `universaltranslatorca`;
DROP procedure IF EXISTS `clearSF`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `clearSF`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


		set @stmt = concat("update ",@translatedTable, " set ",srcField," = '' where 
        configId = ",configId," and ",@batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


end proc_main$$

DELIMITER ;


/** stripCharAtPos **/


USE `universaltranslatorca`;
DROP procedure IF EXISTS `stripCharAtPos`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `stripCharAtPos`(in configId int, 
in batchId int, in srcField varchar(10), in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


-- check to see if con1 is numeric
      if con1 REGEXP '^[]?[0-9]*[]{0,1}[0-9]*$' = 0 then 
					begin
						set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'stripCharAtPos Con1 - ",con1,"  must be a numeric value'",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            -- update all transactions to macro_error
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							 
                             PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
           
			leave proc_main;
        end;
      end if;

set @readField = srcField;
set @strCompare = '';


if (length(trim(con2)) != 0) then
	begin 
		set @strCompare = concat(" and substring(", @readField, ",", con1, ", 1) = '", con2, "'");
	end;
end if; 


select @readField;

set @stmt = concat("update ",@translatedTable, " set ",srcField," = concat(substring(", @readField,", 1, (", con1, "-1)), 
substring(", @readField, ", (", con1, " + 1),length(", @readField,")- ", con1,")) where length(", @readField,") >= " ,con1 , 
@strCompare, "  and  configId = ",configId," and ",@batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


end proc_main$$

DELIMITER ;


/** substringToAnotherField **/

USE `universaltranslatorca`;
DROP procedure IF EXISTS `substringToAnotherField`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `substringToAnotherField`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

	call setInboundOutBoundTables (foroutboundProcessing,batchId);
	SELECT 
		@translatedTable,
		@transactionTable,
		@batchTable,
		@batchIdType,
		@errorTable
	INTO @translatedTable , @transactionTable , @batchTable , @batchIdType , @errorTable;

	call getFinalStatusIds;
	SELECT @finalStatusIds INTO @finalStatusIds;

	-- check to make sure con1 and con2 are numeric
    
	if con1 REGEXP '^[]?[0-9]*[]{0,1}[0-9]*$' = 0 or   con2 REGEXP '^[]?[0-9]*[]{0,1}[0-9]*$' = 0 then 
					begin
			
							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, fieldValue, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'substringToAnotherField macro Either - Con1 - \"",con1,"\"  or Con2 - \"",con2,"\" is not a numeric value'",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							 
							PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
           
			leave proc_main;
        end;
      end if;

		set @stmt = concat("update ",@translatedTable, " set ",fieldA," =  ",
		" substring(" , srcField, ", ", con1,",", con2,")  where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


end proc_main$$

DELIMITER ;


/** Populate Race Fix **/

UPDATE `universaltranslatorca`.`macro_Names` SET `FieldA_Question`='' WHERE `ID`='174';
drop procedure if exists PopulateFPRaceIdAndFields;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `PopulateFPRaceIdAndFields`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin



call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @listTable, @translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @listTable, @translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;
			
            set @whereString = concat("  where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
			
            
            -- we need to keep original value, store it in forcw first
            set @stmt = concat("
				update ",@translatedTable, " set forcw = ",srcField,";
			");
            
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt; 
            
			set @stmt = concat("
				select length(concat_ws('', F17,F18,F19,F20,F21,F22,F23,F30)) fieldLen from ",@translatedTable, @whereString, " order by fieldLen desc limit 1 into @fieldLen;
			");
            
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
         
    
        if (@fieldLen = 0) then
    
    
		begin
				set @stmt = concat("update ",@translatedTable," set F17 = case when concat(',', ",srcField,", ',') like '%,1,%' then '",con1,"' else '' end",@whereString,";");
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
				set @stmt = concat("update ",@translatedTable," set F18 = case when concat(',', ",srcField,", ',') like '%,2,%' then '",con1,"' else '' end",@whereString,";");
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
                
				set @stmt = concat("update ",@translatedTable," set F19 = case when concat(',', ",srcField,", ',') like '%,3,%' then '",con1,"' else '' end",@whereString,";");
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
                
                set @stmt = concat("update ",@translatedTable," set F20 = case when concat(',', ",srcField,", ',') like '%,4,%' then '",con1,"' else '' end",@whereString,";");
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
                
                set @stmt = concat("update ",@translatedTable," set F21 = case when concat(',', ",srcField,", ',') like '%,5,%' then '",con1,"'  else '' end",@whereString,";");
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
                
                set @stmt = concat("update ",@translatedTable," set F22 = case when concat(',', ",srcField,", ',') like '%,7,%' then '",con1,"'  else '' end",@whereString,";");
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
                
                set @stmt = concat("update ",@translatedTable," set F23 = case when concat(',', ",srcField,", ',') like '%,6,%' then '",con1,"' else '' end",@whereString,";");
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
                
                set @stmt = concat("update ",@translatedTable," set F30 = case when concat(',', ",srcField,", ',') like '%,8,%' then'",con1,"'  else '' end ",@whereString,";");
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
	
    end;
    
    end if;
				
                set @stmt = concat("
				update ",@translatedTable," set ",srcField," =  case 
				when ( length(concat_ws('', F17,F18,F19,F20,F21,F23)) > 1)  and  (length(concat_ws('', F22, F30)) = 0) then 6 
				when (F22 = '",con1,"' and length(concat_ws('', F17,F18,F19,F20,F21, F23, F30)) = 0) then 7
				when (F30 ='",con1,"' and length(concat_ws('', F17,F18,F19,F20, F21, F23, F22)) = 0) then 8
				when (F17 = '",con1,"' and length(concat_ws('', F22,F30)) = 0) then 1  when (F18 = '",con1,"' and length(concat_ws('', F22,F30)) = 0) then 2 
				when (F19 = '",con1,"' and length(concat_ws('', F22,F30)) = 0) then 3 when (F20 = '",con1,"' and length(concat_ws('', F22,F30)) = 0)then 4 
				when (F21 = '",con1,"' and length(concat_ws('', F22,F30)) = 0)then 5 when (F23 = '",con1,"' and length(concat_ws('', F22,F30)) = 0)  then 6
				else '' end ",@whereString,"
			");
            
            
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
            
			   
				-- put back forcw value so it can be passed
                -- track the ids that are changed
                
                set @errorIds = '';
                
                set @stmt = concat("
				select  group_concat(id) from ",@translatedTable, "
                where length(forcw) > 0 and (",srcField," is null or length(",srcField,") = 0)
				into @errorIds");
                
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt; 
                
                set @stmt = concat("
				update ",@translatedTable, " set ",srcField," = forcw
                where id in (",@errorIds,")");
		
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt; 
                
                set @stmt = concat("
				update ",@translatedTable, " set forcw = 'MACRO_ERROR'
                where id in (",@errorIds,")");
		
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt; 
                
end proc_main$$
DELIMITER ;


/**  macros that are still on stage and no longer in use or name changed **/

DROP PROCEDURE `universaltranslatorca`.`appendPrependStringIfNotBlank`;
DROP PROCEDURE `universaltranslatorca`.`appendStringWithCon1IfLengthMataches`;
DROP PROCEDURE `universaltranslatorca`.`applyCW`;
DROP PROCEDURE `universaltranslatorca`.`cat2CleanListTable`;
DROP PROCEDURE `universaltranslatorca`.`cat2PopulateTranslatedList`;
DROP PROCEDURE `universaltranslatorca`.`cat2UpdateListValue`;
DROP PROCEDURE `universaltranslatorca`.`CompareFALengthForNotBlankReplaceWithCon2`;
DROP PROCEDURE `universaltranslatorca`.`CompareTwoFieldsAndReject`;
DROP PROCEDURE `universaltranslatorca`.`concat3ColssWithDelimiterNoSpaces`;
DROP PROCEDURE `universaltranslatorca`.`Concat3ColsDelimNoSpaces`;
DROP PROCEDURE `universaltranslatorca`.`deleteTransaction`;
DROP PROCEDURE `universaltranslatorca`.`DeleteTransactionWhenFieldAIsNull`;
DROP PROCEDURE `universaltranslatorca`.`dropValueByPriorityInboundOnly`;
DROP PROCEDURE `universaltranslatorca`.`FieldBGreaterThanEqualFieldAUpdateFieldA`;
DROP PROCEDURE `universaltranslatorca`.`fix2DigitMySQLYears`;
DROP PROCEDURE `universaltranslatorca`.`IfMatchFieldAAndTFBlankSetTFValue`;
DROP PROCEDURE `universaltranslatorca`.`ifNumLTThenError`;
DROP PROCEDURE `universaltranslatorca`.`ifSrcFieldBlankAndFACompareTo0ThenFieldBCon2`;
DROP PROCEDURE `universaltranslatorca`.`ListToRows`;
DROP PROCEDURE `universaltranslatorca`.`trimField`;
DROP PROCEDURE `universaltranslatorca`.`NotInUse_DateToyyyymmdd`;
DROP PROCEDURE `universaltranslatorca`.`PopulateTranslatedList`;
DROP PROCEDURE `universaltranslatorca`.`populateUniqueKeyAndTTI`;
DROP PROCEDURE `universaltranslatorca`.`prependStringWithCon2IfLengthMataches`;
DROP PROCEDURE `universaltranslatorca`.`updateFieldBToDistinctSrcFieldAsList`;
DROP PROCEDURE `universaltranslatorca`.`updateFieldBToSrcFieldAsList`;
DROP PROCEDURE `universaltranslatorca`.`UpdateFPRace`;
DROP PROCEDURE `universaltranslatorca`.`UpdateToMaxMinForCol`;
DROP PROCEDURE `universaltranslatorca`.`UpdateTranslatedListValueNotDistinct`;
