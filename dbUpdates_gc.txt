/** macro updates **/
DROP PROCEDURE if exists yyyymmddToDate;
delete from macro_names where formula = 'yyyymmddToDate';

drop procedure if exists dateyyyymmddTimeToDateTime;
delete from macro_names where formula = 'dateyyyymmddTimeToDateTime';

drop procedure if exists if1Con1ElseNull;
delete from macro_names where formula = 'if1Con1ElseNull';

drop procedure if exists if1Con1ElseCon2;
delete from macro_names where formula = 'if1Con1ElseCon2';

drop procedure if exists cat2Concat3ColsDelimNoSpaces;
delete from  macro_names where formula = 'cat2Concat3ColsDelimNoSpaces';

delete from  macro_names where formula = 'cat2Concat2ColsDelimNoSpaces';
drop procedure if exists cat2Concat2ColsDelimNoSpaces;

delete from  macro_names where formula = 'cat2DelTransWhenNull';
drop procedure if exists cat2DelTransWhenNull;

delete from  macro_names where formula = 'CleanTranslatedListTable';
drop procedure if exists CleanTranslatedListTable;

delete from  macro_names where formula = 'cat2ApplyCWTranslatedList';
drop procedure if exists cat2ApplyCWTranslatedList;



USE `universaltranslatorca`;
DROP procedure IF EXISTS `dateyyyymmddTommddyyyy`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `dateyyyymmddTommddyyyy`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

set @errorIds = "";

set @inboundDateFormat = concat("%Y",con1,"%m",con1,"%d");
set @outboundDateFormat = concat("%m",con1,"%d",con1,"%Y");


--  check inbound date formats and log
set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(",srcField,", '",@inboundDateFormat,"') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

if (@errorIds is not null) then

begin
set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
end;
end if;

if (length(con1) > 0) then 
begin
-- we expect 4 digit years
set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 	
                    and substring(",srcField,",5,",length(con1),") != '",con1,"'
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
end;
end if;

-- update it to valid mysql date fomat
set @stmt = concat("update ",@translatedTable, " set ",srcField," = str_to_date(",srcField,", '",@inboundDateFormat,"') where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 	
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
        
       PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
      

set @errorIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(",srcField,") is null
					and ",srcField," is not null and length(",srcField,") > 0  and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

-- recheck to log invalid dates such as 1997-02-29
if (@errorIds is not null) then

begin

set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;


set @goodIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where  ",srcField," is not null and length(",srcField,") > 0  and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @goodIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

-- recheck to log invalid dates such as 1997-02-29
if (@goodIds is not null) then

begin

-- now we reformat to mmddyyyy with con1
set @stmt = concat("update ",@translatedTable, " set ",srcField," = date_format(",srcField,", '",@outboundDateFormat,"') where id in (",@goodIds,") ");
		
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;




if (passClear = 2) THEN
	BEGIN
		set @stmt = concat("update ",@translatedTable, " set ",srcField,"  = null  where forCW= 'MACRO_ERROR';");
		
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
    
	END;
END IF;



end proc_main$$

DELIMITER ;

USE `universaltranslatorca`;
DROP procedure IF EXISTS `mmddyyyyToyyyymmdd`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `mmddyyyyToyyyymmdd`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

set @errorIds = "";

set @inboundDateFormat = concat("%m",con1,"%d",con1,"%Y");
set @outboundDateFormat = concat("%Y",con1,"%m",con1,"%d");

--  check inbound date formats and log
set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(",srcField,", '",@inboundDateFormat,"') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
      	PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

if (@errorIds is not null) then

begin
set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
end;
end if;

if (length(con1) > 0) then 
begin
-- we expect 4 digit years
set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 	
                    and  left(right(",srcField,", (4 + length('",con1,"'))), length('",con1,"')) != '",con1,"'
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
end;
end if;


-- update it to valid mysql date fomat
set @stmt = concat("update ",@translatedTable, " set ",srcField," = str_to_date(",srcField,", '",@inboundDateFormat,"') where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 	
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
      

set @errorIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(",srcField,") is null
					and ",srcField," is not null and length(",srcField,") > 0  and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
       
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

-- recheck to log invalid dates such as 1997-02-29
if (@errorIds is not null) then

begin

set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;


set @goodIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where  ",srcField," is not null and length(",srcField,") > 0  and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @goodIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

-- recheck to log invalid dates such as 1997-02-29
if (@goodIds is not null) then

begin

-- now we reformat to mmddyyyy with con1
set @stmt = concat("update ",@translatedTable, " set ",srcField," = date_format(",srcField,", '",@outboundDateFormat,"') where id in (",@goodIds,") ");
		
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;


if (passClear = 2) THEN
	BEGIN
		set @stmt = concat("update ",@translatedTable, " set ",srcField,"  = null  where forCW= 'MACRO_ERROR';");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
    
	END;
END IF;

end proc_main$$

DELIMITER ;







USE `universaltranslatorca`;
DROP procedure IF EXISTS `substringToAnotherField`;

USE `universaltranslatorca`;
DROP procedure IF EXISTS `substringToAnotherField`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `substringToAnotherField`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

	call setInboundOutBoundTables (foroutboundProcessing,batchId);
	SELECT 
		@translatedTable,
		@transactionTable,
		@batchTable,
		@batchIdType,
		@errorTable
	INTO @translatedTable , @transactionTable , @batchTable , @batchIdType , @errorTable;

	call getFinalStatusIds;
	SELECT @finalStatusIds INTO @finalStatusIds;

	-- check to make sure con1 and con2 are numeric
    
	if con1 REGEXP '^-?[0-9]+[.]?[0-9]*$|^-?[.][0-9]+$' = 0 or   con2 REGEXP '^-?[0-9]+[.]?[0-9]*$|^-?[.][0-9]+$' = 0 then 
					begin
			
							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, fieldValue, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'substringToAnotherField macro Either - Con1 - \"",con1,"\"  or Con2 - \"",con2,"\" is not a numeric value'",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							 
							PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
           
			leave proc_main;
        end;
      end if;


		set @stmt = concat("update ",@translatedTable, " set ",fieldA," =  ",
		" substring(" , srcField, ", ", con1,",", con2,")  where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


end proc_main$$

DELIMITER ;








USE `universaltranslatorca`;
DROP procedure IF EXISTS `appendPrependString`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `appendPrependString`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

/** 
FA - Prepend string
FB - prepend Y/N to Blanks
Con1 = Append String
Con2 - append Y/N to blanks
**/
-- we remove the first F
	set @prependString = substring(fieldA, 2, length(fieldA) -1);
    set @prependBlanks =  substring(fieldB, 2, 1);
    
    set @appendString = con1;
    set @appendBlanks =  con2;
    
    
			set @stmt = concat("update ", @translatedTable," set forcw = case when ",srcField," is null or length(",srcField,") = 0 then  'blank' else 'notblank' end;");

            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
            
            
    
    
	set @wherePrependString = concat(" and ",srcField, " is not null and length(",srcField,") > 0");
	-- first we prepend
	if (@prependBlanks = 'Y') then
		begin
			set @wherePrependString = '';
        end;
    end if;
    
			set @stmt = concat("update ", @translatedTable," set ",srcField,
			" = case when ",srcField," is null then '",@prependString,"' else concat('", @prependString, "', ", srcField, ") end where ",
			"configId = ",configId," and ",@batchIdType," = ",batchId," and statusId not in (",@finalStatusIds,")",@wherePrependString,";");
            
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;


-- then we append
	set @whereAppendString = concat(" and ",srcField, " is not null and length(",srcField,") > 0 and forcw != 'blank' ");
		-- first we prepend
		if (@appendBlanks = 'Y') then
			begin
				set @whereAppendString = '';
			end;
		end if;

		set @stmt = concat("update ", @translatedTable," set ",srcField,
			" = case when ",srcField," is null then '",@appendString,"' else concat(",srcField,", '",@appendString,"') end where ",
			"configId = ",configId," and ",@batchIdType," = ",batchId," and statusId not in (",@finalStatusIds,")",@whereAppendString,";");
         
			PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;

		
			set @stmt = concat("update ", @translatedTable," set forcw = null;");
            
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
            
end proc_main$$

DELIMITER ;


UPDATE `universaltranslatorca`.`macro_names` SET `FieldA_Question`='Please enter value you would like to prepend', `FieldB_Question`='Prepend if the field is blank (Y/N).', `Con1_Question`='Please enter value you would like to append', `Con2_Question`='Append if the field is blank (Y/N).' WHERE `ID`='102';


/** 20200901 **/

USE `universaltranslatorca`;
DROP procedure IF EXISTS `pastDateCheck`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `pastDateCheck`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;


call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


-- check to make sure con1 is a numeric value
 if con1 REGEXP '^-?[0-9]+[.]?[0-9]*$|^-?[.][0-9]+$' = 0 then 
					begin
			
							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, fieldValue, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'pastDateCheck Con1 - \"",con1,"\"  must be numeric value'",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							 
                             PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
           
			leave proc_main;
        end;
      end if;


	-- we expect 4 digit years
	set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 	
                    and substring(",srcField,",5,1) != '-'
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


set @errorIds = '';

set @stmt = concat("select group_concat(id) from " , @translatedTable, " where
length(",srcField,") > 0 and  ",srcField," is not null  
 and (",srcField," >= curdate() - interval ",con1," month  = 0  or  Date(",srcField,") is null)
 and  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

if (@errorIds is not null) then

	begin

		set @stmt = concat("update " , @translatedTable, "  set forCW = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
	end;
end if;


if (passClear = 2) THEN
			BEGIN

				set @stmt = concat("update " , @translatedTable, " set ", srcField ,"  = null where  forCW = 'MACRO_ERROR'");

				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
			END;
		END IF;

end proc_main$$

DELIMITER ;


USE `universaltranslatorca`;
DROP procedure IF EXISTS `DOBCheck`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `DOBCheck`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

-- check to make sure con1 is a numeric value
 if con1 REGEXP '^-?[0-9]+[.]?[0-9]*$|^-?[.][0-9]+$' = 0 then 
					begin
						set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, fieldValue, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'DOBCheck Con1 - \"",con1,"\"  must be numeric value'",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							 
                             PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
           
			leave proc_main;
        end;
      end if;


-- we expect 4 digit years
set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where forcw is null
					and (
                    (length(",srcField,") = 0 and  length(",fieldA,") > 0)
                    or 
                    (length(",fieldA,") = 0 and  length(",srcField,") > 0)
                    or 
                    (",fieldA," is null and  length(",srcField,") > 0)
                    or 
					(",srcField," is null and  length(",fieldA,") > 0)
                    or  ( length(",srcField,") > 0 and substring(",srcField,",5,1) != '-' )
                    or (length(",fieldA,") > 0 and substring(",fieldA,",5,1) != '-')
                    )
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

-- now we find the ones that are not valid
set @stmt = concat("select group_concat(id) from " , @translatedTable, " where
 ((Date(",srcField,") is null and length(",srcField,") > 0)  or  (Date(",fieldA,") is null and length(",fieldA,") > 0 ))
 or (YEAR(",fieldA,") - YEAR(",srcField,") < ",con1,") 
 or (
 YEAR(",fieldA,") - YEAR(",srcField,") - (DATE_FORMAT(",fieldA,", '%m%d') < DATE_FORMAT(",srcField,", '%m%d')) < ",con1,"
 )
 and  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

if (@errorIds is not null) then

	begin

		set @stmt = concat("update " , @translatedTable, "  set forCW = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
	end;
end if;

set @errorIds = '';

		if (passClear = 2) THEN
			BEGIN

				set @stmt = concat("update " , @translatedTable, " set ", srcField ,"  = null where  forCW = 'MACRO_ERROR'");

				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
			END;
		END IF;

end proc_main$$

DELIMITER ;

/** 20200902 **/
USE `healthelink`;
DROP procedure IF EXISTS `IfMatchFieldAAndTFBlankSetTFValue`;

DELIMITER $$
USE `healthelink`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `IfMatchFieldAAndTFBlankSetTFValue`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


	set @stmt = concat("update ",@translatedTable, " set ",fieldB," = '",con2, "' 
     where " ,fieldA, " = '",con1, "' and (length(",fieldB,") = 0 or ",fieldB," is null) and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");


PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

end proc_main$$

DELIMITER ;

/** 20200902 - 2 **/
update configurationdatatranslations set macroId = 76 where macroId = 110;

drop procedure if exists IfSFLen0orNullReplaceValue;


UPDATE `universaltranslatorca`.`macro_names` SET `FieldB_Question`='Handle MySQL 2 digit year limitations for 2 digit years ending in 30-69. (Y/N)', `Con1_Question`='Please enter the inbound string\'s date format', `Con2_Question`='Please enter the outbound string\'s date format' WHERE `ID`='112';

USE `universaltranslatorca`;
DROP procedure IF EXISTS `stringToDate`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `stringToDate`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


		set @mysqlDateFormat = concat('%Y-%m-%d');

		set @inboundDateFormat = concat(con1);
        
		if (length(con2) > 0) then
			set @outboundDateFormat = concat(con2);
		else 
			set @outboundDateFormat = concat('%Y-%m-%d');
		end if;


--  check inbound date formats and log
		set @errorIds = "";
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(",srcField,", '",@inboundDateFormat,"') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

if (@errorIds is not null) then

begin
		set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
		        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
end;
end if;


-- update it to valid mysql date fomat
set @stmt = concat("update ",@translatedTable, " set ",srcField," = str_to_date(",srcField,", '",@inboundDateFormat,"') where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 	
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
            
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
      

-- recheck to log invalid dates such as 1997-02-29
set @errorIds = "";
set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(",srcField,") is null
					and ",srcField," is not null and length(",srcField,") > 0  and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
       
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

if (@errorIds is not null) then

begin	
		set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
		
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;

	-- now we handle the two digit years that are converted to future MySQL dates
    /** doesn't work for inbound dates is 65-01-13, and even though inboud format is %Y-%m-%d (four digit year),
    
    there are too many variable to check where exactly the year to make sure if it is 2 digit years or 4 digit years
    
    we should ask the users if they 'd like to handle it (fieldB)
   **/

	-- if ((binary '"con1"' like binary '%y%' and binary '"con2"' not like binary '%y%' ) or (substring(fieldA, 2, 1) = 'Y')) then 
    if  (substring(fieldB, 2, 1) = 'Y') then 

		call fix2DigitMySQLYears(configId, batchId, srcField, fieldA, fieldB, con1, con2, macroId, foroutboundProcessing, passClear, transactionId);
        
	end if;
	

set @goodIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where  ",srcField," is not null and length(",srcField,") > 0  and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @goodIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

-- recheck to log invalid dates such as 1997-02-29
if (@goodIds is not null) then

begin

-- now we reformat to mmddyyyy with con1
set @stmt = concat("update ",@translatedTable, " set ",srcField," = date_format(",srcField,", '",@outboundDateFormat,"') where id in (",@goodIds,") ");
		
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;


if (passClear = 2) THEN
	BEGIN
    
		set @stmt = concat("update ",@translatedTable, " set ",srcField,"  = null  where forCW= 'MACRO_ERROR';");
		
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
    
	END;
END IF;

end proc_main$$

DELIMITER ;


USE `universaltranslatorca`;
DROP procedure IF EXISTS `fix2DigitMySQLYears`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `fix2DigitMySQLYears`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

		call setInboundOutBoundTables (foroutboundProcessing,batchId);
		select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
		into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

		call getFinalStatusIds;
		select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable," set  ", srcField ," = replace(",srcField, ", '206','196')   where  configId = ",configId," and ", @batchIdType, " = ",batchId," and statusId not in (",@finalStatusIds,");");
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;   
        
        set @stmt = concat("update ",@translatedTable," set  ", srcField ," = replace(",srcField, ", '205','195')   where  configId = ",configId," and ", @batchIdType, " = ",batchId," and statusId not in (",@finalStatusIds,");");
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;   
        
        set @stmt = concat("update ",@translatedTable," set  ", srcField ," = replace(",srcField, ", '204','194')   where  configId = ",configId," and ", @batchIdType, " = ",batchId," and statusId not in (",@finalStatusIds,");");
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;   
        
		set @stmt = concat("update ",@translatedTable," set  ", srcField ," = replace(",srcField, ", '203','193')   where  configId = ",configId," and ", @batchIdType, " = ",batchId," and statusId not in (",@finalStatusIds,");");
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;    

end proc_main$$

DELIMITER ;


USE `universaltranslatorca`;
DROP procedure IF EXISTS `yyyymmddstripTime`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `yyyymmddstripTime`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
		
        /** we assume inbound / outbound date format - yyyymmdd **/

		set @inboundDateFormat = '%Y-%m-%d %H:%i:%s.%f';
        set @outboundDateFormat =  '%Y%m%d';
        set @mySQLDateFormat =  '%Y-%m-%d';

--  check inbound date  and log
		set @errorIds = "";
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where  date_format(str_to_date(",srcField,", '",@inboundDateFormat,"' ),  '",@inboundDateFormat,"') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");

        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

if (@errorIds is not null) then

begin
		set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
		       
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
end;
end if;


/**update it to valid MySQL date fomat **/
set @stmt = concat("update ",@translatedTable, " set forcw = date_format(str_to_date(",srcField,", '",@inboundDateFormat,"' ) , '",@mySQLDateFormat,"') where forcw is null
					and id not in (",@errorIds,");");
        
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
            
 -- recheck the date as date(str_to_date()) doesnot pick up incorrect date such as 2019-02-29
 
 set @errorIds = "";
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where  
        forcw != 'MACRO_ERROR' and date(forcw) is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

if (@errorIds is not null) then

begin
		set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
		       
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
end;
end if;
 

 -- how we convert to outboundFormat         
  set @stmt = concat("update ",@translatedTable, " set ",srcField," = date_format(str_to_date(",srcField,", '",@inboundDateFormat,"'), '",@outboundDateFormat,"')  where 
					(forcw is null or forcw != 'MACRO_ERROR')
					and ",srcField," is not null and length(",srcField,") > 0 	
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
            
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;     
            
          

if (passClear = 2) THEN
	BEGIN
		
        set @stmt = concat("update ",@translatedTable, " set ",srcField,"  = null  where forCW= 'MACRO_ERROR';");
		
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
    
	END;
END IF;

end proc_main$$

DELIMITER ;


USE `universaltranslatorca`;
DROP procedure IF EXISTS `IfFieldACon1andSFBlankInsertError`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `IfFieldACon1andSFBlankInsertError`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

	call setInboundOutBoundTables (foroutboundProcessing,batchId);
	SELECT 
		@translatedTable,
		@transactionTable,
		@batchTable,
		@batchIdType,
		@errorTable,
		@translateCol
	INTO @translatedTable , @transactionTable , @batchTable , @batchIdType , @errorTable, @translateCol;

	call getFinalStatusIds;
	SELECT @finalStatusIds INTO @finalStatusIds;

	set @whereString = concat("  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");


	-- all conditional errors are flag as required
	set @stmt = concat("insert into ", @errorTable , " (" , @batchIdColumn, ", configId, " , @translateCol, 
    ", fieldNo, errorId, macroId, fieldValue, required) select ",@batchIdType,", configId, id, replace('",srcField,"', 'F', ''), ", con2, 
   ", ",macroId,",",srcField,", true from ", @translatedTable, " where ",fieldA,"  = ",con1," and (",srcField," is null or length(",srcField,") = 0) and ", 
    @whereString);
	

    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    
		-- manually update transaction status to 14
     	set @stmt = concat("update ", @translatedTable, " set statusId = 14 where  ",fieldA,"  = ",con1," and (",srcField," is null or length(",srcField,") = 0) and ", 
		@whereString);
	
		
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
    
     

end proc_main$$

DELIMITER ;


USE `universaltranslatorca`;
DROP procedure IF EXISTS `IfFieldACon1andSFBlankInsertError`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `IfFieldACon1andSFBlankInsertError`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

	call setInboundOutBoundTables (foroutboundProcessing,batchId);
	SELECT 
		@translatedTable,
		@transactionTable,
		@batchTable,
		@batchIdType,
		@errorTable,
		@translateCol
	INTO @translatedTable , @transactionTable , @batchTable , @batchIdType , @errorTable, @translateCol;

	call getFinalStatusIds;
	SELECT @finalStatusIds INTO @finalStatusIds;

		set @whereString = concat("  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");

		set @stmt = concat("select fieldDesc from configurationformfields where configId = ",configId," and fieldNo = replace('",srcField,"', 'F', '') into @fieldDesc;");
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		-- all conditional errors are flag as required
		set @stmt = concat("insert into ", @errorTable , " (" , @batchIdColumn, ", configId, " , @translateCol, 
		", fieldNo, errorId, macroId, fieldValue, required, stackTrace) select ",@batchIdType,", configId, id, replace('",srcField,"', 'F', ''), ", 58, 
	   ", ",macroId,",",srcField,", true, 'A value is required if \"",@fieldDesc,"\" is value \"",con1, "\"' from ", @translatedTable, " where ",fieldA,"  = ",con1," and (",srcField," is null 
       or length(REPLACE(REPLACE(", srcField, ", ""\n"", """"), ""\r"", """")) = 0) and ", 
		@whereString);
		
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
    
    
		-- manually update transaction status to 14
     	set @stmt = concat("update ", @translatedTable, " set statusId = 14 where  ",fieldA,"  = ",con1," and (",srcField," is null 
        or length(REPLACE(REPLACE(", srcField, ", ""\n"", """"), ""\r"", """")) = 0) and ", 
		@whereString);
		
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
        -- handle p/c
		-- pc doesn't apply even though we are checking for a blank or null field because we SF is supposed to be null
     

end proc_main$$

DELIMITER ;



/** 09082020 **/

USE `universaltranslatorca`;
DROP procedure IF EXISTS `dateddmonyyWithDashesToyyyymmdd`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `dateddmonyyWithDashesToyyyymmdd`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


		set @mysqlDateFormat = concat('%Y-%m-%d');
		set @inboundDateFormat = concat('%d-%b-%y');
        set @outboundDateFormat = concat('%Y%m%d');
		
         -- check to make sure it is two digit years
        set @errorIds = '';
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where left(right(F1, 3), 1) != '-' 
					and ",srcField," is not null and length(",srcField,") > 0 and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin

				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
		
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;
        

--  check inbound date formats and log
		set @errorIds = "";
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(",srcField,", '",@inboundDateFormat,"') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin
				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
		end;
		end if;


		-- update it to valid mysql date fomat
		set @stmt = concat("update ",@translatedTable, " set forcw = str_to_date(",srcField,", '",@inboundDateFormat,"') where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
                    
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
      

		-- recheck to log invalid dates such as 1997-02-29
		set @errorIds = "";
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(forcw) is null
					and ",srcField," is not null and length(",srcField,") > 0  and forcw != 'MACRO_ERROR'  and forcw is not null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
       
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin	
				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
				 
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;
        
        
		set @goodIds = "";

		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where  ",srcField," is not null and length(",srcField,") > 0  
					and (forcw != 'MACRO_ERROR' or forcw is null)
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @goodIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		-- recheck to log invalid dates such as 1997-02-29
		if (@goodIds is not null) then

		begin

		-- now we reformat to mmddyyyy with con1
		set @stmt = concat("update ",@translatedTable, " set ",srcField," = date_format(forcw, '",@outboundDateFormat,"') where id in (",@goodIds,") ");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;

		-- now we handle the two digit years that are converted to future MySQL dates
		call fix2DigitMySQLYears(configId, batchId, srcField, fieldA, fieldB, con1, con2, macroId, foroutboundProcessing, passClear, transactionId);

		if (passClear = 2) THEN
			BEGIN
			
				set @stmt = concat("update ",@translatedTable, " set ",srcField,"  = null  where forCW= 'MACRO_ERROR';");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
			
			END;
		END IF;

end proc_main$$

DELIMITER ;

USE `universaltranslatorca`;
DROP procedure IF EXISTS `datemddyyyyWithSlashesToyyyymmdd`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `datemddyyyyWithSlashesToyyyymmdd`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		set @mysqlDateFormat = concat('%Y-%m-%d');
		set @inboundDateFormat = concat('%c/%d/%Y');
        set @outboundDateFormat = concat('%Y%m%d');
		
         -- check to make sure it is two digit years
        set @errorIds = '';
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where left(right(F1, 5), 1) != '/' 
					and ",srcField," is not null and length(",srcField,") > 0 and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin

				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
		
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;
        

--  check inbound date formats and log
		set @errorIds = "";
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(",srcField,", '",@inboundDateFormat,"') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin
				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
		end;
		end if;


		-- update it to valid mysql date fomat
		set @stmt = concat("update ",@translatedTable, " set forcw = str_to_date(",srcField,", '",@inboundDateFormat,"') where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
                    
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
      

		-- recheck to log invalid dates such as 1997-02-29
		set @errorIds = "";
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(forcw) is null
					and ",srcField," is not null and length(",srcField,") > 0  and forcw != 'MACRO_ERROR'  and forcw is not null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
       
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin	
				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
				 
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;
        
        
		set @goodIds = "";

		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where  ",srcField," is not null and length(",srcField,") > 0  
					and (forcw != 'MACRO_ERROR' or forcw is null)
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @goodIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		-- recheck to log invalid dates such as 1997-02-29
		if (@goodIds is not null) then

		begin

		-- now we reformat to mmddyyyy with con1
		set @stmt = concat("update ",@translatedTable, " set ",srcField," = date_format(forcw, '",@outboundDateFormat,"') where id in (",@goodIds,") ");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;

		if (passClear = 2) THEN
			BEGIN
			
				set @stmt = concat("update ",@translatedTable, " set ",srcField,"  = null  where forCW= 'MACRO_ERROR';");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
			
			END;
		END IF;

end proc_main$$

DELIMITER ;


USE `universaltranslatorca`;
DROP procedure IF EXISTS `datemmdyyyyWithSlashesToyyyymmdd`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `datemmdyyyyWithSlashesToyyyymmdd`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		set @mysqlDateFormat = concat('%Y-%m-%d');
		set @inboundDateFormat = concat('%m/%e/%Y');
        set @outboundDateFormat = concat('%Y%m%d');
		
         -- check to make sure it is two digit years
        set @errorIds = '';
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where left(right(F1, 5), 1) != '/' 
					and ",srcField," is not null and length(",srcField,") > 0 and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin

				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
		
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;
        
--  check inbound date formats and log
		set @errorIds = "";
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(",srcField,", '",@inboundDateFormat,"') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin
				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
		end;
		end if;


		-- update it to valid mysql date fomat
		set @stmt = concat("update ",@translatedTable, " set forcw = str_to_date(",srcField,", '",@inboundDateFormat,"') where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
                    
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
      

		-- recheck to log invalid dates such as 1997-02-29
		set @errorIds = "";
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(forcw) is null
					and ",srcField," is not null and length(",srcField,") > 0  and forcw != 'MACRO_ERROR'  and forcw is not null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
       
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin	
				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
				 
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;
        
        
		set @goodIds = "";

		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where  ",srcField," is not null and length(",srcField,") > 0  
					and (forcw != 'MACRO_ERROR' or forcw is null)
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @goodIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		-- recheck to log invalid dates such as 1997-02-29
		if (@goodIds is not null) then

		begin

		-- now we reformat to mmddyyyy with con1
		set @stmt = concat("update ",@translatedTable, " set ",srcField," = date_format(forcw, '",@outboundDateFormat,"') where id in (",@goodIds,") ");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;

		if (passClear = 2) THEN
			BEGIN
			
				set @stmt = concat("update ",@translatedTable, " set ",srcField,"  = null  where forCW= 'MACRO_ERROR';");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
			
			END;
		END IF;

end proc_main$$

DELIMITER ;


USE `universaltranslatorca`;
DROP procedure IF EXISTS `datemddyyyyToyyyymmdd`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `datemddyyyyToyyyymmdd`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		set @mysqlDateFormat = concat('%Y-%m-%d');
		set @inboundDateFormat = concat('%Y-%m-%d');
        set @outboundDateFormat = concat('%Y%m%d');

                set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where length(",srcField,") !=7 and length(",srcField,") !=8
                and ",srcField," is not null and length(",srcField,") > 0");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
		
				/**
					manually add slashes to make it mysql date format since mysql has trouble understanding dates without date separator
					if 7 digits we insert one-two-four
                    if 8 digits we insert two-two-four
                
                **/
                
				set @stmt = concat("update ",@translatedTable, " set forcw = concat(right(",srcField,", 4), '',  '-0', left(",srcField,", 1), '-', substring(",srcField,", 2,2)) 
                where length(",srcField,") =7 and forcw != 'MACRO_ERROR' or forcw is null
                and ",srcField," is not null and length(",srcField,") > 0");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
                
                
                set @stmt = concat("update ",@translatedTable, " set forcw = concat(right(",srcField,", 4), '-',left(",srcField,", 2) , '-', substring(",srcField,", 2,2))
                where length(",srcField,") =8 and forcw != 'MACRO_ERROR' or forcw is null
                and ",srcField," is not null and length(",srcField,") > 0");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
		
				--  check inbound date formats and log
				set @errorIds = "";
				set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(forcw, '",@inboundDateFormat,"') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin
				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
		end;
		end if;

		
		-- recheck to log invalid dates such as 1997-02-29
		set @errorIds = "";
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(forcw) is null
					and ",srcField," is not null and length(",srcField,") > 0 and forcw != 'MACRO_ERROR' and forcw is not null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
       
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin	
				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
				 
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;
        
        
		set @goodIds = "";

		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where  ",srcField," is not null and length(",srcField,") > 0  
					and (forcw != 'MACRO_ERROR' or forcw is null)
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @goodIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		-- recheck to log invalid dates such as 1997-02-29
		if (@goodIds is not null) then

		begin

		-- now we reformat to mddyyyy with con1
		set @stmt = concat("update ",@translatedTable, " set ",srcField," = date_format(forcw, '",@outboundDateFormat,"') where id in (",@goodIds,") ");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;

		if (passClear = 2) THEN
			BEGIN
			
				set @stmt = concat("update ",@translatedTable, " set ",srcField,"  = null  where forCW= 'MACRO_ERROR';");
				 
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
			
			END;
		END IF;

end proc_main$$

DELIMITER ;


USE `universaltranslatorca`;
DROP procedure IF EXISTS `datemmddyyWithSlashesToyyyymmdd`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `datemmddyyWithSlashesToyyyymmdd`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


		set @mysqlDateFormat = concat('%Y-%m-%d');
		set @inboundDateFormat = concat('%m/%d/%y');
        set @outboundDateFormat = concat('%Y%m%d');
		
         -- check to make sure it is two digit years
        set @errorIds = '';
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where left(right(F1, 3), 1) != '/' 
					and ",srcField," is not null and length(",srcField,") > 0 and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin

				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
		
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;
        
--  check inbound date formats and log
		set @errorIds = "";
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(",srcField,", '",@inboundDateFormat,"') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin
				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
		end;
		end if;


		-- update it to valid mysql date fomat
		set @stmt = concat("update ",@translatedTable, " set forcw = str_to_date(",srcField,", '",@inboundDateFormat,"') where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
                    
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
      

		-- recheck to log invalid dates such as 1997-02-29
		set @errorIds = "";
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(forcw) is null
					and ",srcField," is not null and length(",srcField,") > 0  and forcw != 'MACRO_ERROR'  and forcw is not null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
       
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin	
				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
				 
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;
        
        
		set @goodIds = "";

		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where  ",srcField," is not null and length(",srcField,") > 0  
					and (forcw != 'MACRO_ERROR' or forcw is null)
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @goodIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		-- recheck to log invalid dates such as 1997-02-29
		if (@goodIds is not null) then

		begin

		-- now we reformat to mmddyyyy with con1
		set @stmt = concat("update ",@translatedTable, " set ",srcField," = date_format(forcw, '",@outboundDateFormat,"') where id in (",@goodIds,") ");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;

		-- now we handle the two digit years that are converted to future MySQL dates
		call fix2DigitMySQLYears(configId, batchId, srcField, fieldA, fieldB, con1, con2, macroId, foroutboundProcessing, passClear, transactionId);

		if (passClear = 2) THEN
			BEGIN
			
				set @stmt = concat("update ",@translatedTable, " set ",srcField,"  = null  where forCW= 'MACRO_ERROR';");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
			
			END;
		END IF;

end proc_main$$

DELIMITER ;

/** 20200909 remove P/C from macros **/
USE `universaltranslatorca`;
DROP procedure IF EXISTS `datemmddyyyyWithSlashesToyyyymmdd`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `datemmddyyyyWithSlashesToyyyymmdd`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;




set @errorIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(",srcField,", '%m/%d/%Y') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

if (@errorIds is not null) then

begin

set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;


set @stmt = concat("update ",@translatedTable, " set ",srcField," = str_to_date(",srcField,", '%m/%d/%Y') where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 	
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
      

set @errorIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(",srcField,") is null
					and ",srcField," is not null and length(",srcField,") > 0  and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


if (@errorIds is not null) then

begin

set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;

set @errorIds = '';



set @stmt = concat("update ",@translatedTable, " set ",srcField," =  replace(",srcField,", '-', '')
where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") 
");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

end proc_main$$

DELIMITER ;


USE `universaltranslatorca`;
DROP procedure IF EXISTS `dateyyyymmddTommddyyyy`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `dateyyyymmddTommddyyyy`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

set @errorIds = "";

set @inboundDateFormat = concat("%Y",con1,"%m",con1,"%d");
set @outboundDateFormat = concat("%m",con2,"%d",con2,"%Y");


--  check inbound date formats and log
set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(",srcField,", '",@inboundDateFormat,"') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

if (@errorIds is not null) then

begin
set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
end;
end if;

if (length(con1) > 0) then 
begin
-- we expect 4 digit years
set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 	
                    and substring(",srcField,",5,",length(con1),") != '",con1,"'
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
end;
end if;

-- update it to valid mysql date fomat
set @stmt = concat("update ",@translatedTable, " set ",srcField," = str_to_date(",srcField,", '",@inboundDateFormat,"') where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 	
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
        
       PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
      

set @errorIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(",srcField,") is null
					and ",srcField," is not null and length(",srcField,") > 0  and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

-- recheck to log invalid dates such as 1997-02-29
if (@errorIds is not null) then

begin

set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;


set @goodIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where  ",srcField," is not null and length(",srcField,") > 0  and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @goodIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

-- recheck to log invalid dates such as 1997-02-29
if (@goodIds is not null) then

begin

-- now we reformat to mmddyyyy with con1
set @stmt = concat("update ",@translatedTable, " set ",srcField," = date_format(",srcField,", '",@outboundDateFormat,"') where id in (",@goodIds,") ");
		
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;

end proc_main$$

DELIMITER ;

UPDATE `universaltranslatorca`.`macro_Names` SET `Con1_Question`='Please enter source SF\'s date value separator.  e.g. -, ., /', `Con2_Question`='Please enter target SF\'s date value separator.  e.g. -, ., /' WHERE `ID`='68';
UPDATE `universaltranslatorca`.`macro_Names` SET `Con1_Question`='Please enter source SF\'s date value separator.  e.g. -, ., /', `Con2_Question`='Please enter target SF\'s date value separator.  e.g. -, ., /' WHERE `ID`='69';


USE `universaltranslatorca`;
DROP procedure IF EXISTS `DOBCheck`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `DOBCheck`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

-- check to make sure con1 is a numeric value
 if con1 REGEXP '^-?[0-9]+[.]?[0-9]*$|^-?[.][0-9]+$' = 0 then 
					begin
						set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, fieldValue, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'DOBCheck Con1 - \"",con1,"\"  must be numeric value'",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							 
                             PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
           
			leave proc_main;
        end;
      end if;


-- we expect 4 digit years
set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where forcw is null
					and (
                    (length(",srcField,") = 0 and  length(",fieldA,") > 0)
                    or 
                    (length(",fieldA,") = 0 and  length(",srcField,") > 0)
                    or 
                    (",fieldA," is null and  length(",srcField,") > 0)
                    or 
					(",srcField," is null and  length(",fieldA,") > 0)
                    or  ( length(",srcField,") > 0 and substring(",srcField,",5,1) != '-' )
                    or (length(",fieldA,") > 0 and substring(",fieldA,",5,1) != '-')
                    )
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

-- now we find the ones that are not valid
set @stmt = concat("select group_concat(id) from " , @translatedTable, " where
 ((Date(",srcField,") is null and length(",srcField,") > 0)  or  (Date(",fieldA,") is null and length(",fieldA,") > 0 ))
 or (YEAR(",fieldA,") - YEAR(",srcField,") < ",con1,") 
 or (
 YEAR(",fieldA,") - YEAR(",srcField,") - (DATE_FORMAT(",fieldA,", '%m%d') < DATE_FORMAT(",srcField,", '%m%d')) < ",con1,"
 )
 and  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

if (@errorIds is not null) then

	begin

		set @stmt = concat("update " , @translatedTable, "  set forCW = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
	end;
end if;

set @errorIds = '';


end proc_main$$

DELIMITER ;

UPDATE `universaltranslatorca`.`macro_Names` SET `Macro_Name`='Date - yyyy*mm*dd to mm*dd*yyyy' WHERE `ID`='68';
UPDATE `universaltranslatorca`.`macro_Names` SET `Macro_Name`='Date - mm*dd*yyyy to yyyy*mm*dd' WHERE `ID`='69';

USE `universaltranslatorca`;
DROP procedure IF EXISTS `ZipCodeCheck`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `ZipCodeCheck`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
SELECT 
    @translatedTable,
    @transactionTable,
    @batchTable,
    @batchIdType,
    @errorTable,
    @translateCol
INTO @translatedTable , @transactionTable , @batchTable , @batchIdType , @errorTable, @translateCol;

call getFinalStatusIds;
SELECT @finalStatusIds INTO @finalStatusIds;

				
                set @proceed = true;
                
                
                if (length(con1) > 0) then
					begin
						
                        if con1 REGEXP '^[0-9]{5}$' = 0 then 
                        
							set @proceed = false;
                            
							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, fieldValue, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'Default zip code ",con1," is not a valid value'",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            
                            leave proc_main;
						end if;
					end;
                end if;

				if (@proceed) then 
								begin
								
								set @whereStmt =  concat(" and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");
								set @whereClause = concat("  (",srcField," REGEXP '^[0-9]{5}$' != 1) 
								and ",srcField," is not null and length(",srcField,") > 0 ");
							    set @whereString = concat(@whereClause , @whereStmt);

								set @stmt = concat("update  ", @translatedTable , " set forcw = ",srcField);
								PREPARE stmt from @stmt;
								EXECUTE stmt;
								DEALLOCATE PREPARE stmt;

								set @stmt = concat("update  ", @translatedTable , " set ",srcField," = replace(",srcField,", '-', '') where (length(", srcField,") != 0 or ",srcField," is not null )", @whereStmt);
								PREPARE stmt from @stmt;
								EXECUTE stmt;
								DEALLOCATE PREPARE stmt;
								
								
								
								set @stmt = concat("update  ", @translatedTable , " set ",srcField," = 
								case 
								when (length(",srcField,") = 4 or length(",srcField,") = 8) then concat('0', ",srcField,") 
								when (length(",srcField,") = 3 or length(",srcField,") = 7)  then concat('00', ",srcField,") 
								when (length(",srcField,") = 2  or length(",srcField,") = 6)  then concat('000', ",srcField,") 
								when length(",srcField,") = 1 then concat('0000', ",srcField,") 
								else ",srcField," end where length(",srcField,") != 5 ", @whereStmt);
								
								PREPARE stmt from @stmt;
								EXECUTE stmt;
								DEALLOCATE PREPARE stmt;
							   
								set @stmt = concat("update  ", @translatedTable , " set ",srcField," = left(",srcField,", 5) where length(", srcField,") > 5", @whereStmt);
								 
								PREPARE stmt from @stmt;
								EXECUTE stmt;
								DEALLOCATE PREPARE stmt;
                                
								
								set @stmt = concat("update  ", @translatedTable , " set forcw = 'MACRO_ERROR' where  ", @whereString);
                               
								PREPARE stmt from @stmt;
								EXECUTE stmt;
								
							   
								if (length(con1) > 0) then
												
													set @stmt = concat("update  ", @translatedTable , " set forcw='BlankVar', ",srcField," = '",con1,"' where (length(", srcField,") = 0 or ",srcField," is null )  ", @whereStmt);
													
                                                    PREPARE stmt from @stmt;
													EXECUTE stmt;
													DEALLOCATE PREPARE stmt;
								end if;
							   
				

				if (passClear = 2) THEN
							BEGIN
							set @dvTableName = "batchuploaddroppedvalues";
							set @colDirection = "in";

							if (foroutboundProcessing)  then
									set @dvTableName = "batchdownloaddroppedvalues";
									set @colDirection = "out";
							end if;
							
							SET @stmt = CONCAT("
								select fieldDesc from configurationformfields where fieldNo = replace('",srcField,"', 'F', '') and configId = ",configId," into @fieldName;
							");
						 
							PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            
                           SET @stmt = CONCAT("
							insert into ",@dvTableName ," (",@batchIdType,", transaction",@colDirection,"recordsId, fieldNo, configId, fieldName, fieldValue)
							select ",batchId,", transaction",@colDirection,"RecordsId, replace('",srcField,"', 'F', ''), ",configId,", '", @fieldName, "' , ",srcField," 
							from ", @translatedTable, " where forCW != 'BlankVar'  and ",@whereString
							);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
					
                    END;
				END IF;

			end;
	end if;
				
end proc_main$$

DELIMITER ;


/** 20200912 **/
USE `universaltranslatorca`;
DROP procedure IF EXISTS `dateyyyymmddTommddyyyy`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `dateyyyymmddTommddyyyy`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

set @errorIds = "";

set @inboundDateFormat = concat("%Y",con1,"%m",con1,"%d");
set @outboundDateFormat = concat("%m",con2,"%d",con2,"%Y");


--  check inbound date formats and log
set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(",srcField,", '",@inboundDateFormat,"') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

if (@errorIds is not null) then

begin
set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
end;
end if;

if (length(con1) > 0) then 
begin
-- we expect 4 digit years
set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 	
                    and substring(",srcField,",5,",length(con1),") != '",con1,"'
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
end;
end if;

-- update it to valid mysql date fomat
set @stmt = concat("update ",@translatedTable, " set ",srcField," = str_to_date(",srcField,", '",@inboundDateFormat,"') where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 	
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
        
       PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
      

set @errorIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(",srcField,") is null
					and ",srcField," is not null and length(",srcField,") > 0  and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

-- recheck to log invalid dates such as 1997-02-29
if (@errorIds is not null) then

begin

set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;


set @goodIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where  ",srcField," is not null and length(",srcField,") > 0  and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @goodIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

-- recheck to log invalid dates such as 1997-02-29
if (@goodIds is not null) then
begin
-- now we reformat to mmddyyyy with con1
set @stmt = concat("update ",@translatedTable, " set ",srcField," = date_format(",srcField,", '",@outboundDateFormat,"') where id in (",@goodIds,") ");
		
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;

end proc_main$$

DELIMITER ;

USE `universaltranslatorca`;
DROP procedure IF EXISTS `datemmddyyyytoyyyymmdd`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `datemmddyyyytoyyyymmdd`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;




set @errorIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(",srcField,", '%m%d%Y') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

if (@errorIds is not null) then

begin

set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;


set @stmt = concat("update ",@translatedTable, " set ",srcField," = str_to_date(",srcField,", '%m%d%Y') where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 	
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
      

set @errorIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(",srcField,") is null
					and ",srcField," is not null and length(",srcField,") > 0  and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


if (@errorIds is not null) then

begin

set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;

set @errorIds = '';



set @stmt = concat("update ",@translatedTable, " set ",srcField," =  replace(",srcField,", '-', '')
where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") 
");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


end proc_main$$

DELIMITER ;

delete from macro_names where formula = 'addCharToString';
drop procedure if exists addCharToString;

delete from macro_names where formula = 'dateYYYYMMDDHHMMSSMSToYYYYMMDDHHMMSS';
drop procedure if exists dateYYYYMMDDHHMMSSMSToYYYYMMDDHHMMSS;

DROP PROCEDURE if exists yyyymmddToDate;
delete from macro_names where formula = 'yyyymmddToDate';

drop procedure if exists dateyyyymmddTimeToDateTime;
delete from macro_names where formula = 'dateyyyymmddTimeToDateTime';

delete from macro_names where formula = 'addDelimiterEvery2Characters';
drop procedure if exists addDelimiterEvery2Characters;

drop procedure if exists if1Con1ElseNull;
delete from macro_names where formula = 'if1Con1ElseNull';

drop procedure if exists if1Con1ElseCon2;
delete from macro_names where formula = 'if1Con1ElseCon2';

drop procedure if exists ifDateCon1ElseNull;
delete from macro_names where formula = 'ifDateCon1ElseNull';

drop procedure if exists concatColumnsToList;
delete from macro_names where formula = 'concatColumnsToList';

USE `universaltranslatorca`;
DROP procedure IF EXISTS `pastDateCheck`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `pastDateCheck`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;


call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


-- check to make sure con1 is a numeric value
 if con1 REGEXP '^-?[0-9]+[.]?[0-9]*$|^-?[.][0-9]+$' = 0 then 
					begin
			
							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, fieldValue, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'pastDateCheck Con1 - \"",con1,"\"  must be numeric value'",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							 
                             PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
           
			leave proc_main;
        end;
      end if;


	-- we expect 4 digit years
	set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 	
                    and substring(",srcField,",5,1) != '-'
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


set @errorIds = '';

set @stmt = concat("select group_concat(id) from " , @translatedTable, " where
length(",srcField,") > 0 and  ",srcField," is not null  
 and (",srcField," >= curdate() - interval ",con1," month  = 0  or  Date(",srcField,") is null)
 and  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

if (@errorIds is not null) then

	begin

		set @stmt = concat("update " , @translatedTable, "  set forCW = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
	end;
end if;

end proc_main$$

DELIMITER ;

drop procedure if exists IfSFLen0orNullReplaceValue;
delete from macro_names where formula = 'IfSFLen0orNullReplaceValue';


USE `universaltranslatorca`;
DROP procedure IF EXISTS `stringToDate`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `stringToDate`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


		set @mysqlDateFormat = concat('%Y-%m-%d');

		set @inboundDateFormat = concat(con1);
        
		if (length(con2) > 0) then
			set @outboundDateFormat = concat(con2);
		else 
			set @outboundDateFormat = concat('%Y-%m-%d');
		end if;


--  check inbound date formats and log
		set @errorIds = "";
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(",srcField,", '",@inboundDateFormat,"') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

if (@errorIds is not null) then

begin
		set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
		        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
end;
end if;


-- update it to valid mysql date fomat
set @stmt = concat("update ",@translatedTable, " set ",srcField," = str_to_date(",srcField,", '",@inboundDateFormat,"') where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 	
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
            
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
      

-- recheck to log invalid dates such as 1997-02-29
set @errorIds = "";
set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(",srcField,") is null
					and ",srcField," is not null and length(",srcField,") > 0  and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
       
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

if (@errorIds is not null) then

begin	
		set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
		
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;

	-- now we handle the two digit years that are converted to future MySQL dates
    /** doesn't work for inbound dates is 65-01-13, and even though inboud format is %Y-%m-%d (four digit year),
    
    there are too many variable to check where exactly the year to make sure if it is 2 digit years or 4 digit years
    
    we should ask the users if they 'd like to handle it (fieldB)
   **/

	-- if ((binary '"con1"' like binary '%y%' and binary '"con2"' not like binary '%y%' ) or (substring(fieldA, 2, 1) = 'Y')) then 
    if  (substring(fieldB, 2, 1) = 'Y') then 

		call fix2DigitMySQLYears(configId, batchId, srcField, fieldA, fieldB, con1, con2, macroId, foroutboundProcessing, passClear, transactionId);
        
	end if;
	

set @goodIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where  ",srcField," is not null and length(",srcField,") > 0  and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @goodIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

-- recheck to log invalid dates such as 1997-02-29
if (@goodIds is not null) then

begin

-- now we reformat to mmddyyyy with con1
set @stmt = concat("update ",@translatedTable, " set ",srcField," = date_format(",srcField,", '",@outboundDateFormat,"') where id in (",@goodIds,") ");
		
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;

end proc_main$$

DELIMITER ;

drop procedure if exists yyyymmddstripTime;
delete from macro_names where formula = 'yyyymmddstripTime';

drop procedure if exists cat2ApplyCWTranslatedList;
delete from macro_names where formula = 'cat2ApplyCWTranslatedList';

drop procedure if exists ifNonDateSetNull;
delete from macro_names where formula = 'ifNonDateSetNull';

USE `universaltranslatorca`;
DROP procedure IF EXISTS `dateddmonyyWithDashesToyyyymmdd`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `dateddmonyyWithDashesToyyyymmdd`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


		set @mysqlDateFormat = concat('%Y-%m-%d');
		set @inboundDateFormat = concat('%d-%b-%y');
        set @outboundDateFormat = concat('%Y%m%d');
		
         -- check to make sure it is two digit years
        set @errorIds = '';
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where left(right(F1, 3), 1) != '-' 
					and ",srcField," is not null and length(",srcField,") > 0 and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin

				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
		
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;
        

--  check inbound date formats and log
		set @errorIds = "";
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(",srcField,", '",@inboundDateFormat,"') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin
				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
		end;
		end if;


		-- update it to valid mysql date fomat
		set @stmt = concat("update ",@translatedTable, " set forcw = str_to_date(",srcField,", '",@inboundDateFormat,"') where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
                    
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
      

		-- recheck to log invalid dates such as 1997-02-29
		set @errorIds = "";
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(forcw) is null
					and ",srcField," is not null and length(",srcField,") > 0  and forcw != 'MACRO_ERROR'  and forcw is not null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
       
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin	
				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
				 
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;
        
        
		set @goodIds = "";

		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where  ",srcField," is not null and length(",srcField,") > 0  
					and (forcw != 'MACRO_ERROR' or forcw is null)
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @goodIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		-- recheck to log invalid dates such as 1997-02-29
		if (@goodIds is not null) then

		begin

		-- now we reformat to mmddyyyy with con1
		set @stmt = concat("update ",@translatedTable, " set ",srcField," = date_format(forcw, '",@outboundDateFormat,"') where id in (",@goodIds,") ");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;

		-- now we handle the two digit years that are converted to future MySQL dates
		call fix2DigitMySQLYears(configId, batchId, srcField, fieldA, fieldB, con1, con2, macroId, foroutboundProcessing, passClear, transactionId);

end proc_main$$

DELIMITER ;

USE `universaltranslatorca`;
DROP procedure IF EXISTS `datemmddyyWithSlashesToyyyymmdd`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `datemmddyyWithSlashesToyyyymmdd`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


		set @mysqlDateFormat = concat('%Y-%m-%d');
		set @inboundDateFormat = concat('%m/%d/%y');
        set @outboundDateFormat = concat('%Y%m%d');
		
         -- check to make sure it is two digit years
        set @errorIds = '';
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where left(right(F1, 3), 1) != '/' 
					and ",srcField," is not null and length(",srcField,") > 0 and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin

				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
		
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;
        
--  check inbound date formats and log
		set @errorIds = "";
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(",srcField,", '",@inboundDateFormat,"') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin
				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
		end;
		end if;


		-- update it to valid mysql date fomat
		set @stmt = concat("update ",@translatedTable, " set forcw = str_to_date(",srcField,", '",@inboundDateFormat,"') where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
                    
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
      

		-- recheck to log invalid dates such as 1997-02-29
		set @errorIds = "";
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(forcw) is null
					and ",srcField," is not null and length(",srcField,") > 0  and forcw != 'MACRO_ERROR'  and forcw is not null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
       
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin	
				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
				 
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;
        
        
		set @goodIds = "";

		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where  ",srcField," is not null and length(",srcField,") > 0  
					and (forcw != 'MACRO_ERROR' or forcw is null)
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @goodIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		-- recheck to log invalid dates such as 1997-02-29
		if (@goodIds is not null) then

		begin

		-- now we reformat to mmddyyyy with con1
		set @stmt = concat("update ",@translatedTable, " set ",srcField," = date_format(forcw, '",@outboundDateFormat,"') where id in (",@goodIds,") ");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;

		-- now we handle the two digit years that are converted to future MySQL dates
		call fix2DigitMySQLYears(configId, batchId, srcField, fieldA, fieldB, con1, con2, macroId, foroutboundProcessing, passClear, transactionId);

end proc_main$$

DELIMITER ;

USE `universaltranslatorca`;
DROP procedure IF EXISTS `datemddyyyyWithSlashesToyyyymmdd`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `datemddyyyyWithSlashesToyyyymmdd`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		set @mysqlDateFormat = concat('%Y-%m-%d');
		set @inboundDateFormat = concat('%c/%d/%Y');
        set @outboundDateFormat = concat('%Y%m%d');
		
         -- check to make sure it is two digit years
        set @errorIds = '';
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where left(right(F1, 5), 1) != '/' 
					and ",srcField," is not null and length(",srcField,") > 0 and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin

				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
		
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;
        

--  check inbound date formats and log
		set @errorIds = "";
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(",srcField,", '",@inboundDateFormat,"') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin
				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
		end;
		end if;


		-- update it to valid mysql date fomat
		set @stmt = concat("update ",@translatedTable, " set forcw = str_to_date(",srcField,", '",@inboundDateFormat,"') where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
                    
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
      

		-- recheck to log invalid dates such as 1997-02-29
		set @errorIds = "";
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(forcw) is null
					and ",srcField," is not null and length(",srcField,") > 0  and forcw != 'MACRO_ERROR'  and forcw is not null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
       
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin	
				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
				 
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;
        
        
		set @goodIds = "";

		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where  ",srcField," is not null and length(",srcField,") > 0  
					and (forcw != 'MACRO_ERROR' or forcw is null)
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @goodIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		-- recheck to log invalid dates such as 1997-02-29
		if (@goodIds is not null) then

		begin

		-- now we reformat to mmddyyyy with con1
		set @stmt = concat("update ",@translatedTable, " set ",srcField," = date_format(forcw, '",@outboundDateFormat,"') where id in (",@goodIds,") ");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;

end proc_main$$

DELIMITER ;



USE `universaltranslatorca`;
DROP procedure IF EXISTS `datemmdyyyyWithSlashesToyyyymmdd`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `datemmdyyyyWithSlashesToyyyymmdd`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		set @mysqlDateFormat = concat('%Y-%m-%d');
		set @inboundDateFormat = concat('%m/%e/%Y');
        set @outboundDateFormat = concat('%Y%m%d');
		
         -- check to make sure it is two digit years
        set @errorIds = '';
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where left(right(F1, 5), 1) != '/' 
					and ",srcField," is not null and length(",srcField,") > 0 and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin

				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
		
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;
        
--  check inbound date formats and log
		set @errorIds = "";
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(",srcField,", '",@inboundDateFormat,"') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin
				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
		end;
		end if;


		-- update it to valid mysql date fomat
		set @stmt = concat("update ",@translatedTable, " set forcw = str_to_date(",srcField,", '",@inboundDateFormat,"') where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
                    
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
      

		-- recheck to log invalid dates such as 1997-02-29
		set @errorIds = "";
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(forcw) is null
					and ",srcField," is not null and length(",srcField,") > 0  and forcw != 'MACRO_ERROR'  and forcw is not null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
       
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin	
				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
				 
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;
        
        
		set @goodIds = "";

		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where  ",srcField," is not null and length(",srcField,") > 0  
					and (forcw != 'MACRO_ERROR' or forcw is null)
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @goodIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		-- recheck to log invalid dates such as 1997-02-29
		if (@goodIds is not null) then

		begin

		-- now we reformat to mmddyyyy with con1
		set @stmt = concat("update ",@translatedTable, " set ",srcField," = date_format(forcw, '",@outboundDateFormat,"') where id in (",@goodIds,") ");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;


end proc_main$$

DELIMITER ;

USE `universaltranslatorca`;
DROP procedure IF EXISTS `datemdyyyyWithSlashesToyyyymmdd`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `datemdyyyyWithSlashesToyyyymmdd`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;




set @errorIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(",srcField,", '%c/%e/%Y') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

if (@errorIds is not null) then

begin

set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;


set @stmt = concat("update ",@translatedTable, " set ",srcField," = str_to_date(",srcField,", '%c/%e/%Y') where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 	
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
      

set @errorIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(",srcField,") is null
					and ",srcField," is not null and length(",srcField,") > 0  and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


if (@errorIds is not null) then

begin

set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;

set @errorIds = '';



set @stmt = concat("update ",@translatedTable, " set ",srcField," =  replace(",srcField,", '-', '')
where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") 
");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


end proc_main$$

DELIMITER ;


USE `universaltranslatorca`;
DROP procedure IF EXISTS `dateyyyymmddWithDashesToyyyymmdd`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `dateyyyymmddWithDashesToyyyymmdd`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;




set @errorIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(",srcField,", '%Y-%m-%d') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

if (@errorIds is not null) then

begin

set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;


set @stmt = concat("update ",@translatedTable, " set ",srcField," = str_to_date(",srcField,", '%Y-%m-%d') where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 	
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
      

set @errorIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(",srcField,") is null
					and ",srcField," is not null and length(",srcField,") > 0  and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


if (@errorIds is not null) then

begin

set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;

set @errorIds = '';


set @stmt = concat("update ",@translatedTable, " set ",srcField," =  replace(",srcField,", '-', '')
where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") 
");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


end proc_main$$

DELIMITER ;

USE `universaltranslatorca`;
DROP procedure IF EXISTS `datemddyyyyToyyyymmdd`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `datemddyyyyToyyyymmdd`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		set @mysqlDateFormat = concat('%Y-%m-%d');
		set @inboundDateFormat = concat('%Y-%m-%d');
        set @outboundDateFormat = concat('%Y%m%d');

                set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where length(",srcField,") !=7 and length(",srcField,") !=8
                and ",srcField," is not null and length(",srcField,") > 0");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
		
				/**
					manually add slashes to make it mysql date format since mysql has trouble understanding dates without date separator
					if 7 digits we insert one-two-four
                    if 8 digits we insert two-two-four
                
                **/
                
				set @stmt = concat("update ",@translatedTable, " set forcw = concat(right(",srcField,", 4), '',  '-0', left(",srcField,", 1), '-', substring(",srcField,", 2,2)) 
                where length(",srcField,") =7 and forcw != 'MACRO_ERROR' or forcw is null
                and ",srcField," is not null and length(",srcField,") > 0");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
                
                
                set @stmt = concat("update ",@translatedTable, " set forcw = concat(right(",srcField,", 4), '-',left(",srcField,", 2) , '-', substring(",srcField,", 2,2))
                where length(",srcField,") =8 and forcw != 'MACRO_ERROR' or forcw is null
                and ",srcField," is not null and length(",srcField,") > 0");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
		
				--  check inbound date formats and log
				set @errorIds = "";
				set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(forcw, '",@inboundDateFormat,"') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin
				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
		end;
		end if;

		
		-- recheck to log invalid dates such as 1997-02-29
		set @errorIds = "";
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(forcw) is null
					and ",srcField," is not null and length(",srcField,") > 0 and forcw != 'MACRO_ERROR' and forcw is not null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
       
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin	
				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
				 
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;
        
        
		set @goodIds = "";

		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where  ",srcField," is not null and length(",srcField,") > 0  
					and (forcw != 'MACRO_ERROR' or forcw is null)
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @goodIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		-- recheck to log invalid dates such as 1997-02-29
		if (@goodIds is not null) then

		begin

		-- now we reformat to mddyyyy with con1
		set @stmt = concat("update ",@translatedTable, " set ",srcField," = date_format(forcw, '",@outboundDateFormat,"') where id in (",@goodIds,") ");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;

end proc_main$$

DELIMITER ;

USE `universaltranslatorca`;
DROP procedure IF EXISTS `datemmddyyWithSlashesToyyyymmdd`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `datemmddyyWithSlashesToyyyymmdd`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


		set @mysqlDateFormat = concat('%Y-%m-%d');
		set @inboundDateFormat = concat('%m/%d/%y');
        set @outboundDateFormat = concat('%Y%m%d');
		
         -- check to make sure it is two digit years
        set @errorIds = '';
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where left(right(F1, 3), 1) != '/' 
					and ",srcField," is not null and length(",srcField,") > 0 and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin

				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
		
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;
        
--  check inbound date formats and log
		set @errorIds = "";
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(",srcField,", '",@inboundDateFormat,"') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin
				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
		end;
		end if;


		-- update it to valid mysql date fomat
		set @stmt = concat("update ",@translatedTable, " set forcw = str_to_date(",srcField,", '",@inboundDateFormat,"') where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
                    
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
      

		-- recheck to log invalid dates such as 1997-02-29
		set @errorIds = "";
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(forcw) is null
					and ",srcField," is not null and length(",srcField,") > 0  and forcw != 'MACRO_ERROR'  and forcw is not null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
       
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin	
				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
				 
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;
        
        
		set @goodIds = "";

		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where  ",srcField," is not null and length(",srcField,") > 0  
					and (forcw != 'MACRO_ERROR' or forcw is null)
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @goodIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		-- recheck to log invalid dates such as 1997-02-29
		if (@goodIds is not null) then

		begin

		-- now we reformat to mmddyyyy with con1
		set @stmt = concat("update ",@translatedTable, " set ",srcField," = date_format(forcw, '",@outboundDateFormat,"') where id in (",@goodIds,") ");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;
        
		-- now we handle the two digit years that are converted to future MySQL dates
		call fix2DigitMySQLYears(configId, batchId, srcField, fieldA, fieldB, con1, con2, macroId, foroutboundProcessing, passClear, transactionId);

end proc_main$$

DELIMITER ;

USE `universaltranslatorca`;
DROP procedure IF EXISTS `datedmyyWithSlashesToyyyymmdd`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `datedmyyWithSlashesToyyyymmdd`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;




set @errorIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(",srcField,", '%e/%c/%y') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

if (@errorIds is not null) then

begin

set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;



set @errorIds = '';
set @stmt = concat("select group_concat(id) from ",@translatedTable, " where left(right(F1, 3), 1) != '/' 
					and ",srcField," is not null and length(",srcField,") > 0 and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

if (@errorIds is not null) then

begin

set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;



set @stmt = concat("update ",@translatedTable, " set ",srcField," = str_to_date(",srcField,",  '%e/%c/%y') where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 	
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
       
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
        
        

BEGIN
		set @stmt = concat("update ",@translatedTable," set  ", srcField ," = replace(",srcField, ", '206','196')   where  forcw is null and configId = ",configId," and ", @batchIdType, " = ",batchId," and statusId not in (",@finalStatusIds,");");
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;   
        
        set @stmt = concat("update ",@translatedTable," set  ", srcField ," = replace(",srcField, ", '205','195')   where  forcw is null and configId = ",configId," and ", @batchIdType, " = ",batchId," and statusId not in (",@finalStatusIds,");");
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;   
        
        set @stmt = concat("update ",@translatedTable," set  ", srcField ," = replace(",srcField, ", '204','194')   where forcw is null and  configId = ",configId," and ", @batchIdType, " = ",batchId," and statusId not in (",@finalStatusIds,");");
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;   
        
       set @stmt = concat("update ",@translatedTable," set  ", srcField ," = replace(",srcField, ", '203','193')   where forcw is null and  configId = ",configId," and ", @batchIdType, " = ",batchId," and statusId not in (",@finalStatusIds,");");
	   PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;    
    END;


      

set @errorIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(",srcField,") is null
					and ",srcField," is not null and length(",srcField,") > 0  and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


if (@errorIds is not null) then

begin

set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;

set @errorIds = '';


set @stmt = concat("update ",@translatedTable, " set ",srcField," =  replace(",srcField,", '-', '')
where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") 
");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

end proc_main$$

DELIMITER ;

USE `universaltranslatorca`;
DROP procedure IF EXISTS `CheckInvalidDateAndError`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `CheckInvalidDateAndError`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
SELECT 
    @translatedTable,
    @transactionTable,
    @batchTable,
    @batchIdType,
    @errorTable,
    @translateCol
INTO @translatedTable , @transactionTable , @batchTable , @batchIdType , @errorTable, @translateCol;

call getFinalStatusIds;
SELECT @finalStatusIds INTO @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


set @errorIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, "  where 
					(str_to_date(",srcField,",'",con1,"') is null or str_to_date(",srcField,",'",con1,"') = '0000-00-00'
                    or right(str_to_date(",srcField,",'",con1,"'), 2) = '00' or left(str_to_date(",srcField,",'",con1,"'), 2) = '00' 
                    or substring(str_to_date(",srcField,",'",con1,"'), 6, 2) = '00' 
                    ) 
                    and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
       
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


if (@errorIds is not null) then

begin

set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;
     


set @stmt = concat("update ",@translatedTable, " set forcw = str_to_date(",srcField,", '",con1,"') where (forcw is null or forcw != 'MACRO_ERROR')
					and ",srcField," is not null and length(",srcField,") > 0 	
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
 

set @errorIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(forcw) is null
					and ",srcField," is not null and length(",srcField,") > 0  and  (forcw is null or forcw != 'MACRO_ERROR')
					and ",srcField," is not null and length(",srcField,") > 0 	
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


if (@errorIds is not null) then

begin

set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;


end proc_main$$

DELIMITER ;



