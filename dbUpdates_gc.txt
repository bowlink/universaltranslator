/** macro updates **/
DROP PROCEDURE if exists yyyymmddToDate;
delete from macro_names where formula = 'yyyymmddToDate';

drop procedure if exists dateyyyymmddTimeToDateTime;
delete from macro_names where formula = 'dateyyyymmddTimeToDateTime';

drop procedure if exists if1Con1ElseNull;
delete from macro_names where formula = 'if1Con1ElseNull';

drop procedure if exists if1Con1ElseCon2;
delete from macro_names where formula = 'if1Con1ElseCon2';

drop procedure if exists cat2Concat3ColsDelimNoSpaces;
delete from  macro_names where formula = 'cat2Concat3ColsDelimNoSpaces';

delete from  macro_names where formula = 'cat2Concat2ColsDelimNoSpaces';
drop procedure if exists cat2Concat2ColsDelimNoSpaces;

delete from  macro_names where formula = 'cat2DelTransWhenNull';
drop procedure if exists cat2DelTransWhenNull;

delete from  macro_names where formula = 'CleanTranslatedListTable';
drop procedure if exists CleanTranslatedListTable;

delete from  macro_names where formula = 'cat2ApplyCWTranslatedList';
drop procedure if exists cat2ApplyCWTranslatedList;

delete from macro_names where formula = 'addCharToString';
drop procedure if exists addCharToString;

DROP PROCEDURE if exists yyyymmddToDate;
delete from macro_names where formula = 'yyyymmddToDate';

drop procedure if exists dateyyyymmddTimeToDateTime;
delete from macro_names where formula = 'dateyyyymmddTimeToDateTime';

delete from macro_names where formula = 'addDelimiterEvery2Characters';
drop procedure if exists addDelimiterEvery2Characters;

drop procedure if exists ifDateCon1ElseNull;
delete from macro_names where formula = 'ifDateCon1ElseNull';

UPDATE `universaltranslatorca`.`macro_Names` SET `Con1_Question`='Please enter source SF\'s date value separator.  e.g. -, ., /', `Con2_Question`='Please enter target SF\'s date value separator.  e.g. -, ., /' WHERE `ID`='68';
UPDATE `universaltranslatorca`.`macro_Names` SET `Con1_Question`='Please enter source SF\'s date value separator.  e.g. -, ., /', `Con2_Question`='Please enter target SF\'s date value separator.  e.g. -, ., /' WHERE `ID`='69';

UPDATE `universaltranslatorca`.`macro_Names` SET `Macro_Name`='Date - yyyy*mm*dd to mm*dd*yyyy' WHERE `ID`='68';
UPDATE `universaltranslatorca`.`macro_Names` SET `Macro_Name`='Date - mm*dd*yyyy to yyyy*mm*dd' WHERE `ID`='69';

UPDATE `universaltranslatorca`.`macro_names` SET `FieldB_Question`='Handle MySQL 2 digit year limitations for 2 digit years ending in 30-69. (Y/N)', `Con1_Question`='Please enter the inbound string\'s date format', `Con2_Question`='Please enter the outbound string\'s date format' WHERE `ID`='112';

drop procedure if exists yyyymmddstripTime;
delete from macro_names where formula = 'yyyymmddstripTime';

drop procedure if exists ifNonDateSetNull;
delete from macro_names where formula = 'ifNonDateSetNull';

delete from macro_names where formula = 'dateYYYYMMDDHHMMSSMSToYYYYMMDDHHMMSS';
drop procedure if exists dateYYYYMMDDHHMMSSMSToYYYYMMDDHHMMSS;


/** Still TO DO **/
UPDATE `universaltranslatorca`.`macro_names` SET `FieldA_Question`='Please enter value you would like to prepend', `FieldB_Question`='Prepend if the field is blank (Y/N).', `Con1_Question`='Please enter value you would like to append', `Con2_Question`='Append if the field is blank (Y/N).' WHERE `ID`='102';

update configurationdatatranslations set macroId = 76 where macroId = 110;

drop procedure if exists IfSFLen0orNullReplaceValue;


drop procedure if exists concatColumnsToList;
delete from macro_names where formula = 'concatColumnsToList';

drop procedure if exists IfSFLen0orNullReplaceValue;
delete from macro_names where formula = 'IfSFLen0orNullReplaceValue';

/** ***** **/
/**  20200917 **/
 
drop procedure if exists ArithmeticForSFAndFAUpdateFB;
delete from macro_names where formula = 'ArithmeticForSFAndFAUpdateFB';

drop procedure if exists DeleteTransactionWhenFieldIsNull;
delete from macro_names where formula = 'DeleteTransactionWhenFieldIsNull';

/** 20200920 **/
USE `universaltranslatorca`;
DROP procedure IF EXISTS `futureDateCheck`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `futureDateCheck`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

set @stmt = concat("select group_concat(id) from " , @translatedTable, " where
 ((Date(",srcField,") is null and length(",srcField,") > 0)
 or (curdate() >= ", srcField , " = 0))
 and  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

if (@errorIds is not null) then
	begin
		set @stmt = concat("update " , @translatedTable, "  set forCW = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
	end;
end if;

set @errorIds = '';


end proc_main$$

DELIMITER ;

/** 20200921 **/

drop procedure if exists GreaterThanEqualFieldAUpdateFieldB;
delete from macro_names where formula = 'GreaterThanEqualFieldAUpdateFieldB';


drop procedure if exists lessThanEqualFieldAUpdateFieldB;
delete from macro_names where formula = 'lessThanEqualFieldAUpdateFieldB';

drop procedure if exists countListSize;
delete from macro_names where formula = 'countListSize';


INSERT INTO `macro_names` (`ID`, `CategoryId`, `Macro_Name`, `Macro_Short_Name`, `Formula`, `FieldA_Question`, `FieldB_Question`, `Con1_Question`, `Con2_Question`) VALUES ('197', '1', 'Compare Two Fields and Update SF to Con2', 'Compare Two Fields and Update SF to Con2', 'CompareTwoFieldsAndUpdateSFWithCon2', 'Please enter field to compare source field to', ' ', 'Please enter comparison (< , <=, =, >, >=, !=)', 'Please enter value to update SF to');

USE `universaltranslatorca`;
DROP procedure IF EXISTS `CompareTwoFieldsAndUpdateSFWithCon2`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `CompareTwoFieldsAndUpdateSFWithCon2`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

/** 
this macro compares SF and FA using con1 operator
and will update to con2

**/

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


	/** allowed comparison >, >=, =, <, <=, != **/
      if con1 != '>'  and  con1 != '>='  and con1!='=' and con1 != '<' and con1 != '<=' and con1 != '!=' and con1 != '<>'then
					begin
			
							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'CompareTwoFieldsAndUpdateSF con1 - ", con1," is not a valid comparison.'",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
           
			leave proc_main;
        end;
      end if;


	-- leaving it for now, nulls are ignored by default. In case we need to handle issues comparing null and values, we will update this 
	set @sqlBlanks = '';
	
    /** MySql doesn't compare integers and decimals well
		we create a temp table and insert those into a table that specifics them as float
    **/
    set @stmt = concat("drop table if exists transactionnumericcompare_", batchId);
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
    
    
    set @stmt = concat("CREATE TABLE transactionnumericcompare_",batchId," (
			  id int(11) NOT NULL AUTO_INCREMENT,
			  transactionId int(11) DEFAULT NULL,
			  compareResult bit(1) NOT NULL DEFAULT b'0',
			  col1Data FLOAT(20,10) DEFAULT NULL,
			  col2Data FLOAT(20,10) DEFAULT NULL,
			  PRIMARY KEY (id),
			  KEY numCompResult (compareResult)
			  ) ENGINE=InnoDB DEFAULT CHARSET=latin1;");
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
    
	/** now we insert the numeric values and compare those **/
    set @stmt = concat("insert into transactionnumericcompare_",batchId," 
    (transactionId, col1Data, col2Data)
    select ",@translateCol,", ",srcField,", ",fieldA," from ", @translatedTable, 
    " where ",srcField, "  REGEXP '^[+-]?[0-9]*[.]{0,1}[0-9]*$' = 1
    and ",fieldA, "  REGEXP '^[+-]?[0-9]*[.]{0,1}[0-9]*$' = 1 
    and length(",srcField, ") > 0 and length(",fieldA, ") > 0",
	@sqlBlanks);
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
	
	/** this way it will compare better **/
    set @stmt = concat("update ",@translatedTable, " join 
	(select col1data ", con1 ," col2data comparedResults , transactionId from transactionnumericcompare_",batchId,") t2
	on transactionId = ",@translateCol,"
	set forCW = 'compared', ",srcField," = case when comparedResults then '",con2,"' else ",srcField," end ");
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
    
		
	 /** we compare and update **/
     set @stmt = concat("update  ",@translatedTable, " t1 join 
		(select ",srcField, " " , con1, " ",fieldA," comparedResults , ",@translateCol," 
		from  ",@translatedTable, " where forCW is null or forCW != 'compared') t2
		on t1.",@translateCol," = t2.",@translateCol,"
		set ",srcField," = case when comparedResults then '",con2,"' else ",srcField," end");
	 
     PREPARE stmt from @stmt;
     EXECUTE stmt;
     DEALLOCATE PREPARE stmt;
     
     
	set @stmt = concat("drop table if exists transactionnumericcompare_", batchId);
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;

end proc_main$$

DELIMITER ;

update macro_names set fieldA_Question = '', fieldB_Question = '' where formula = 'stringToDate';


USE `universaltranslatorca`;
DROP procedure IF EXISTS `stringToDate`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `stringToDate`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


		set @mysqlDateFormat = concat('%Y-%m-%d');

		set @inboundDateFormat = con1;
        
		if (length(con2) > 0) then
			set @outboundDateFormat = concat(con2);
		else 
			set @outboundDateFormat = concat('%Y-%m-%d');
		end if;



		set @errorIds = "";
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(",srcField,", '",@inboundDateFormat,"') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

	if (@errorIds is not null) then

		begin
				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
						
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
		end;
	end if;

	set @stmt = concat("update ",@translatedTable, " set ",srcField," = str_to_date(",srcField,", '",@inboundDateFormat,"') where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 	
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
            
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
      


	set @errorIds = "";
	set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(",srcField,") is null
					and ",srcField," is not null and length(",srcField,") > 0  and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
       
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

if (@errorIds is not null) then

begin	
		set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
		
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;

	
set @goodIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where  ",srcField," is not null and length(",srcField,") > 0  and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @goodIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
		
		if (@goodIds is not null) then

			begin
					-- fix two digit years
					-- check to make sure %y is in the inbound to handle
                    select year(curdate()) into @currYear;
                    
					if  (@inboundDateFormat like BINARY '%\%y%' && @outboundDateFormat not like BINARY '%\%y%') then 
					
					select year(curdate()) into @currYear;

					set @stmt = concat("update ",@translatedTable, " set ",srcField," =  DATE_ADD(",srcField,", INTERVAL -100 Year) where id in (",@goodIds,") 
					and year(",srcField,") > ",@currYear,"");
					
					PREPARE stmt from @stmt;
					EXECUTE stmt;
					DEALLOCATE PREPARE stmt;
                    
                    -- translate to final format
                    set @stmt = concat("update ",@translatedTable, " set ",srcField," = date_format(",srcField,", '",@outboundDateFormat,"') where id in (",@goodIds,") ");
					
					PREPARE stmt from @stmt;
					EXECUTE stmt;
					DEALLOCATE PREPARE stmt;
		end if;
                    
			end;
		end if;
        
        

end proc_main$$

DELIMITER ;

drop procedure if exists populateWithBatchUploadId;
delete from macro_names where formula = 'populateWithBatchUploadId';

drop procedure if exists ifNonDateAndNotBlankReject;
delete from macro_names where formula = 'ifNonDateAndNotBlankReject';

UPDATE `universaltranslatorca`.`macro_names` SET `Macro_Short_Name`='ifNotBlankError', `Formula`='ifNotBlankError' WHERE `ID`='150';

drop procedure if exists ifNotBlankReject;

USE `universaltranslatorca`;
DROP procedure IF EXISTS `ZipCodeCheck`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `ZipCodeCheck`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
SELECT 
    @translatedTable,
    @transactionTable,
    @batchTable,
    @batchIdType,
    @errorTable,
    @translateCol
INTO @translatedTable , @transactionTable , @batchTable , @batchIdType , @errorTable, @translateCol;

call getFinalStatusIds;
SELECT @finalStatusIds INTO @finalStatusIds;

				
                set @proceed = true;
                
                
                if (length(con1) > 0) then
					begin
						
                        if con1 REGEXP '^[0-9]{5}$' = 0 then 
                        
							set @proceed = false;
                            
							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, fieldValue, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'Default zip code ",con1," is not a valid value'",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            
                            leave proc_main;
						end if;
					end;
                end if;

				if (@proceed) then 
								begin
								
								set @whereStmt =  concat(" and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");
								set @whereClause = concat("  (",srcField," REGEXP '^[0-9]{5}$' != 1) 
								and ",srcField," is not null and length(",srcField,") > 0 ");
							    set @whereString = concat(@whereClause , @whereStmt);

								set @stmt = concat("update  ", @translatedTable , " set forcw = ",srcField);
								PREPARE stmt from @stmt;
								EXECUTE stmt;
								DEALLOCATE PREPARE stmt;

								set @stmt = concat("update  ", @translatedTable , " set ",srcField," = replace(",srcField,", '-', '') where (length(", srcField,") != 0 or ",srcField," is not null )", @whereStmt);
								PREPARE stmt from @stmt;
								EXECUTE stmt;
								DEALLOCATE PREPARE stmt;
								
								
								
								set @stmt = concat("update  ", @translatedTable , " set ",srcField," = 
								case 
								when (length(",srcField,") = 4 or length(",srcField,") = 8) then concat('0', ",srcField,") 
								when (length(",srcField,") = 3 or length(",srcField,") = 7)  then concat('00', ",srcField,") 
								when (length(",srcField,") = 2  or length(",srcField,") = 6)  then concat('000', ",srcField,") 
								when length(",srcField,") = 1 then concat('0000', ",srcField,") 
								else ",srcField," end where length(",srcField,") != 5 ", @whereStmt);
								
								PREPARE stmt from @stmt;
								EXECUTE stmt;
								DEALLOCATE PREPARE stmt;
							   
								set @stmt = concat("update  ", @translatedTable , " set ",srcField," = left(",srcField,", 5) where length(", srcField,") > 5", @whereStmt);
								 
								PREPARE stmt from @stmt;
								EXECUTE stmt;
								DEALLOCATE PREPARE stmt;
                                
								
								set @stmt = concat("update  ", @translatedTable , " set forcw = 'MACRO_ERROR' where  ", @whereString);
                               
								PREPARE stmt from @stmt;
								EXECUTE stmt;
								DEALLOCATE PREPARE stmt;
							   
								if (length(con1) > 0) then
												
													set @stmt = concat("update  ", @translatedTable , " set forcw='BlankVar', ",srcField," = '",con1,"' where (length(", srcField,") = 0 or ",srcField," is null )  ", @whereStmt);
													
                                                    PREPARE stmt from @stmt;
													EXECUTE stmt;
													DEALLOCATE PREPARE stmt;
								end if;
							   
				

			end;
	end if;
				
end proc_main$$

DELIMITER ;


USE `universaltranslatorca`;
DROP procedure IF EXISTS `ifNotBlankError`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `ifNotBlankError`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

	call setInboundOutBoundTables (foroutboundProcessing,batchId);
	select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn
	into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn;

	call getFinalStatusIds;
	select @finalStatusIds into @finalStatusIds;

    set @stmt = concat("update  ", @translatedTable , " set forcw = 'MACRO_ERROR' where ",
    srcField," is not null and length(",srcField,") > 0 ",
    " and  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");

	PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

end proc_main$$

DELIMITER ;

USE `universaltranslatorca`;
DROP procedure IF EXISTS `rejectNonYearMonthTransactions`;

UPDATE `universaltranslatorca`.`macro_names` SET `CategoryId`='0', `Macro_Short_Name`='errorNonYearMonthTransactions', `Formula`='errorNonYearMonthTransactions' WHERE `ID`='152';

USE `universaltranslatorca`;
DROP procedure IF EXISTS `errorNonYearMonthTransactions`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `errorNonYearMonthTransactions`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin



call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @translateCol;


call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

set @whereClause = concat(" and  configId = ",configId," and ", @batchIdColumn," = ",batchId," and statusId not in (",@finalStatusIds ,") ");

set @totalCount1 = 0;
set @yearMonthToUse1 = 0;

set @stmt = concat("select count(*) totalCount, 
DATE_FORMAT(",srcField,",'%Y%m') monthYearForFile from ",@translatedTable," where ",srcField," is not null ", @whereClause,"
group by 
DATE_FORMAT(",srcField,",'%Y%m')
order by totalCount desc limit 0, 1 into @totalCount1, @yearMonthToUse1
;");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

set @totalCount2 = 0;
set @yearMonthToUse2 = 0;

set @stmt = concat("select count(*) totalCount, 
DATE_FORMAT(",srcField,",'%Y%m') monthYearForFile from ",@translatedTable," where ",srcField," is not null ", @whereClause,"
group by 
DATE_FORMAT(",srcField,",'%Y%m')
order by totalCount desc limit 1, 1 into @totalCount2, @yearMonthToUse2
;");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


set @stmt = concat("select fieldDesc from configurationformfields where configId = ",configId," 
and fieldNo = replace('",srcField,"', 'F', '') 
into @fieldLabel;");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;



if (@totalCount1 = @totalCount2) then
 
	BEGIN
			set @stmt = concat("insert into ", @errorTable , " (" , @batchIdColumn, ", configId, " , @translateCol, 
			", fieldNo, errorId, macroId, stackTrace, required, fieldLabel, fieldValue) select ",batchId,", ",configId,", ",@translateCol, ", replace('",srcField,"', 'F', ''), ", 8, 
			", ",macroId, ", 'Macro rejectNonYearMonthTransactions - Could not determine which date to use:  "  "Year Month - ",@yearMonthToUse1, " and ",@yearMonthToUse2," have the same numbers of transactions - ",@totalCount1, "'",
            ", true, '",@fieldLabel,"', ",srcField," from ", @translatedTable, " where ",
			srcField," is not null and length(",srcField,") > 0 ", @whereClause, ";");
            
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
        set @stmt = concat("update ",@translatedTable, " set statusId = 14 where ",
			srcField," is not null and length(",srcField,") > 0 ", @whereClause, ";");
            
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
        
	END;
end if;
			if (@totalCount1 > @totalCount2) then
				BEGIN
                
					
					set @stmt = concat("insert into ", @errorTable , " (" , @batchIdColumn, ", configId, " , @translateCol, 
					", fieldNo, errorId, macroId, stacktrace, required,fieldLabel, fieldValue) select ",batchId,", ",configId,", ", @translateCol, ", replace('",srcField,"', 'F', ''), 60,",
                    macroId,", concat('Year and month of ', DATE_FORMAT(",srcField,",'%Y%m'), ' for ',",srcField,", ' does not match year and month ',",@yearMonthToUse1,",' used for processing.')
                    , true, '",@fieldLabel,"', ",srcField,"  from ", @translatedTable, " where ",
					srcField," is not null and length(",srcField,") > 0 ",
                    " and DATE_FORMAT(",srcField,",'%Y%m') != ", @yearMonthToUse1, " ", 
                    @whereClause, ";");
					
                    PREPARE stmt from @stmt;
					EXECUTE stmt;
					DEALLOCATE PREPARE stmt;
                    
                    set @stmt = concat("update ",@translatedTable, " set statusId = 14 where ",
					srcField," is not null and length(",srcField,") > 0 ",
                    " and DATE_FORMAT(",srcField,",'%Y%m') != ", @yearMonthToUse1, " ", 
                    @whereClause, ";");
                    
					PREPARE stmt from @stmt;
					EXECUTE stmt;
					DEALLOCATE PREPARE stmt;
                
                END;
		end if;


end proc_main$$

DELIMITER ;

delete from macro_names where formula = 'StringToDateFor2DigitYears';
drop procedure if exists StringToDateFor2DigitYears;

delete from macro_names where formula = 'prependStringWithCon2IfLengthMataches';
drop procedure if exists prependStringWithCon2IfLengthMataches;

delete from macro_names where formula = 'CopyColumnTTItoTIR';
drop procedure if exists CopyColumnTTItoTIR;

USE `universaltranslatorca`;
DROP procedure IF EXISTS `regExCheck`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `regExCheck`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
SELECT 
    @translatedTable,
    @transactionTable,
    @batchTable,
    @batchIdType,
    @errorTable,
    @translateCol
INTO @translatedTable , @transactionTable , @batchTable , @batchIdType , @errorTable, @translateCol;

call getFinalStatusIds;
SELECT @finalStatusIds INTO @finalStatusIds;


set @whereClause  = concat("  (",srcField," REGEXP '",con1,"' != 1 or ",srcField," REGEXP '^[",con1,"]*$' is null)
            and ",srcField," is not null and  length(",srcField,") > 0 and ");
            
set @whereString = concat(@whereClause, "  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");

			set @stmt = concat("update  ", @translatedTable , " set forcw = 'MACRO_ERROR'  where ",@whereString);

			PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;


end proc_main$$

DELIMITER ;

USE `universaltranslatorca`;
DROP procedure IF EXISTS `applyCWTranslatedListNoTrackDroppedValues`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `applyCWTranslatedListNoTrackDroppedValues`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin 

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @listTable, @translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @listTable, @translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

if (transactionId = 0) then
	set @whereString = concat(" and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");
end if;

if (transactionId != 0) then
	set @whereString = concat(" and ",	@transactionTable,".id = ", transactionId,";");
end if;

set @fcol = replace(lcase(srcField), 'f', '');
set @stmt = concat("truncate table ", @listTable);

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


		

		set @stmt = concat("
		SELECT max(CHAR_LENGTH(",srcField,") - CHAR_LENGTH( REPLACE ( ",srcField,", ',', '') )  + 1) from ",@translatedTable, " into @maxListLength");
		
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
         
        if (@maxListLength is null) then
			set @maxListLength = 108;
        end if;
       
		set @stmt = concat("
    insert into ", @listTable," (",@batchIdType,", ",@translateCol,", invalue, fcol)
    SELECT ",@batchIdType,", ",@translateCol,", IFNULL(trim(SUBSTRING_INDEX(SUBSTRING_INDEX(t.",srcField,", ',', n.n), ',', -1)),'') value, ",@fcol,"
	FROM ",@translatedTable ," t CROSS JOIN (
    SELECT distinct a.N + b.N * 10 + 1 n FROM  
   (select id N from ref_numbers where id <=",@maxListLength,") a
   ,(select id N from ref_numbers where id <=",@maxListLength,") b
    ORDER BY n) n  WHERE n.n <= 1 + (LENGTH(t.",srcField,") - LENGTH(REPLACE(t.",srcField,", ',', ''))) ", @whereString);
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

    
    set @stmt = concat("update ",@listTable," set invalue = replace(replace(invalue, '\n',''), '\r', '')");
	 
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    
    set @stmt2 = "";
	set @stmt1 = concat("update ",@listTable," join (select id, sourcevalue, targetvalue from rel_crosswalkdata where crosswalkid = ", con1 ,") cwdata
	on invalue = sourcevalue set translatedvalue = targetvalue where ",@batchIdType," = ", batchId);
 
	set @stmt = concat(@stmt1, @stmt2);
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
	if (passClear = 1) then
	
	set @stmt1 = concat("update ",@listTable, " set translatedvalue = invalue where translatedvalue is null ");

	set @stmt = concat(@stmt1, @stmt2);
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
	end if;
  
  
  
	set @selDistinct = '';
    
    if (con2 = 'Y') then
		begin
			set @selDistinct = ' distinct ';
        end;
    end if;
  
    set @stmt = concat("update ",@translatedTable," join  (select ",@translateCol," as matchId, 
    group_concat(",@selDistinct," translatedValue order by id) label from  ",@listTable,"
	where ",@batchIdType," = ",batchid, " and fcol = ",@fCol," group by ",@translateCol," ) cwmatch on ",@translateCol," = matchid set ",srcField," = label ");
	   
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    

    set @stmt = concat("delete from ", @listTable, " where ",@batchIdType," = ",batchId," and fcol = ",@fcol);
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;


end proc_main$$

DELIMITER ;


drop procedure if exists ArithmeticConstantStoreInFA;
delete from macro_names where formula = 'ArithmeticConstantStoreInFA';

DROP PROCEDURE `universaltranslatorca`.`CompareTwoFieldsAndReject`;
UPDATE `universaltranslatorca`.`macro_names` SET `Macro_Name`='Conditional: Compare Two Non-Blank Fields and Insert Error when criteria is not met', `Macro_Short_Name`='CompareTwoFieldsAndError', `Formula`='CompareTwoFieldsAndError' WHERE `ID`='146';


USE `universaltranslatorca`;
DROP procedure IF EXISTS `CompareTwoFieldsAndError`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `CompareTwoFieldsAndError`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

/** 
this macro compares SF and FA using con1 operator
Conditional: Compare Two Non-Blank Fields and Insert Error when criteria is not met

**/

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


	/** allowed comparison >, >=, =, <, <=, != **/
      if con1 != '>'  and  con1 != '>='  and con1!='=' and con1 != '<' and con1 != '<=' and con1 != '!=' and con1 != '<>' then
					begin
			
							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'CompareTwoFieldsAndError con1 - ", con1," is not a valid comparison.'",", ",true);
                            
							
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
           
			leave proc_main;
        end;
      end if;


	-- This macro compares non-blank fields
    set @sqlBlanks = concat("  ", fieldA," is not null and ",srcField," is not null 
    and length(", fieldA,") > 0 and length(",srcField,") > 0 
    ");
	
    
    /** MySql doesn't compare integers and decimals well
		we create a temp table and insert those into a table that specifics them as float
    **/
    set @stmt = concat("drop table if exists transactionnumericcompare_", batchId);
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
    
    
    set @stmt = concat("CREATE TABLE transactionnumericcompare_",batchId," (
			  id int(11) NOT NULL AUTO_INCREMENT,
			  transactionId int(11) DEFAULT NULL,
			  compareResult bit(1) NOT NULL DEFAULT b'0',
			  col1Data FLOAT(20,10) DEFAULT NULL,
			  col2Data FLOAT(20,10) DEFAULT NULL,
			  PRIMARY KEY (id),
			  KEY numCompResult (compareResult)
			  ) ENGINE=InnoDB DEFAULT CHARSET=latin1;");
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
    
	/** now we insert the numeric values and compare those **/
    set @stmt = concat("insert into transactionnumericcompare_",batchId," 
    (transactionId, col1Data, col2Data)
    select ",@translateCol,", ",srcField,", ",fieldA," from ", @translatedTable, 
    " where ",srcField, "  REGEXP '^[+-]?[0-9]*[.]{0,1}[0-9]*$' = 1
    and ",fieldA, "  REGEXP '^[+-]?[0-9]*[.]{0,1}[0-9]*$' = 1 
    and length(",srcField, ") > 0 and length(",fieldA, ") > 0 and ",
	@sqlBlanks);
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
	
	/** this way it will compare better **/
    set @stmt = concat("update ",@translatedTable, " join 
	(select col1data ", con1 ," col2data comparedResults , transactionId from transactionnumericcompare_",batchId,") t2
	on transactionId = ",@translateCol,"
	set forCW = case when comparedResults = true then 'compared' else 'MACRO_ERROR' end where", @sqlBlanks);
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
    
		
	 /** we compare and update **/
     set @stmt = concat("update  ",@translatedTable, " t1 join 
		(select ",srcField, " " , con1, " ",fieldA," comparedResults , ",@translateCol," 
		from  ",@translatedTable, " where forCW is null or forCW != 'compared') t2
		on t1.",@translateCol," = t2.",@translateCol,"
		set forCW = case when comparedResults then '' else 'MACRO_ERROR' end where", @sqlBlanks);
	 
     
     PREPARE stmt from @stmt;
     EXECUTE stmt;
     DEALLOCATE PREPARE stmt;

	set @stmt = concat("drop table if exists transactionnumericcompare_", batchId);
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;

end proc_main$$

DELIMITER ;

USE `universaltranslatorca`;
DROP procedure IF EXISTS `CompareTwoFieldsAndUpdateSFWithCon2`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `CompareTwoFieldsAndUpdateSFWithCon2`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

/** 
this macro compares SF and FA using con1 operator
and will update to con2

**/

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


	/** allowed comparison >, >=, =, <, <=, != **/
      if con1 != '>'  and  con1 != '>='  and con1!='=' and con1 != '<' and con1 != '<=' and con1 != '!=' and con1 != '<>'then
					begin
			
							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'CompareTwoFieldsAndUpdateSF con1 - ", con1," is not a valid comparison.'",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
           
			leave proc_main;
        end;
      end if;


	-- we only compare non-empty fields
    set @sqlBlanks = concat("  ", fieldA," is not null and ",srcField," is not null 
    and length(", fieldA,") > 0 and length(",srcField,") > 0 
    ");
	
    /** MySql doesn't compare integers and decimals well
		we create a temp table and insert those into a table that specifics them as float
    **/
    set @stmt = concat("drop table if exists transactionnumericcompare_", batchId);
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
    
    
    set @stmt = concat("CREATE TABLE transactionnumericcompare_",batchId," (
			  id int(11) NOT NULL AUTO_INCREMENT,
			  transactionId int(11) DEFAULT NULL,
			  compareResult bit(1) NOT NULL DEFAULT b'0',
			  col1Data FLOAT(20,10) DEFAULT NULL,
			  col2Data FLOAT(20,10) DEFAULT NULL,
			  PRIMARY KEY (id),
			  KEY numCompResult (compareResult)
			  ) ENGINE=InnoDB DEFAULT CHARSET=latin1;");
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
    
	/** now we insert the numeric values and compare those **/
    set @stmt = concat("insert into transactionnumericcompare_",batchId," 
    (transactionId, col1Data, col2Data)
    select ",@translateCol,", ",srcField,", ",fieldA," from ", @translatedTable, 
    " where ",srcField, "  REGEXP '^[+-]?[0-9]*[.]{0,1}[0-9]*$' = 1
    and ",fieldA, "  REGEXP '^[+-]?[0-9]*[.]{0,1}[0-9]*$' = 1 
    and length(",srcField, ") > 0 and length(",fieldA, ") > 0 and ",
	@sqlBlanks);
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
	
	/** this way it will compare better **/
    set @stmt = concat("update ",@translatedTable, " join 
	(select col1data ", con1 ," col2data comparedResults , transactionId from transactionnumericcompare_",batchId,") t2
	on transactionId = ",@translateCol,"
	set forCW = 'compared', ",srcField," = case when comparedResults then '",con2,"' else ",srcField," end where ", @sqlBlanks);
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
    
		
	 /** we compare and update **/
     set @stmt = concat("update  ",@translatedTable, " t1 join 
		(select ",srcField, " " , con1, " ",fieldA," comparedResults , ",@translateCol," 
		from  ",@translatedTable, " where forCW is null or forCW != 'compared') t2
		on t1.",@translateCol," = t2.",@translateCol,"
		set ",srcField," = case when comparedResults then '",con2,"' else ",srcField," end where ", @sqlBlanks);
	 
     PREPARE stmt from @stmt;
     EXECUTE stmt;
     DEALLOCATE PREPARE stmt;
     
     
	set @stmt = concat("drop table if exists transactionnumericcompare_", batchId);
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;

end proc_main$$

DELIMITER ;

USE `universaltranslatorca`;
DROP procedure IF EXISTS `ifNotNumericSetToCon1`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `ifNotNumericSetToCon1`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

set @whereclause = concat(" and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
set @stmt1 = concat("update ",@translatedTable, " set ",srcField, " = '", con1 , "' where  ",srcField ," REGEXP  '^-?[0-9]+[.]?[0-9]*$|^-?[.][0-9]+$' = 0 ");


set @stmt = concat(@stmt1, @whereclause, ";");
PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


end proc_main$$

DELIMITER ;

USE `universaltranslatorca`;
DROP procedure IF EXISTS `NumericRange`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `NumericRange`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
SELECT 
    @translatedTable,
    @transactionTable,
    @batchTable,
    @batchIdType,
    @errorTable,
    @translateCol
INTO @translatedTable , @transactionTable , @batchTable , @batchIdType , @errorTable, @translateCol;

call getFinalStatusIds;
SELECT @finalStatusIds INTO @finalStatusIds;

set @startRange = replace(fieldA, 'F', '');
set @endRange = replace(fieldB, 'F', '');

if (length(con1) = 0) then
	set con1 = 0;
end if;

/** make sure start range, end range and con1 ( ) are all numeric **/
		if ( 
		@startRange REGEXP '^[+-]?[0-9]*[.]{0,1}[0-9]*$' = 0 ||
		@endRange REGEXP '^[+-]?[0-9]*[.]{0,1}[0-9]*$' = 0 ||
		con1 REGEXP '^[+-]?[0-9]*[.]{0,1}[0-9]*$' = 0 ||
		length(@startRange) = 0 || length(@endRange) = 0 ||length(@con1) = 0 
		) then

							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'NumericRange Macro - One of these is not a valid value.  Con1 - ",con1,"  or startRange - ",@startRange," or endRange - ",@endRange,". '",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;


leave proc_main;

end if;



	set @whereStmt =  concat("and ",srcField ," is not null and length(",srcField,") > 0 and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");
	

	-- error out all non numeric values transactions
    set @stmt = concat("update  ", @translatedTable , " set forcw = 'MACRO_ERROR' where ",srcField," REGEXP '^[+-]?[0-9]*[.]{0,1}[0-9]*$' = 0 "
    , @whereStmt);
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
      
    /**
    now we compare if value is between startRange and endRange, we insert error if it is not
    now we standardize our output
	output format concat(round(",srcField,", ",con1,"), '') **/
    set @stmt = concat("update  ", @translatedTable , " set forcw ='MACRO_ERROR'
    where ",srcField," not between ",@startRange," and ", @endRange,
    " and (forcw is null or forcw != 'MACRO_ERROR') ", @whereStmt);
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
	
    set @stmt = concat("update  ", @translatedTable , " set ",srcField,"  = concat(round(",srcField,", ",con1,"), '')
    where (forcw is null or forcw != 'MACRO_ERROR') ", @whereStmt);
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
    
    
end proc_main$$

DELIMITER ;


USE `universaltranslatorca`;
DROP procedure IF EXISTS `mergeTransactions`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `mergeTransactions`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


set @con1 = concat('F', con1);
set @con2 = concat('F', con2);


set @stmt = concat("update ",@translatedTable," set forcw = concat_ws('', ",fieldA,", '_', ",fieldB,", '_', ",@con1,");");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;  


set @stmt = concat("update ",@translatedTable," tt 
join  (select group_concat(",@con2,") mser, forcw from ",@translatedTable," group by forcw)  ms on ms.forcw = tt.forcw set ",@con2," =ms.mser;");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt; 


set @stmt = concat("delete table1 from    ",@translatedTable," table1  left join (SELECT id as idsToKeep FROM ",@translatedTable," tt
						INNER JOIN (SELECT forcw, min(id) AS keepId FROM ",@translatedTable,"  GROUP BY forcw) groupedtt 
						ON tt.forcw = groupedtt.forcw  AND tt.id = groupedtt.keepId ) keepIds
                        on keepIds.idsToKeep = table1.id where idsToKeep is null;
                        ");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt; 

end proc_main$$

DELIMITER ;


USE `universaltranslatorca`;
DROP procedure IF EXISTS `applyCWTranslatedList`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `applyCWTranslatedList`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin 

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @listTable, @translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @listTable, @translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

set @whereString = concat(" and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");


set @fcol = replace(lcase(srcField), 'f', '');
set @stmt = concat("truncate table ", @listTable);

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

		set @stmt = concat("
		SELECT max(CHAR_LENGTH(",srcField,") - CHAR_LENGTH( REPLACE ( ",srcField,", ',', '') )  + 1) from ",@translatedTable, " into @maxListLength");
		
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
         
        if (@maxListLength is null) then
			set @maxListLength = 108;
        end if;
       
		set @stmt = concat("
    insert into ", @listTable," (",@batchIdType,", ",@translateCol,", invalue, fcol)
    SELECT ",@batchIdType,", ",@translateCol,", IFNULL(trim(SUBSTRING_INDEX(SUBSTRING_INDEX(t.",srcField,", ',', n.n), ',', -1)),'') value, ",@fcol,"
	FROM ",@translatedTable ," t CROSS JOIN (
    SELECT distinct a.N + b.N * 10 + 1 n FROM  
   (select id N from ref_numbers where id <=",@maxListLength,") a
   ,(select id N from ref_numbers where id <=",@maxListLength,") b
    ORDER BY n) n  WHERE n.n <= 1 + (LENGTH(t.",srcField,") - LENGTH(REPLACE(t.",srcField,", ',', ''))) ", @whereString);
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

    
    set @stmt = concat("update ",@listTable," set invalue = replace(replace(invalue, '\n',''), '\r', '')");
	 
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    
	set @stmt = concat("update ",@listTable," join (select id, sourcevalue, targetvalue from rel_crosswalkdata where crosswalkid = ", con1 ,") cwdata
	on invalue = sourcevalue set translatedvalue = targetvalue where ",@batchIdType," = ", batchId);
  
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
	if (passClear = 1) then
	
		set @stmt = concat("update ",@listTable, " set translatedvalue = invalue where translatedvalue is null ");
		
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
	end if;
  
	set @selDistinct = '';
    
    if (con2 = 'Y') then
		begin
			set @selDistinct = ' distinct ';
        end;
    end if;
  
    set @stmt = concat("update ",@translatedTable," join  (select ",@translateCol," as matchId, 
    group_concat(",@selDistinct," translatedValue order by id) label from  ",@listTable,"
	where ",@batchIdType," = ",batchid, " and fcol = ",@fCol," group by ",@translateCol," ) cwmatch on ",@translateCol," = matchid set ",srcField," = label ");
	   
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    set @colText = "in";
    if (foroutboundProcessing) then
		set @colText = "out";
    end if;
    
    if (passClear = 2) then

		set @stmt = concat("
			insert into transaction",@colText,"macrodroppedvalues_",batchId," (",@batchIdColumn ,", transaction",@colText,"RecordsId, fieldNo, fieldValue, matchId, configId) 
			select distinct ",batchId,", transaction",@colText,"RecordsId, fcol, invalue,concat(",configId,", '_', fcol, '_', invalue), ",configId," from transactiontranslatedlist",@colText,"_",batchId," where translatedValue is null and length(invalue) > 0;
		");
		
		
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
	end if;

	set @stmt = concat("
		insert into transaction",@colText,"macrokeptvalues_",batchId," (",@batchIdColumn ,", transaction",@colText,"RecordsId, fieldNo, fieldValue, matchId, configId) 
		select distinct ",batchId,", transaction",@colText,"RecordsId, fcol, invalue, concat(",configId,", '_', fcol, '_', invalue), ",configId," from transactiontranslatedlist",@colText,"_",batchId," where translatedValue is not null;
	");
 
	PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

    set @stmt = concat("delete from ", @listTable, " where ",@batchIdType," = ",batchId," and fcol = ",@fcol);
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

end proc_main$$

DELIMITER ;

DROP PROCEDURE applyCWTranslatedList;
DROP PROCEDURE applyCWTranslatedListNoTrackDroppedValues;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `applyCWTranslatedList`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin 

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @listTable, @translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @listTable, @translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

set @whereString = concat(" and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");


set @fcol = replace(lcase(srcField), 'f', '');
set @stmt = concat("truncate table ", @listTable);

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

		set @stmt = concat("
		SELECT max(CHAR_LENGTH(",srcField,") - CHAR_LENGTH( REPLACE ( ",srcField,", ',', '') )  + 1) from ",@translatedTable, " into @maxListLength");
		
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
         
        if (@maxListLength is null) then
			set @maxListLength = 108;
        end if;
       
		set @stmt = concat("
    insert into ", @listTable," (",@batchIdType,", ",@translateCol,", invalue, fcol)
    SELECT ",@batchIdType,", ",@translateCol,", IFNULL(trim(SUBSTRING_INDEX(SUBSTRING_INDEX(t.",srcField,", ',', n.n), ',', -1)),'') value, ",@fcol,"
	FROM ",@translatedTable ," t CROSS JOIN (
    SELECT distinct a.N + b.N * 10 + 1 n FROM  
   (select id N from ref_numbers where id <=",@maxListLength,") a
   ,(select id N from ref_numbers where id <=",@maxListLength,") b
    ORDER BY n) n  WHERE n.n <= 1 + (LENGTH(t.",srcField,") - LENGTH(REPLACE(t.",srcField,", ',', ''))) ", @whereString);
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

    
    set @stmt = concat("update ",@listTable," set invalue = replace(replace(invalue, '\n',''), '\r', '')");
	 
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    
	set @stmt = concat("update ",@listTable," join (select id, sourcevalue, targetvalue from rel_crosswalkdata where crosswalkid = ", con1 ,") cwdata
	on invalue = sourcevalue set translatedvalue = targetvalue where ",@batchIdType," = ", batchId);
  
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
	if (passClear = 1) then
	
		set @stmt = concat("update ",@listTable, " set translatedvalue = invalue where translatedvalue is null ");
		
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
	end if;
  
	set @selDistinct = '';
    
    if (con2 = 'Y') then
		begin
			set @selDistinct = ' distinct ';
        end;
    end if;
  
    set @stmt = concat("update ",@translatedTable," join  (select ",@translateCol," as matchId, 
    group_concat(",@selDistinct," translatedValue order by id) label from  ",@listTable,"
	where ",@batchIdType," = ",batchid, " and fcol = ",@fCol," group by ",@translateCol," ) cwmatch on ",@translateCol," = matchid set ",srcField," = label ");
	   
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    set @colText = "in";
    if (foroutboundProcessing) then
		set @colText = "out";
    end if;
    
    if (passClear = 2) then

		set @stmt = concat("
			insert into transaction",@colText,"macrodroppedvalues_",batchId," (",@batchIdColumn ,", transaction",@colText,"RecordsId, fieldNo, fieldValue, matchId, configId) 
			select distinct ",batchId,", transaction",@colText,"RecordsId, fcol, invalue,concat(",configId,", '_', fcol, '_', invalue), ",configId," from transactiontranslatedlist",@colText,"_",batchId," where translatedValue is null and length(invalue) > 0;
		");
		
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
	end if;

	set @stmt = concat("
		insert into transaction",@colText,"macrokeptvalues_",batchId," (",@batchIdColumn ,", transaction",@colText,"RecordsId, fieldNo, fieldValue, matchId, configId) 
		select distinct ",batchId,", transaction",@colText,"RecordsId, fcol, invalue, concat(",configId,", '_', fcol, '_', invalue), ",configId," from transactiontranslatedlist",@colText,"_",batchId," where translatedValue is not null;
	");
 
	PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

    set @stmt = concat("delete from ", @listTable, " where ",@batchIdType," = ",batchId," and fcol = ",@fcol);
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `applyCWTranslatedListNoTrackDroppedValues`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin 

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @listTable, @translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @listTable, @translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

set @whereString = concat(" and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");

set @fcol = replace(lcase(srcField), 'f', '');
set @stmt = concat("truncate table ", @listTable);

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

		set @stmt = concat("
		SELECT max(CHAR_LENGTH(",srcField,") - CHAR_LENGTH( REPLACE ( ",srcField,", ',', '') )  + 1) from ",@translatedTable, " into @maxListLength");
		
        insert into sqlstmts (sqlstmt) values (@stmt);
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
         
        if (@maxListLength is null) then
			set @maxListLength = 108;
        end if;
       
		set @stmt = concat("
    insert into ", @listTable," (",@batchIdType,", ",@translateCol,", invalue, fcol)
    SELECT ",@batchIdType,", ",@translateCol,", IFNULL(trim(SUBSTRING_INDEX(SUBSTRING_INDEX(t.",srcField,", ',', n.n), ',', -1)),'') value, ",@fcol,"
	FROM ",@translatedTable ," t CROSS JOIN (
    SELECT distinct a.N + b.N * 10 + 1 n FROM  
   (select id N from ref_numbers where id <=",@maxListLength,") a
   ,(select id N from ref_numbers where id <=",@maxListLength,") b
    ORDER BY n) n  WHERE n.n <= 1 + (LENGTH(t.",srcField,") - LENGTH(REPLACE(t.",srcField,", ',', ''))) ", @whereString);
    
    insert into sqlstmts (sqlstmt) values (@stmt);
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

    
    set @stmt = concat("update ",@listTable," set invalue = replace(replace(invalue, '\n',''), '\r', '')");
	
    insert into sqlstmts (sqlstmt) values (@stmt);
     
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    set @stmt = concat("update ",@listTable," join (select id, sourcevalue, targetvalue from rel_crosswalkdata where crosswalkid = ", con1 ,") cwdata
	on invalue = sourcevalue set translatedvalue = targetvalue where ",@batchIdType," = ", batchId);
	
    insert into sqlstmts (sqlstmt) values (@stmt);
  
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
	if (passClear = 1) then
	
		set @stmt = concat("update ",@listTable, " set translatedvalue = invalue where translatedvalue is null ");
		
        insert into sqlstmts (sqlstmt) values (@stmt);
		
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
	
    end if;
  
  
  
	set @selDistinct = '';
    
    if (con2 = 'Y') then
		begin
			set @selDistinct = ' distinct ';
        end;
    end if;
  
    set @stmt = concat("update ",@translatedTable," join  (select ",@translateCol," as matchId, 
    group_concat(",@selDistinct," translatedValue order by id) label from  ",@listTable,"
	where ",@batchIdType," = ",batchid, " and fcol = ",@fCol," group by ",@translateCol," ) cwmatch on ",@translateCol," = matchid set ",srcField," = label ");
	
    insert into sqlstmts (sqlstmt) values (@stmt);
       
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    

    set @stmt = concat("delete from ", @listTable, " where ",@batchIdType," = ",batchId," and fcol = ",@fcol);
    
    insert into sqlstmts (sqlstmt) values (@stmt);
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;


end proc_main$$
DELIMITER ;


drop procedure if exists removeDupFromList;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `removeDupFromList`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin 

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @listTable, @translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @listTable, @translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

set @whereString = concat(" and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");


set @fcol = replace(lcase(srcField), 'f', '');
set @stmt = concat("truncate table ", @listTable);

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

		set @stmt = concat("
		SELECT max(CHAR_LENGTH(",srcField,") - CHAR_LENGTH( REPLACE ( ",srcField,", ',', '') )  + 1) from ",@translatedTable, " into @maxListLength");
		
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
         
        if (@maxListLength is null) then
			set @maxListLength = 108;
        end if;
       
		set @stmt = concat("
    insert into ", @listTable," (",@batchIdType,", ",@translateCol,", invalue, fcol)
    SELECT ",@batchIdType,", ",@translateCol,", IFNULL(trim(SUBSTRING_INDEX(SUBSTRING_INDEX(t.",srcField,", ',', n.n), ',', -1)),'') value, ",@fcol,"
	FROM ",@translatedTable ," t CROSS JOIN (
    SELECT distinct a.N + b.N * 10 + 1 n FROM  
   (select id N from ref_numbers where id <=",@maxListLength,") a
   ,(select id N from ref_numbers where id <=",@maxListLength,") b
    ORDER BY n) n  WHERE n.n <= 1 + (LENGTH(t.",srcField,") - LENGTH(REPLACE(t.",srcField,", ',', ''))) ", @whereString);
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

    
    set @stmt = concat("update ",@listTable," set invalue = replace(replace(invalue, '\n',''), '\r', '')");
	 
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
	set @stmt = concat("update ",@listTable, " set translatedvalue = invalue where translatedvalue is null ");
		
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;

	set @selDistinct = ' distinct ';
    
    set @stmt = concat("update ",@translatedTable," join  (select ",@translateCol," as matchId, 
    group_concat(",@selDistinct," translatedValue order by id) label from  ",@listTable,"
	where ",@batchIdType," = ",batchid, " and fcol = ",@fCol," group by ",@translateCol," ) cwmatch on ",@translateCol," = matchid set ",srcField," = label ");
	   
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    set @colText = "in";
    if (foroutboundProcessing) then
		set @colText = "out";
    end if;
    
    set @stmt = concat("
    insert into transaction",@colText,"macrodroppedvalues_",batchId," (",@batchIdColumn ,", transaction",@colText,"RecordsId, fieldNo, fieldValue, matchId, configId) 
	select distinct ",batchId,", t2.transaction",@colText,"RecordsId, fcol, concat((valCount-1), ' count(s) of - ' , t2.translatedValue),
	concat('dupMacro_', t2.transaction",@colText,"RecordsId, '_', t2.translatedValue), ",configId," 
	from transactiontranslatedlistin_",batchId," t1 join (
	select ",batchId,", ",configId," , transaction",@colText,"RecordsId, count(translatedvalue) valCount, translatedvalue from transactiontranslatedlistin_",batchId,"
	where translatedvalue is not null
	group by transaction",@colText,"RecordsId, translatedvalue
	order by count(translatedvalue) desc) t2
	on t1.transactionInrecordsId = t2.transactionInrecordsId
	where valCount > 1");
	
    	PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
	set @stmt = concat("truncate table ", @listTable);
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

end proc_main$$
DELIMITER ;


drop procedure if exists appendStringWithCon1IfLengthMataches;

USE `universaltranslatorca`;
DROP procedure IF EXISTS `appendCon2IfCon1Length`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `appendCon2IfCon1Length`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

set @stmt = concat("update ", @translatedTable," set ",srcField,
" = concat('", con2, "', ", srcField,") where (length(",srcField,") = ",con1,") and ",
"configId = ",configId," and ",@batchIdType," = ",batchId," and statusId not in (",@finalStatusIds,");");


PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

end proc_main$$

DELIMITER ;

USE `universaltranslatorca`;
DROP procedure IF EXISTS `appendCon2IfCon1Length`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `appendCon2IfCon1Length`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

/** con1 must be numeric **/
				if (con1 REGEXP '^[]?[0-9]*[]{0,1}[0-9]*$' = 0 || length(@con1) = 0 ) then

							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'appendCon2IfCon1Length Macro - Con1 - ",con1," must be an integer. '",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;


leave proc_main;

end if;

set @whereClause = '';
if (con1 = 0) then
	set @whereClause = concat(" or ",srcField," is null");
end if;

set @stmt = concat("update ", @translatedTable," set ",srcField,
" = concat_ws('',",srcField,", '", con2, "') where (length(",srcField,") = ",con1,@whereClause,") and ",
"configId = ",configId," and ",@batchIdType," = ",batchId," and statusId not in (",@finalStatusIds,");");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

end proc_main$$

DELIMITER ;

drop procedure IfFALengthNotMatchCon1ReplaceFBWithCon2;



USE `universaltranslatorca`;
DROP procedure IF EXISTS `IfLengthNotCon1ReplaceWithCon2`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `IfLengthNotCon1ReplaceWithCon2`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

/** con1 must be numeric **/
				if (con1 REGEXP '^[]?[0-9]*[]{0,1}[0-9]*$' = 0 || length(@con1) = 0 ) then

							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'IfLengthNotCon1ReplaceWithCon2 Macro - Con1 - ",con1," must be an integer. '",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;


leave proc_main;

end if;

set @whereClause = '';
if (con1 != 0) then
	set @whereClause = concat(" or ", srcField," is null");
end if;

set @stmt = concat(
"update ", @translatedTable," set ",srcField, " = '", con2,"' where (length(",srcField,") != ",con1, @whereClause, ") and 
configId = ",configId," and ",@batchIdType," = ",batchId," and statusId not in (",@finalStatusIds,");");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

end proc_main$$

DELIMITER ;

UPDATE `universaltranslatorca`.`macro_Names` SET `Macro_Name`='If SF Length is not Con 1 Replace With Con 2', `Macro_Short_Name`='IfLengthNotCon1ReplaceWithCon2', `Formula`='IfLengthNotCon1ReplaceWithCon2', `FieldA_Question`='', `FieldB_Question`='', `Con2_Question`='Please enter value to replacement value' WHERE `ID`='147';
UPDATE `universaltranslatorca`.`macro_Names` SET `Macro_Short_Name`='appendCon2IfCon1Length', `Formula`='appendCon2IfCon1Length' WHERE `ID`='128';

USE `universaltranslatorca`;
DROP procedure IF EXISTS `stripCharsFromStartOrEnd`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `stripCharsFromStartOrEnd`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

/** con1 must be numeric **/
				if (con1 REGEXP '^[]?[0-9]*[]{0,1}[0-9]*$' = 0 || length(@con1) = 0 ) then

							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'stripCharsFromStartOrEnd Macro - Con1 - ",con1," must be an integer. '",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;


leave proc_main;

end if;

if (length(con2) = 0) then

	set con2 = 2;

end if;

if (con2 != 1 && con2 != 2 && length(con2) != 1) then

							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'stripCharsFromStartOrEnd Macro - Con2 - ",con2," should be 1 or 2. '",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
leave proc_main;

end if;

		set @stripSQL = concat("substring(",srcField,", ",con1+1,", length(",srcField,"))");
		if (con2 = 2) then 
		set @stripSQL = concat("substring(",srcField,", 1, length(",srcField,")-",con1,")");
		end if;

		set @stmt = concat("update ",@translatedTable, " set ",srcField," = " ,@stripSQL,  " where 
		configId = ",configId," and ",@batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

end proc_main$$

DELIMITER ;

USE `universaltranslatorca`;
DROP procedure IF EXISTS `ifValueNotInListValuesSetToCon2`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `ifValueNotInListValuesSetToCon2`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

/** cwId con1 must be numeric **/
if (con1 REGEXP '^[]?[0-9]*[]{0,1}[0-9]*$' = 0 || length(@con1) = 0 || con1 < 1) then

							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'ifValueNotInListValuesSetToCon2 Macro - Con1 - ",con1," must be an integer greater than 0. '",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;


leave proc_main;

end if;


set @leaveBlanks = "";


set @dropTable = "batchuploaddroppedvalues";
set @colDirection = "in";

if (foroutboundProcessing) then

	set @dropTable = "batchdownloaddroppedvalues";
	set @colDirection = "out";
    
end if;

	set @stmt = concat("select fieldDesc into @fieldName from configurationformfields where configId = ",configId," and fieldNo = replace('",srcField,"', 'F', '') limit 1;");

	PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

	set @stmt1 = concat("
    insert into ",@dropTable,"
    (transaction",@colDirection,"RecordsId, fieldNo, ",@batchIdType ,", configId, fieldName, fieldValue) 
     select transaction",@colDirection,"RecordsId, replace('",srcField,"', 'F', ''), ",@batchIdType,", configId, '",@fieldName,"', ",srcField,"
     from ",@translatedTable," where   ",srcField," is not null and length(",srcField,") != 0 and 
    ",srcField ," not in (select sourcevalue from rel_crosswalkdata where crosswalkId = ",con1,")  ",@leaveBlanks,"
    and  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");
    
	set @stmt = concat("update ",@translatedTable, " set ", srcField, " = '",con2,"' where   ",srcField," is not null and length(",srcField,") != 0 and 
    ",srcField ," not in (select sourcevalue from rel_crosswalkdata where crosswalkId = ",con1,")  ",@leaveBlanks,"
    and  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");
	
	
	PREPARE stmt1 from @stmt1;
	EXECUTE stmt1;
    DEALLOCATE PREPARE stmt1;
   
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;


end proc_main$$

DELIMITER ;

USE `universaltranslatorca`;
DROP procedure IF EXISTS `ifStartsWithCon1UpdateToCon2`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `ifStartsWithCon1UpdateToCon2`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


	set @stmt = concat("update ",@translatedTable, " set ",srcField, " = '", con2, "'    where left(",srcField,", ", length(con1), ") = '",con1,"' ",
				" and  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

end proc_main$$

DELIMITER ;

USE `universaltranslatorca`;
DROP procedure IF EXISTS `AlphaNumericCheck`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `AlphaNumericCheck`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing,batchId);
SELECT 
    @translatedTable,
    @transactionTable,
    @batchTable,
    @batchIdType,
    @errorTable,
    @translateCol
INTO @translatedTable , @transactionTable , @batchTable , @batchIdType , @errorTable, @translateCol;

call getFinalStatusIds;
SELECT @finalStatusIds INTO @finalStatusIds;

set @whereClause  = concat("  (",srcField," REGEXP '^[a-zA-Z0-9]*$' != 1 or ",srcField," REGEXP '^[a-zA-Z0-9]*$' is null)
            and ",srcField," is not null and  length(",srcField,") > 0 and ");
            
set @whereString = concat(@whereClause, "  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");

			set @stmt = concat("update ",@translatedTable," set forCW = 'MACRO_ERROR' where ",@whereString);

			PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;

end proc_main$$

DELIMITER ;


USE `universaltranslatorca`;
DROP procedure IF EXISTS `CheckListLengthIfGTError`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `CheckListLengthIfGTError`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
SELECT 
    @translatedTable,
    @transactionTable,
    @batchTable,
    @batchIdType,
    @errorTable,
    @translateCol
INTO @translatedTable , @transactionTable , @batchTable , @batchIdType , @errorTable, @translateCol;

call getFinalStatusIds;
SELECT @finalStatusIds INTO @finalStatusIds;

/** con1 must be numeric and greater than 1 **/

				if (con1 REGEXP '^[]?[0-9]*[]{0,1}[0-9]*$' = 0 || length(@con1) = 0 || con1 < 1) then

							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'CheckListLengthIfGTError Macro - Con1 - ",con1," must be an integer greater than 0. '",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;


leave proc_main;

end if;

	set @errorCode='52';

	set @whereString = concat("  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");


	set @requiredField = true;
    set @stmt = concat("update ", @translatedTable, " set statusId = 14 where  LENGTH(",srcField,") - LENGTH(REPLACE( ",srcField,", ',', '')) + 1 > ",con1," and ", 
		@whereString);
		
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
     
     
	set @stmt = concat("select fieldDesc into @fieldName from configurationformfields where configId = ",configId," and fieldNo = replace('",srcField,"', 'F', '') limit 1;");

	PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
     
     set @stmt = concat("insert into ", @errorTable , " (" , @batchIdColumn, ", configId, " , @translateCol, 
    ", fieldNo, errorId, macroId, fieldValue, required, fieldLabel, stackTrace) select ",@batchIdType,", configId, id, replace('",srcField,"', 'F', ''), ", @errorCode, 
    ", ",macroId,",",srcField,", ",@requiredField,", '",@fieldName,"', 'CheckListLengthIfGTError - list length is too long. Expecting ", con1,".'  from ", @translatedTable, " where  LENGTH(",srcField,") - LENGTH(REPLACE( ",srcField,", ',', '')) + 1 > ",con1," and ", 
    @whereString);
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    
    
     
end proc_main$$

DELIMITER ;



USE `universaltranslatorca`;
DROP procedure IF EXISTS `KeepTopRanked`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `KeepTopRanked`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin 


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @listTable, @translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @listTable, @translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

/** make sure con1 is numeric **/
/** con1 must be numeric and greater than 1 **/

				if (con1 REGEXP '^[]?[0-9]*[]{0,1}[0-9]*$' = 0 || length(@con1) = 0 || con1 < 1) then

							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'KeepTopRanked Macro - Crosswalk Id - ",con1," must be an integer greater than 0. '",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;


leave proc_main;

end if;

set @stmt = concat("
		SELECT max(CHAR_LENGTH(",srcField,") - CHAR_LENGTH( REPLACE ( ",srcField,", ',', '') )  + 1) from ",@translatedTable, " into @maxListLength");
		
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
         
        if (@maxListLength is null) then
			set @maxListLength = 108;
        end if;


set @whereString = concat(" and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");

set @fcol = replace(lcase(srcField), 'f', '');
set @stmt = concat("truncate table ", @listTable);

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

	set @stmt = concat("
    insert into ", @listTable," (",@batchIdType,", ",@translateCol,", invalue, fcol)
    SELECT ",@batchIdType,", ",@translateCol,", trim(SUBSTRING_INDEX(SUBSTRING_INDEX(t.",srcField,", ',', n.n), ',', -1)) value, ",@fcol,"
    FROM ",@translatedTable ," t CROSS JOIN (
    SELECT a.N + b.N * 10 + 1 n FROM  
   (select id N from ref_numbers where id <= ",@maxListLength,") a
   ,(select id N from ref_numbers where id <= ",@maxListLength,") b
    ORDER BY n) n  WHERE n.n <= 1 + (LENGTH(t.",srcField,") - LENGTH(REPLACE(t.",srcField,", ',', ''))) ", @whereString);
    

    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
     
    -- we delete the single values from top rank look up 
     set @stmt = concat("
		delete t1 from  ", @listTable," t1 join (
	   select t1.",@translateCol," from ", @listTable," t1 join (
	   select count(",@translateCol,") recordCount, ",@translateCol,"
	   from ", @listTable," group by ",@translateCol,"
	   order by recordCount) t2 on 
	   t1.",@translateCol," = t2.",@translateCol,"
	   where recordCount = 1) t2 
	   on t1.",@translateCol," = t2.",@translateCol,";");
   
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
     
	set @stmt = concat("update ",@listTable," set invalue = replace(replace(invalue, '\n',''), '\r', '')");
	 
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    
	set @stmt = concat("update ",@listTable," join (select id, sourcevalue, targetvalue from rel_crosswalkdata where crosswalkid = ", con1 ,") cwdata
	on invalue = sourcevalue set translatedvalue = targetvalue where ",@batchIdType," = ", batchId);
  
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

	set @selDistinct = ' distinct ';
    
    set @stmt = concat("update ",@translatedTable," join  (
	SELECT tt.",@translateCol," as matchId,  invalue label
	FROM ",@listTable," tt
	INNER JOIN
	(SELECT ",@translateCol,", min(CONVERT(translatedValue,UNSIGNED INTEGER) ) AS topRanked
	FROM ",@listTable," 
	where ",@batchIdType," = ",batchid," and fcol = ",@fCol," 
	GROUP BY ",@translateCol," order by ",@translateCol,") groupedtt 
	ON tt.",@translateCol," = groupedtt.",@translateCol," 
	AND tt.translatedValue = groupedtt.topRanked
	where ",@batchIdType," = ",batchid," and fcol = ",@fCol," 
    order by tt.",@translateCol,"
   ) cwmatch on ",@translateCol," = matchid set ",srcField," = label 
   where label is not null
   ");
	
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    
    -- track the topranked value
    
    set @stmt = concat("
	update ",@listTable," t1 join  (
	SELECT tt.id as matchId,  invalue label
	FROM ",@listTable," tt
	INNER JOIN
	(SELECT ",@translateCol,", min(CONVERT(translatedValue,UNSIGNED INTEGER) ) AS topRanked
	FROM ",@listTable," 
	where ",@batchIdType," = ",batchid," and fcol = ",@fCol," 
	GROUP BY ",@translateCol," order by ",@translateCol,") groupedtt 
	ON tt.",@translateCol," = groupedtt.",@translateCol," 
	AND tt.translatedValue = groupedtt.topRanked
	where ",@batchIdType," = ",batchid," and fcol = ",@fCol," 
    order by tt.",@translateCol,"
   ) cwmatch on t1.id = cwmatch.matchId set translateIdToKeep = 1
   where label is not null;");
    
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    
    /** track dropped values **/
    set @colText = "in";
    if (foroutboundProcessing) then
		set @colText = "out";
    end if;
    
	
    set @stmt = concat("
			insert into transaction",@colText,"macrodroppedvalues_",batchId," (",@batchIdColumn ,", transaction",@colText,"RecordsId, fieldNo, fieldValue, matchId, configId) 
			select distinct ",batchId,", transaction",@colText,"RecordsId, fcol, invalue,concat('keepTopRanked_',",configId,", '_', fcol, '_', invalue), ",configId," from transactiontranslatedlist",@colText,"_",batchId," 
            where translateIdToKeep is null;
	");
    
	PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;

    set @stmt = concat("truncate table ", @listTable);
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;


end proc_main$$

DELIMITER ;


USE `universaltranslatorca`;
DROP procedure IF EXISTS `CompareTwoFieldsAndError`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `CompareTwoFieldsAndError`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

/** 
this macro compares SF and FA using con1 operator
Conditional: Compare Two Non-Blank Fields and Insert Error when criteria is not met

**/

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


	/** allowed comparison >, >=, =, <, <=, != **/
      if con1 != '>'  and  con1 != '>='  and con1!='=' and con1 != '<' and con1 != '<=' and con1 != '!=' and con1 != '<>' then
					begin
			
							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'CompareTwoFieldsAndError con1 - ", con1," is not a valid comparison.'",", ",true);
                            
							
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
           
			leave proc_main;
        end;
      end if;


	-- This macro compares non-blank fields
    set @sqlBlanks = concat("  ", fieldA," is not null and ",srcField," is not null 
    and length(", fieldA,") > 0 and length(",srcField,") > 0 
    ");
	
    
    /** MySql doesn't compare integers and decimals well
		we create a temp table and insert those into a table that specifics them as float
    **/
    set @stmt = concat("drop table if exists transactionnumericcompare_", batchId);
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
    
    
    set @stmt = concat("CREATE TABLE transactionnumericcompare_",batchId," (
			  id int(11) NOT NULL AUTO_INCREMENT,
			  transactionId int(11) DEFAULT NULL,
			  compareResult bit(1) NOT NULL DEFAULT b'0',
			  col1Data FLOAT(20,10) DEFAULT NULL,
			  col2Data FLOAT(20,10) DEFAULT NULL,
			  PRIMARY KEY (id),
			  KEY numCompResult (compareResult)
			  ) ENGINE=InnoDB DEFAULT CHARSET=latin1;");
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
    
	/** now we insert the numeric values and compare those **/
    set @stmt = concat("insert into transactionnumericcompare_",batchId," 
    (transactionId, col1Data, col2Data)
    select ",@translateCol,", ",srcField,", ",fieldA," from ", @translatedTable, 
    " where ",srcField, "  REGEXP '^[+-]?[0-9]*[.]{0,1}[0-9]*$' = 1
    and ",fieldA, "  REGEXP '^[+-]?[0-9]*[.]{0,1}[0-9]*$' = 1 
    and length(",srcField, ") > 0 and length(",fieldA, ") > 0 and ",
	@sqlBlanks);
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
	
	/** this way it will compare better **/
    set @stmt = concat("update ",@translatedTable, " join 
	(select col1data ", con1 ," col2data comparedResults , transactionId from transactionnumericcompare_",batchId,") t2
	on transactionId = ",@translateCol,"
	set forCW = case when comparedResults = true then 'compared' else 'MACRO_ERROR' end where", @sqlBlanks);
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
    
		
	 /** we compare and update **/
     set @stmt = concat("update  ",@translatedTable, " t1 join 
		(select ",srcField, " " , con1, " ",fieldA," comparedResults , ",@translateCol," 
		from  ",@translatedTable, " where forCW is null or forCW != 'compared') t2
		on t1.",@translateCol," = t2.",@translateCol,"
		set forCW = case when comparedResults then '' else 'MACRO_ERROR' end where", @sqlBlanks);
	 
     
     PREPARE stmt from @stmt;
     EXECUTE stmt;
     DEALLOCATE PREPARE stmt;

	set @stmt = concat("drop table if exists transactionnumericcompare_", batchId);
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;

end proc_main$$

DELIMITER ;

/** 20200923 **/
USE `universaltranslatorca`;
DROP procedure IF EXISTS `IfFieldsBlankThenError`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `IfFieldsBlankThenError`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
SELECT 
    @translatedTable,
    @transactionTable,
    @batchTable,
    @batchIdType,
    @errorTable,
    @translateCol
INTO @translatedTable , @transactionTable , @batchTable , @batchIdType , @errorTable, @translateCol;

call getFinalStatusIds;
SELECT @finalStatusIds INTO @finalStatusIds;

set @errorCode='51';

	set @whereString = concat("  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");


	set @sqlConstraintS = concat(" (",srcField," is null or length(",srcField,") = 0)");
    set @sqlConstraintA = "";
    set @sqlConstraintB = "";
    set @fieldAName = '';
    set @fieldBName = '';
    
	set @stmt = concat("select fieldDesc into @fieldName from configurationformfields where configId = ",configId," and fieldNo = replace('",srcField,"', 'F', '') limit 1;");

	PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    
    if (fieldA != 'F') then 
		 set @sqlConstraintA = concat(" and  (",fieldA," is null or length(",fieldA,") = 0)");
         set @stmt = concat("select concat(', ', fieldDesc) into @fieldAName from configurationformfields where configId = ",configId," and fieldNo = replace('",fieldA,"', 'F', '') limit 1;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
         
    end if;
    
    if (fieldB != 'F') then 
		 set @sqlConstraintB = concat(" and  (",fieldB," is null or length(",fieldB,") = 0)");
         set @stmt = concat("select concat(', ', fieldDesc) into @fieldBName from configurationformfields where configId = ",configId," and fieldNo = replace('",fieldB,"', 'F', '') limit 1;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
         
    end if;
    
    set @stmt = concat("insert into ", @errorTable , " (" , @batchIdColumn, ", configId, " , @translateCol, 
    ", fieldNo, errorId, macroId, fieldValue, required, fieldLabel, stackTrace) select ",@batchIdType,", configId, id, replace('",srcField,"', 'F', ''), ", @errorCode, 
    ", ",macroId,",'', true, '",@fieldName,"', 'IfFieldsBlankThenError - Field(s) ",@fieldName, @fieldAName, @fieldBName," cannot all be blank.'  
    from ", @translatedTable, "  where",@sqlConstraintS,@sqlConstraintA, @sqlConstraintB, "  and ", 
    @whereString);
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    set @stmt = concat("update ",@translatedTable," set statusId = 14  where",@sqlConstraintS,@sqlConstraintA, @sqlConstraintB, "  and ", 
    @whereString);
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
     
     
end proc_main$$

DELIMITER ;


