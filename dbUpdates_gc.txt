/** 20201015  dropped value error on stage **/


DROP procedure IF EXISTS `populateDroppedValues`;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `populateDroppedValues`(in inConfigId int, in inBatchId int, in foroutboundProcessing boolean)
proc_main:begin

set @dvTableName = "batchuploaddroppedvalues";
set @recordName = "transactioninrecords";
set @batchIdCol = "batchUploadId";
set @colDirection = "in";

if (foroutboundProcessing)  then
		set @dvTableName = "batchdownloaddroppedvalues";
		set @recordName = "transactionoutrecords";
        set @batchIdCol = "batchDownloadId";
        set @colDirection = "out";
end if;

SET @stmt = CONCAT("
delete dropv from transaction",@colDirection,"macrodroppedvalues_",inBatchId," dropv join (
select matchid from transaction",@colDirection,"macrokeptvalues_",inBatchId,") keptv
on keptv.matchId = dropv.matchId;
");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


SET @stmt = CONCAT("
insert into ",@dvTableName ," (",@batchIdCol,", transaction",@colDirection,"recordsId, fieldNo, configId, fieldName, fieldValue)
select distinct ",inBatchId,", t1.transaction",@colDirection,"recordsId, t1.fieldNo, t1.configId, fieldDesc, 
t1.fieldValue from transaction",@colDirection,"macrodroppedvalues_",inBatchId," t1 
join (select * from configurationformfields) t2
on t1.configId = t2.configId
and t1.fieldNo = t2.fieldno;
");



PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


if (foroutboundProcessing) then
	begin
		
         select batchuploadid into @batchUploadId from batchdownloads where id = inBatchId;
        delete from   batchdownloaddroppedvalues where batchuploadId = @batchUploadId;
    
        
        SET @stmt = CONCAT("
			update  batchdownloaddroppedvalues t1 join (select id transactionOutRecordsId, transactionInRecordsId from transactionoutrecords_",inBatchId," 
            ) t2
			on t1.transactionOutRecordsId = t2.transactionOutRecordsId
			set t1.batchuploadId = ",@batchUploadId,",
            t1.transactionInRecordsId = t2.transactionInRecordsId
            where t1.batchdownloadId = ",inBatchId,";
		");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

        
	end;
end if;

SELECT concat('F',rptField1),concat('F',rptField2),concat('F',rptField3),concat('F',rptField4) INTO @rptField1, @rptField2,@rptField3,@rptField4 
FROM configurationmessagespecs where configId = inConfigId LIMIT 1;

if(@rptField1 = 'F0') then 
	set @rptField1 = "F1";
end if;

if(@rptField2 = 'F0') then 
	set @rptField2 = "F2";
end if;

if(@rptField3 = 'F0') then 
	set @rptField3 = "F3";
end if;

if(@rptField4 = 'F0') then 
	set @rptField4 = "F4";
end if;


SET @stmt = CONCAT("
update  ",@dvTableName," t1 join 
(Select transaction",@colDirection,"RecordsId, t1.",@rptField1," rptField1, t1.",@rptField2," rptField2, t1.",@rptField3," rptField3, t1.",@rptField4," rptField4
 from transaction",@colDirection,"records_",inBatchId," t1 join
(select transaction",@colDirection,"RecordsId from transactiontranslated",@colDirection,"_",inBatchId,") t2
on t1.id = t2.transaction",@colDirection,"RecordsId) t2
on t1.",@recordName ,"Id = t2.",@recordName,"Id 
set reportField1Data = rptField1,
reportField2Data = rptField2,
reportField3Data = rptField3,
reportField4Data = rptField4
where t1.",@batchIdCol," = ",inBatchId," and configId = ",inConfigId,";
");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


SET @stmt = CONCAT("
update  ",@dvTableName," t1 join 
(Select transaction",@colDirection,"RecordsId, ",@rptField1," rptField1
from transactiontranslated",@colDirection,"_",inBatchId,") t2
on t1.",@recordName ,"Id = t2.",@recordName,"Id 
set translatedReportField1Data = rptField1 
where t1.",@batchIdCol," = ",inBatchId," and configId = ",inConfigId,";
");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

end proc_main$$

DELIMITER ;


/** 20201015 FP race macro error **/
USE `universaltranslatorca`;
DROP procedure IF EXISTS `PopulateFPRaceIdAndFields`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `PopulateFPRaceIdAndFields`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @listTable, @translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @listTable, @translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;
			
            set @whereString = concat("  where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
			
            
            -- we need to keep original value, store it in forcw first
            set @stmt = concat("
				update ",@translatedTable, " set forcw = ",srcField,";
			");
            
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt; 
            
			set @stmt = concat("
				select length(concat_ws('', F17,F18,F19,F20,F21,F22,F23,F30)) fieldLen from ",@translatedTable, @whereString, " order by fieldLen desc limit 1 into @fieldLen;
			");
            
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
         
    
        if (@fieldLen = 0) then
    
    
		begin
				set @stmt = concat("update ",@translatedTable," set F17 = case when concat(',', ",srcField,", ',') like '%,1,%' then '",con1,"' else '' end",@whereString,";");
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
				set @stmt = concat("update ",@translatedTable," set F18 = case when concat(',', ",srcField,", ',') like '%,2,%' then '",con1,"' else '' end",@whereString,";");
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
                
				set @stmt = concat("update ",@translatedTable," set F19 = case when concat(',', ",srcField,", ',') like '%,3,%' then '",con1,"' else '' end",@whereString,";");
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
                
                set @stmt = concat("update ",@translatedTable," set F20 = case when concat(',', ",srcField,", ',') like '%,4,%' then '",con1,"' else '' end",@whereString,";");
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
                
                set @stmt = concat("update ",@translatedTable," set F21 = case when concat(',', ",srcField,", ',') like '%,5,%' then '",con1,"'  else '' end",@whereString,";");
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
                
                set @stmt = concat("update ",@translatedTable," set F22 = case when concat(',', ",srcField,", ',') like '%,7,%' then '",con1,"'  else '' end",@whereString,";");
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
                
                set @stmt = concat("update ",@translatedTable," set F23 = case when concat(',', ",srcField,", ',') like '%,6,%' then '",con1,"' else '' end",@whereString,";");
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
                
                set @stmt = concat("update ",@translatedTable," set F30 = case when concat(',', ",srcField,", ',') like '%,8,%' then'",con1,"'  else '' end ",@whereString,";");
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
	
    end;
    
    end if;
				
                set @stmt = concat("
				update ",@translatedTable," set ",srcField," =  case 
				when ( length(concat_ws('', F17,F18,F19,F20,F21,F23)) > 1)  and  (length(concat_ws('', F22, F30)) = 0) then 6 
				when (F22 = '",con1,"' and length(concat_ws('', F17,F18,F19,F20,F21, F23, F30)) = 0) then 7
				when (F30 ='",con1,"' and length(concat_ws('', F17,F18,F19,F20, F21, F23, F22)) = 0) then 8
				when (F17 = '",con1,"' and length(concat_ws('', F22,F30)) = 0) then 1  when (F18 = '",con1,"' and length(concat_ws('', F22,F30)) = 0) then 2 
				when (F19 = '",con1,"' and length(concat_ws('', F22,F30)) = 0) then 3 when (F20 = '",con1,"' and length(concat_ws('', F22,F30)) = 0)then 4 
				when (F21 = '",con1,"' and length(concat_ws('', F22,F30)) = 0)then 5 when (F23 = '",con1,"' and length(concat_ws('', F22,F30)) = 0)  then 6
				else '' end ",@whereString,"
			");
            
            
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
            
			   
				-- put back forcw value so it can be passed
                -- track the ids that are changed
                
                set @errorIds = '';
                
                set @stmt = concat("
				select  group_concat(id) from ",@translatedTable, "
                where length(forcw) > 0 and (",srcField," is null or length(",srcField,") = 0)
				into @errorIds");
                
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt; 
                
                if (@errorIds is not null) then 
                
					begin
						set @stmt = concat("
						update ",@translatedTable, " set ",srcField," = forcw
						where id in (",@errorIds,")");
				
						PREPARE stmt from @stmt;
						EXECUTE stmt;
						DEALLOCATE PREPARE stmt; 
						
						set @stmt = concat("
						update ",@translatedTable, " set forcw = 'MACRO_ERROR'
						where id in (",@errorIds,")");
			
						PREPARE stmt from @stmt;
						EXECUTE stmt;
						DEALLOCATE PREPARE stmt; 
					
					end;
                end if;
                
                
end proc_main$$

DELIMITER ;


