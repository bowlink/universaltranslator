/** for Prod **/

DROP TABLE IF EXISTS `macro_names`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `macro_names` (
  `ID` int(11) NOT NULL AUTO_INCREMENT,
  `CategoryId` int(11) DEFAULT '1' COMMENT '1 - data manipulation\n2 - processing',
  `Macro_Name` varchar(100) CHARACTER SET utf8 DEFAULT NULL,
  `Macro_Short_Name` varchar(75) CHARACTER SET utf8 DEFAULT NULL,
  `Ref_Number` int(11) DEFAULT NULL,
  `Date_Display` char(10) DEFAULT NULL,
  `Formula` varchar(255) CHARACTER SET utf8 DEFAULT NULL,
  `Invalid_When` varchar(255) CHARACTER SET utf8 DEFAULT NULL,
  `FieldA_Question` varchar(255) CHARACTER SET utf8 DEFAULT NULL,
  `FieldB_Question` varchar(255) CHARACTER SET utf8 DEFAULT NULL,
  `Con1_Question` varchar(255) CHARACTER SET utf8 DEFAULT NULL,
  `Con2_Question` varchar(255) CHARACTER SET utf8 DEFAULT NULL,
  `populateFieldA` bit(1) DEFAULT b'1',
  `macroDesc` text,
  `errorCondition` varchar(255) DEFAULT NULL,
  `passClearLogic` varchar(255) DEFAULT NULL,
  `droppedValueLogging` varchar(255) DEFAULT NULL,
  `rejectRecordFile` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`ID`)
) ENGINE=InnoDB AUTO_INCREMENT=198 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;


INSERT INTO `macro_names` VALUES (2,1,'IF FA = CON1, SF = CON2','IF FA = CON1, SF = CON2',NULL,NULL,'MatchFAtoCon1UpdateSFtoCon2',NULL,'Please enter the field number to match','','Please enter the constant to match','Please enter the constant to update to','\0','If the field specified in FA matches CON1, insert CON2 into the current field.','This macro does not generate an error under any circumstances.','N/A','N/A','N/A'),(68,1,'YYYY*MM*DD to MM*DD*YYYY','YYYY*MM*DD to MM*DD*YYYY',NULL,NULL,'dateyyyymmddTommddyyyy',NULL,'','','Please enter the date value separator used in the submitted value.  e.g. -, ., /','Please enter the date value separator used in the converted value.  e.g. -, ., /','\0','This macro converts date value in yyyy*mm*dd format to mm*dd*yyyy. Any date value separators may be specified in both the submitted value as well as the converted value.','An error is logged if the date is not in the correct format (yyyy*mm*dd).','If clear is set and an error occurs, clear the current field. If pass is set and an error occurs, do not clear the current field.','N/A','If field is required AND an error occurs, reject record/reject file logic will be applied if active.'),(69,1,'MM*DD*YYYY to YYYY*MM*DD','MM*DD*YYYY to YYYY*MM*DD',NULL,NULL,'datemmddyyyyToyyyymmdd',NULL,'','','Please enter the date value separator used in the submitted value.  e.g. -, ., /','Please enter the date value separator used in the converted value.  e.g. -, ., /','\0','This macro converts date value in mm*dd*yyyy format to yyyy*mm*dd. Any date value separators may be specified in both the submitted value as well as the converted value.','An error is logged if the date is not in the correct format (mm*dd*yyyy).','If clear is set and an error occurs, clear the current field. If pass is set and an error occurs, do not clear the current field.','N/A','If field is required AND an error occurs, reject record/reject file logic will be applied if active.'),(70,1,'Clear SF','Clear SF',NULL,NULL,'ClearSF',NULL,'','','','','\0','Clear the current field','This macro will never generate an error.','N/A','N/A','N/A'),(72,1,'replace Chars In SF string','replace Chars In SF string',NULL,NULL,'replaceCon1CharswithCon2',NULL,'','','Please enter character(s) that you would like to replace','Please enter new character(s).','\0','This macro searches for the CON1 character string in the current field and if found, replaces the character string with the specified character string in CON2.','This macro will never generate an error. If the specified character string is not found, no action is taken.','N/A','N/A','N/A'),(74,1,'concat fields to list','concat fields to list',NULL,NULL,'concatFieldToList',NULL,'','','Please enter the delimiter to be used when concatenating the values.','Please enter field numbers to be concatenated (separate with commas)','\0','Concatenate the values found in the comma separated fields found in CON2. Using the specified delimiter specified in CON1, store the results into the current field.','This macro will never generate an error.','N/A','N/A','N/A'),(75,1,'strip Char At Position X','strip Char At Position X',NULL,NULL,'stripCharAtPos',NULL,'','','Please enter the position of the character to drop within the string','Please enter the character to drop (optional)','\0','Drop a character from the specified location in the character string. A specific character may be used (optional). If a specific character is used, and that character is not found, the character found is not dropped. If no character is specified, whatever character is found will be dropped. Only one character may be specified.','This macro will never generate an error.','N/A','N/A','N/A'),(76,1,'replace blanks with chars','replace blanks with chars',NULL,NULL,'replaceBlanksWithChars',NULL,'','','Please enter the value to insert if the field is blank.','','\0','This macro will insert the specified value into the current field but only if the current field is blank or null.','This macro will never generate an error.','N/A','N/A','N/A'),(80,1,'Strip Leading Chars','Strip Leading Chars',NULL,NULL,'stripLeadingChars',NULL,'','','Please enter leading character(s) to remove','','\0','This macro will strip characters specified by the user from the leading edge of the current field. If characters are not found, no action is taken.','This macro will never generate an error.','N/A','N/A','N/A'),(81,1,'Strip trailing Chars','Strip trailing Chars',NULL,NULL,'stripTrailingChars',NULL,'','','Please enter trailing character(s) to remove','','\0','This macro will strip characters specified by the user from the trailing edge of the current field. If characters are not found, no action is taken.','This macro will never generate an error.','N/A','N/A','N/A'),(86,1,'Update Field','Update Field',NULL,NULL,'overwriteSF',NULL,'','','Please enter the new value to be stored in the current field.','','\0','This macro replaces the value stored in the current field with the specified value.','This macro will never generate an error.','N/A','N/A','N/A'),(87,1,'Copy Field','Copy Field',NULL,NULL,'copyField',NULL,'','Please enter the field number of the field to be copied into the current field.','','','\0','This macro copies the value from the specified field and stores that value in the current field.','This macro will never generate an error.','N/A','N/A','N/A'),(89,1,'Insert Random Number','Insert Random Number',NULL,NULL,'overwriteSFWithRandomNumber',NULL,'','','','','\0','This macro inserts a random number into the current field.','This macro will never generate an error.','N/A','N/A','N/A'),(93,1,'Check Min Length And Replace','Check Min Length And Replace',NULL,NULL,'CheckLengthAndReplace',NULL,'','','Please enter minimum string length','Please enter the value to insert if string length is >= CON1','\0','This macro checks the length of the value in the current field. If the length is >= CON1, the value specified in CON2 will be inserted. If the length is < CON1, no action is taken.','This macro will never generate an error.','N/A','N/A','N/A'),(94,1,'Substring to Another Field','Substring to Another Field',NULL,NULL,'substringToAnotherField',NULL,'Please enter field number to be updated','','Please enter starting position of string to be extracted','Please enter how many characters to extract','\0','This macro copies a substring from the current field and stores that value in the specified field. If the string position or length of string conditions are not met, the field is not updated.','This macro will never generate an error.','N/A','N/A','N/A'),(99,1,'If SRCF=CON1, Copy FB to FA','If SRCF=CON1, Copy FB to FA',NULL,NULL,'IfSFMatchCon1SetFAtoFB',NULL,'Please enter field number to be updated','Please enter field number to copy to FA','Please enter value to match to SF','','\0','This macro checks the current field for a specified value. If a match is found, the value in field B is copied to field A.','This macro will never generate an error.','N/A','N/A','N/A'),(102,1,'Prepend Append String','Prepend Append String',NULL,NULL,'appendPrependString',NULL,'Please enter value you would like to prepend','Prepend if the field is blank (Y/N).','Please enter value you would like to append','Append if the field is blank (Y/N).','\0','This macro adds a string to the beginning and/or end of the value in the current field. The user has the option of prepending/appending (or choosing not to)\nif the field is blank.','This macro will never generate an error.','N/A','N/A','N/A'),(103,1,'Min Age Insert Error','Min Age Insert Error',NULL,NULL,'yearDiffinsertError',NULL,'Please enter the field number of the field that the current field (typically DOB) will be compared to (e.g. visit date\'s column number)','','Please enter the minimum age before rejecting','','\0','This macro will compare the DATE1 value (yyyy-mm-dd format required) in the current field with the DATE2 value in FA (yyyy-mm-dd format required) in order to calculate time difference in years. If the time difference is below the minimim value specified in CON1, an error is generated.','An error is generated if the calculated time difference is below the minimum value specified. If one or both date fields are not in the correct format, an error is generated.','If clear is set and an error occurs, clear the current field. If pass is set and an error occurs, do not clear the current field.','N/A','If field is required AND an error occurs, reject record/reject file logic will be applied if active.'),(104,1,'past Date Check','past Date Check',NULL,NULL,'pastDateCheck',NULL,'','','Please enter number of months','','\0','This macro will reject a record where the specified field has a date value that is older than CON1 months relative to the current date. The date field must be in yyyy-mm-dd format.','An error is generated when the date value specified is older than the number of months specified in CON1.\n\nIf the date value is not in the correct format, an error will be generated.','If clear is set and an error occurs, clear the current field. If pass is set and an error occurs, do not clear the current field.','N/A','If field is required AND an error occurs, reject record/reject file logic will be applied if active.'),(108,1,'If SRCF BLANK and FA = CON1, SRCF=CON2 ','If SRCF BLANK and FA = CON1, SRCF=CON2 ',NULL,NULL,'IfFACon1AndSFBlankSetSFToCon2',NULL,'Please enter field to check with CON1','','Please enter the value to check for in field A','Please enter value to set current field to if blank','\0','This macro will update the current field with CON2 if the current field is blank but only if the specified field (field A) matches the value specified in CON1.','This macro will never generate an error.','N/A','N/A','N/A'),(109,1,'IF SF = CON1, SF = CON2 else clear SF.','IF SF = CON1, SF = CON2 else clear SF.',NULL,NULL,'ifSFMatchCon1ThenCon2ElseClear',NULL,'','','Please enter value to match for SF','Please enter value to update SF to','\0','This macro will update the current field with CON2 if the current field = CON1 but will clear the current field if the current field <> CON1.','This macro will never generate an error.','N/A','N/A','N/A'),(112,1,'string To Date','string To Date',NULL,NULL,'stringToDate',NULL,'','','Please enter the inbound string\'s date format','Please enter the outbound string\'s date format','\0','This macro will convert the specified inbound date format to the specified outbound date format. Please follow this link for more details…\nhttps://www.w3schools.com/sql/func_mysql_date_format.asp','An error is generated when the format of the inbound date value doesn\'t match the format specified by the user.','If clear is set and an error occurs, clear the current field. If pass is set and an error occurs, do not clear the current field.','N/A','If field is required AND an error occurs, reject record/reject file logic will be applied if active.'),(113,1,'Zip Code Check','Zip Code Check',NULL,NULL,'ZipCodeCheck',NULL,'','','Optional - Please enter a default (e.g. 00000) for invalid (alphanumeric) zip codes','','\0','This macro performs the following steps: Remove dashes from values. Zip code length over 5 digits will be truncated to 5. Numeric values shorter than 5 digits will be prepended with 0s (e.g. 345 becomes 00345). A default value may be inserted (optional) for any invalid (alphanumeric) zip codes.','An error will be generated if an alphanumeric value is found but the option to replace with a default value has not been activated.','If clear is set and an error occurs, clear the current field. If pass is set and an error occurs, do not clear the current field.','N/A','If field is required AND an error occurs, reject record/reject file logic will be applied if active.'),(115,1,'If SF Blank AND FA = CON1 then ERROR','If SF Blank AND FA = CON1 then ERROR',NULL,NULL,'IfFieldACon1andSFBlankInsertError',NULL,'Please enter field to match value to','','Please enter value to be checked in FA','','\0','This macro will check FA for a specified value (CON1). If there is a match AND the SRCF is blank, log an error.This macro is typically used in family planning to check if the IFNOMETHOD field is populated when the contra metho field = NO METHOD.','This macro will generate an error if the check condition is met.','If clear is set and an error occurs, clear the current field. If pass is set and an error occurs, do not clear the current field.','N/A','If field is required AND an error occurs, reject record/reject file logic will be applied if active.'),(128,1,'append Con2 If SF Length = Con1','append Con2 If SF Length = Con1',NULL,NULL,'appendCon2IfCon1Length',NULL,'','','Please enter length of string','Please enter value to append','\0','These macro appends the specified string (CON2) to the current field value if the current field value matches the length specified (CON1). ','This macro will never generate an error.','N/A','N/A','N/A'),(129,1,'Apply CW to List','Apply CW to List',NULL,NULL,'applyCWTranslatedList',NULL,' ',' ','Please select a crosswalk','Enter Y to remove duplicate value in the list; blank will keep duplicates.','\0','This macro applies a crosswalk to the current field where the values in the current field are in a comma delimited list. If values in the field are found in the crosswalk, they are translated. User has the option to remove duplicate values (or not).','This macro will never generate an error.','N/A','N/A','N/A'),(131,1,'If SF is empty, copy FA to SF','If SF is empty, copy FA to SF',NULL,NULL,'IfSFBlankSetToFA',NULL,'Please enter field to copy from','','','','\0','This macro will copy the value found in FA to SF if SF is emplty.','This macro will never generate an error.','N/A','N/A','N/A'),(146,1,'Compare Two Fields And Error','Compare Two Fields And Error',NULL,NULL,'CompareTwoFieldsAndError',NULL,'Pleae enter field to compare source field to','','Please enter how to compare.  Options include <,<=,>,>=,=,<>,!=',' ','\0','This macro will compare two field values using the specified arithmetic operator (<,<=,>,>=,<>,!=). If the result of the compare is FALSE, an error is generated.','This macro will generate an error if the compare logic is FALSE.','If clear is set and an error occurs, clear the current field. If pass is set and an error occurs, do not clear the current field.','N/A','If field is required AND an error occurs, reject record/reject file logic will be applied if active.'),(147,1,'If SF Length <> Con1, SF = CON2','If SF Length <> Con1, SF = CON2',NULL,NULL,'IfLengthNotCon1ReplaceWithCon2',NULL,'','','Please enter SF string length','Please enter replacement value','\0','This macro will compare the string length in the current field to CON1 and if a match occurs, will copy CON2 to SF.','This macro will never generate an error.','N/A','N/A','N/A'),(148,1,'IF SF <> CON1, then Clear SF','IF SF <> CON1, then Clear SF',NULL,NULL,'ifSFNotCon1ThenClear',NULL,'','','Please enter value to match','','\0','This macro will check for the CON1 value in the current field. If not found, the current field will be cleared.','This macro will never generate an error.','N/A','N/A','N/A'),(150,1,'if Not Blank Error','if Not Blank Error',NULL,NULL,'ifNotBlankError',NULL,'','','','','\0','This macro inspects the value in the current field and will generate an error if the current field is not blank.','This macro will generate an error if the field is not blank.','If clear is set and an error occurs, clear the current field. If pass is set and an error occurs, do not clear the current field.','N/A','If field is required AND an error occurs, reject record/reject file logic will be applied if active.'),(152,0,'clear Other Month Transactions','clear Other Month Transactions',NULL,NULL,'errorNonYearMonthTransactions',NULL,'','','','','\0','This macro will review date values in the current field (must be in yyyy-mm-dd format) and will count records by month. The month with the most records will be flagged. All records with dates in the flagged month will be kept. All records with other months will be rejected. If two or more months tie for the high record count, an error will be generated.','This macro will never generate an error.','N/A','N/A','N/A'),(156,1,'strip Chars From Start Or End','strip Chars From Start Or End',NULL,NULL,'stripCharsFromStartOrEnd',NULL,'','','Please enter number of characters to strip','Please enter 1 to strip from beginning, 2 for strip from end','\0','This macro will strip leading or trailing characters (any characters found) from the value stored in the current field.','This macro will never generate an error.','N/A','N/A','N/A'),(160,1,'if SF Not in CW, SF = CON2','if SF Not in CW, SF = CON2',NULL,NULL,'ifValueNotInListValuesSetToCon2',NULL,'','','Please select a crosswalk','Please enter value to update to','\0','This macro checks to see if the current field value (single values only - no comma separated lists) is found in the source values of the specified crosswalk. If yes, no action is taken. If no, replace the current field value with CON2. NOTE: The crosswalk translation is not applied with this macro.','This macro will never generate an error.','N/A','If the current field value is not found, it is logged as a dropped value before being overwritten with CON2.','N/A'),(161,1,'if SF substring = CON1, SF = CON2','if SF substring = CON1, SF = CON2',NULL,NULL,'ifStartsWithCon1UpdateToCon2',NULL,'','','Please enter starting characters to check','Please enter replacement value','\0','This macro will check to see if the value specified in CON1 is found at the start of the current field and if true, replace current field with CON2.','This macro will never generate an error.','N/A','N/A','N/A'),(165,1,'AlphaNumeric Check','AlphaNumeric Check',NULL,NULL,'AlphaNumericCheck',NULL,'','','','','\0','This macro will check to see that the value in the current field only contains alphanumeric characters. No special characters are allowed.','The macro will generate an error if special characters are found.','If clear is set and an error occurs, clear the current field. If pass is set and an error occurs, do not clear the current field.','N/A','If field is required AND an error occurs, reject record/reject file logic will be applied if active.'),(166,1,'reject Future Date','reject Future Date',NULL,NULL,'futureDateCheck',NULL,'','','','','\0','This macro will compare the date value in the current field (must be in yyyy-mm-dd format) and if it is a future date relative to the current date, will reject the record.','This macro will generate an error if the date is a future date relative to the current date.','Pass/clear logic does not apply. If an error occurs, the record is rejected.','','Reject record/reject file logic does not apply. If an error occurs, the record is rejected.'),(167,1,'If SF <> NUM, SF = CON1','If SF <> NUM, SF = CON1',NULL,NULL,'ifNotNumericSetToCon1',NULL,'','','Please enter replacement value','','\0','This macro will check to see if the value in the current field is numeric and if not, will insert CON1 value into the current field.','This macro will never generate an error.','N/A','If the value is not numeric, log the value as a dropped value and update current field to CON1.','N/A'),(169,1,'SF = SF (+,-,*,/) CON1','SF = SF (+,-,*,/) CON1',NULL,NULL,'ArithmeticConstant',NULL,'How many decimal places. (Defaults to 0 if left blank)','','Please enter the constant value','Please enter arithmetic operation ( + - / or *)','\0','This macro uses the specified arithmetic operator in CON2 and the value specified in CON1 to update the value stored in the current field.','This macro will generate an error if the current field contains blank or a numeric value.','If clear is set and an error occurs, clear the current field. If pass is set and an error occurs, do not clear the current field.','N/A','If field is required AND an error occurs, reject record/reject file logic will be applied if active.'),(172,1,'If List Length GT, Log Error','If List Length GT, Log Error',NULL,NULL,'CheckListLengthIfGTError',NULL,'','','Please enter the max number of elements expected in the list','','\0','This macro will count the number of values in the current field and if the count > CON1, log an error. The values in the field must be comma separated.','This macro will generate an error if the count of values in the current field > CON1.','If clear is set and an error occurs, clear the current field. If pass is set and an error occurs, do not clear the current field.','N/A','If field is required AND an error occurs, reject record/reject file logic will be applied if active.'),(173,1,'If Fields Blank Then Error','If Fields Blank Then Error',NULL,NULL,'IfFieldsBlankThenError',NULL,'Please enter second field number to check (optional)','Please enter third field number to check (optional)','','','\0','This macro will check up to three fields (current field, FA, FB) and if the specifiied fields are all blank, log an error.','This macro will generate an error if the specifiied fields are all blank.','N/A - Macro is checking for blanks.','N/A','If field is required AND an error occurs, reject record/reject file logic will be applied if active.'),(174,1,'Populate FP RaceId And Fields','Populate FP RaceId And Fields',NULL,NULL,'PopulateFPRaceIdAndFields',NULL,'','','','','\0','This macro is specifically used for family planning. This macro manages how individual race fields (white, black, asian, etc.) and the raceID field are populated. This macro is only used in the target configuration. First, the macro looks to see if individual race fields are in use (at least one must contain Y).\nIf no individual race fields are populated, the macro will use the raceId(s) in the current field to populate the individual race fields NOTE: if multiple raceIDs are used, they must be comma separated.\nExample... If individual race fields are in use, the macro will populate the current field (the single race field) after assessing the contents of the individual race fields. If it finds that individual race fields are not in use, the macro will look at what is in the current field and populate the individual race fields accordingly. For example, if the current field value is \"1,2\", the macro will set individual race field white to Y and individual race field black to Y. The single race field will then be set to 6 (more than one race). For this macro to work correctly, the current field must be blank (indicating that individual race fields are in use) OR it must be populated with legitimate race values (1=white, 2=black, 3=native american, 4=asian, 5=hawaiian, 6=multiracial, 7=unknown, 8=refused to state).','This macro will generate an error if all fields are blank.','If clear is set and an error occurs, clear the current field. If pass is set and an error occurs, do not clear the current field.','N/A','If field is required AND an error occurs, reject record/reject file logic will be applied if active.'),(177,1,'Keep Top Ranked','Keep Top Ranked',NULL,NULL,'KeepTopRanked',NULL,'','','Please select the crosswalk that contains the rank list','','\0','This macro takes a list of values (must be comma separated) found in the current field and only keeps the top matching value (top ranked value). Other values in the field that are found in the crosswalk are dropped. Other values in the field that are not in the crosswalk are ignored. Values in the field musts be comma separated.\n\nThe top rank list is a crosswalk.\nThe order we want to keep is in the second value. In the example below, the submitted value of \"\"5\"\" is the top ranked value.\n\n\nSource Value|Priority|Description Value\n1|5|Office Visit, Focused - New Patient - 99201\n2|4|Office Visit, Focused Expanded - New Patient - 99202\n3|3|Office Visit, Limited Complex - New Patient - 99203\n4|2|Office Visit, Moderate Complex - New Patient - 99204\n5|1|Office Visit, High Complex - New Patient - 99205\n6|10|Office Visit, Focused - Est. Patient - 99211','This macro will never generate an error.','N/A','Values that are not top ranked AND are in the top ranked crosswalk will be dropped and logged for audit report review. Values that are not in the top ranked crosswalk will not be dropped.','N/A'),(178,1,'Remove Duplicates','Remove Duplicates',NULL,NULL,'removeDupFromList',NULL,'','','','','\0','This macro will remove duplicate values from the list of values in the current field. The lists of values must be comma separated.','This macro will never generate an error.','N/A','N/A','N/A'),(179,1,'Merge Records','Merge Records',NULL,NULL,'mergeTransactions',NULL,'Please enter the field number for site ID','Please enter the field number for Client Identifier (MRN)','Please enter the field number for visit date','Please enter the field number of the field to be merged (typically med svcs)','\0','This macro is typically used for family planning where the customer submits one record for each ICD/CPT code in a visit, resulting in multiple records in the submission for a single patient visit. This macro will merge records with the same site ID, patient ID and visit date. Medical services from all matched records will be stored in the first record and only the first matched record will be saved. This macro does not generate errors.','This macro will never generate an error.','N/A','N/A','N/A'),(180,1,'prepend Con2 If SF length = Con1','prepend Con2 If SF length = Con1',NULL,NULL,'prependCon2IfCon1Length',NULL,'','','Please enter length of string','Please enter value to prepend','\0','This macro prepends CON2 to the value in the current field if the value in the current field matches the length specified in CON1.','This macro will never generate an error.','N/A','N/A','N/A'),(181,1,'Combine Values In Multiple Records','Combine Values In Multiple Records',NULL,NULL,'mergeValues',NULL,'Please enter the field number for Site Id','Please enter the field number for Client Identifier','Please enter the field number for visit date','Please enter the field number to be merged','\0','This macro copies values found in the current field (usually the icd codes column) for all records with the same site/client Identifier/visit date combination. For example, if Patient A, Site 123, Visit Date 1/1/2020 has two entries, one with ICD codes X, Y and Z and a second record with with ICD codes A, B and C, both entries will be updated to contain X,Y,Z,A,B,C. This macro is typically used just before the MERGE macro which removes duplicate records from a submission. This macro ensures that ICD codes are not lost while the MERGE macro removes duplicate records afer ensuring that MEDSVCS codes are not lost.','This macro will never generate an error.','N/A','N/A','N/A'),(183,1,'Convert Date mmddyyyy to yyyymmdd','Convert Date mmddyyyy to yyyymmdd',NULL,NULL,'datemmddyyyyToyyyymmdd',NULL,'','','','','\0','This macro will convert a date value in mmddyyyy format to yyyymmdd format.',' If the date format is invalid, an error will be logged.','If clear is set and an error occurs, clear the current field. If pass is set and an error occurs, do not clear the current field.','N/A','If field is required AND an error occurs, reject record/reject file logic will be applied if active.'),(184,1,'Convert Date dd-Mon-YY to yyyymmdd','Convert Date dd-Mon-YY to yyyymmdd',NULL,NULL,'dateddmonyyWithDashesToyyyymmdd',NULL,'','','','','\0','This macro will convert a date value in dd-mon-yy format to yyyymmdd format. ','If the date format is invalid, an error will be logged. ','If clear is set and an error occurs, clear the current field. If pass is set and an error occurs, do not clear the current field.','N/A','If field is required AND an error occurs, reject record/reject file logic will be applied if active.'),(185,1,'Convert Date mm/dd/yyyy to yyyymmdd','Convert Date mm/dd/yyyy to yyyymmdd',NULL,NULL,'datemmddyyyyWithSlashesToyyyymmdd',NULL,'','','','','\0','This macro will convert a date value in mm/dd/yyyy format to yyyymmdd format.','If the date format is invalid, an error will be logged. ','If clear is set and an error occurs, clear the current field. If pass is set and an error occurs, do not clear the current field.','N/A','If field is required AND an error occurs, reject record/reject file logic will be applied if active.'),(186,1,'Convert Date m/dd/yyyy to yyyymmdd','Convert Date m/dd/yyyy to yyyymmdd',NULL,NULL,'datemddyyyyWithSlashesToyyyymmdd',NULL,'','','','','\0','This macro will convert a date value in m/dd/yyyy format to yyyymmdd format.','If the date format is invalid, an error will be logged. ','If clear is set and an error occurs, clear the current field. If pass is set and an error occurs, do not clear the current field.','N/A','If field is required AND an error occurs, reject record/reject file logic will be applied if active.'),(187,1,'Convert Date mm/d/yyyy to yyyymmdd','Convert Date mm/d/yyyy to yyyymmdd',NULL,NULL,'datemmdyyyyWithSlashesToyyyymmdd',NULL,'','','','','\0','This macro will convert a date value in mm/d/yyyy format to yyyymmdd format.','If the date format is invalid, an error will be logged. ','If clear is set and an error occurs, clear the current field. If pass is set and an error occurs, do not clear the current field.','N/A','If field is required AND an error occurs, reject record/reject file logic will be applied if active.'),(188,1,'Convert Date m/d/yyyy to yyyymmdd','Convert Date m/d/yyyy to yyyymmdd',NULL,NULL,'datemdyyyyWithSlashesToyyyymmdd',NULL,'','','','','\0','This macro will convert a date value in m/d/yyyy format to yyyymmdd format. ','If the date format is invalid, an error will be logged. ','If clear is set and an error occurs, clear the current field. If pass is set and an error occurs, do not clear the current field.','N/A','If field is required AND an error occurs, reject record/reject file logic will be applied if active.'),(189,1,'Convert Date yyyy-mm-dd to yyyymmdd','Convert Date yyyy-mm-dd to yyyymmdd',NULL,NULL,'dateyyyymmddWithDashesToyyyymmdd',NULL,'','','','','\0','This macro will convert a date value in yyyy-mm-dd format to yyyymmdd format. ','If the date format is invalid, an error will be logged. ','If clear is set and an error occurs, clear the current field. If pass is set and an error occurs, do not clear the current field.','N/A','If field is required AND an error occurs, reject record/reject file logic will be applied if active.'),(190,1,'Convert Date mddyyyy to yyyymmdd','Convert Date mddyyyy to yyyymmdd',NULL,NULL,'datemddyyyyToyyyymmdd',NULL,'','','','','\0','This macro will convert a date value in mddyyyy format to yyyymmdd format.','If the date format is invalid, an error will be logged. ','If clear is set and an error occurs, clear the current field. If pass is set and an error occurs, do not clear the current field.','N/A','If field is required AND an error occurs, reject record/reject file logic will be applied if active.'),(191,1,'Convert Date mm/dd/yy to yyyymmdd','Convert Date mm/dd/yy to yyyymmdd',NULL,NULL,'datemmddyyWithSlashesToyyyymmdd',NULL,'','','','','\0','This macro will convert a date value in mm/dd/yy format to yyyymmdd format. ','If the date format is invalid, an error will be logged. ','If clear is set and an error occurs, clear the current field. If pass is set and an error occurs, do not clear the current field.','N/A','If field is required AND an error occurs, reject record/reject file logic will be applied if active.'),(192,1,'Convert Date m/d/yy to yyyymmdd','Convert Date m/d/yy to yyyymmdd',NULL,NULL,'datedmyyWithSlashesToyyyymmdd',NULL,'','','','','\0','This macro will convert a date value in m/d/yy format to yyyymmdd format. ','If the date format is invalid, an error will be logged. ','If clear is set and an error occurs, clear the current field. If pass is set and an error occurs, do not clear the current field.','N/A','If field is required AND an error occurs, reject record/reject file logic will be applied if active.'),(193,1,'Error Invalid Date','Error Invalid Date',NULL,NULL,'CheckInvalidDateAndError',NULL,'','','Please enter current date format (e.g. %Y%m%d for yyyymmdd)','','\0','This macro checks the field for a valid date.\nUser will enter in the format of the date using corresponding MySQL format. For example, dates in yyyymmdd format will be %Y%m%d. Below are the acceptable formats\n%c - (m) Numeric month name (0 to 12)\n%d - (dd) Day of the month as a numeric value (01 to 31)\n%e - (d) Day of the month as a numeric value (0 to 31)\n%M - (month) Month name in full (January to December)\n%m - (mon) Month name as a numeric value (00 to 12)\n%Y - (yyyy) Year as a numeric, 4-digit value%y - (yy) Year as a numeric, 2-digit value','If the date format is invalid, an error will be logged. ','If clear is set and an error occurs, clear the current field. If pass is set and an error occurs, do not clear the current field.','N/A','If field is required AND an error occurs, reject record/reject file logic will be applied if active.'),(194,1,'Numeric Range','Numeric Range',NULL,NULL,'NumericRange',NULL,'','Please enter start range','Please enter end range','','\0','This macro will verify that a field is numeric and that the value falls within the specified numeric range.',' If the field is not numeric or does not fall within the specified range, an error will be logged. ','If clear is set and an error occurs, clear the current field. If pass is set and an error occurs, do not clear the current field.','N/A','If field is required AND an error occurs, reject record/reject file logic will be applied if active.'),(195,1,'Apply CW to List without Tracking Dropped Values','Apply CW to List without Tracking Dropped Values',NULL,NULL,'applyCWTranslatedListNoTrackDroppedValues',NULL,'','','Please select the crosswalk to be used.','Enter Y to remove duplicates; Leave blank to keep duplicates.','\0','This macro applies a crosswalk to the current field where the values are in a comma delimited list. If values are found in the crosswalk, they are translated. User has the option to remove duplicate values (or not). This macro does not track dropped values.','This macro will never generate an error.','N/A','N/A','N/A'),(196,1,'reg Ex Check','reg Ex Check',NULL,NULL,'regExCheck',NULL,'','','Please enter the regular expression','','\0','This is for advanced users.\nUser must know Regular expressions to use this. This macro will check for specific character types in the string and error if conditions are not met. For example, if a program wants to accept 0-9, a-z, \"-\" and \".\" in their patient number, all I have to do is enter a-zA-Z0-9-\\. (\\ is used to escape .) See this link for details - https://dev.mysql.com/doc/refman/5.6/en/regexp.html','This macro will generate an error if other than specified characters are found.','If clear is set and an error occurs, clear the current field. If pass is set and an error occurs, do not clear the current field.','N/A','If field is required AND an error occurs, reject record/reject file logic will be applied if active.'),(197,1,'If SF compares to FA, SF = Con2','If SF compares to FA, SF = Con2',NULL,NULL,'CompareTwoFieldsAndUpdateSF',NULL,'Please enter field to compare source field to',' ','Please enter comparison (< , <=, =, >, >=, !=, <>)','Please enter value to update SF to','\0','This macro will perform an arithmetic operation (<,>,<=,>=,=,<>) on the current field and FA. If the operation is true, the current field will be updated to CON2.','This macro will never generate an error.','N/A','N/A','N/A');



/** SPs **/
DROP PROCEDURE if exists  `universaltranslator`.`addCharToString`;
DROP PROCEDURE if exists  `universaltranslator`.`addDelimiterEvery2Characters`;
DROP PROCEDURE if exists  `universaltranslator`.`AlphaNumericCheck`;
DROP PROCEDURE if exists  `universaltranslator`.`AlphaNumericCheck_20200422`;
DROP PROCEDURE if exists  `universaltranslator`.`appendPrependString`;
DROP PROCEDURE if exists  `universaltranslator`.`appendPrependStringIfNotBlank`;
DROP PROCEDURE if exists  `universaltranslator`.`appendStringWithCon1IfLengthMataches`;
DROP PROCEDURE if exists  `universaltranslator`.`applyCW`;
DROP PROCEDURE if exists  `universaltranslator`.`applyCWTranslatedList`;
DROP PROCEDURE if exists  `universaltranslator`.`applyCWTranslatedListNoTrackDroppedValues`;
DROP PROCEDURE if exists  `universaltranslator`.`ArithmeticConstant`;
DROP PROCEDURE if exists  `universaltranslator`.`ArithmeticConstantStoreInFA`;
DROP PROCEDURE if exists  `universaltranslator`.`ArithmeticForSFAndFAUpdateFB`;
DROP PROCEDURE if exists  `universaltranslator`.`BHCounseling`;
DROP PROCEDURE if exists  `universaltranslator`.`BHMedServices`;
DROP PROCEDURE if exists  `universaltranslator`.`cat2ApplyCW`;
DROP PROCEDURE if exists  `universaltranslator`.`cat2ApplyCWForTransactionInRecords`;
DROP PROCEDURE if exists  `universaltranslator`.`cat2ApplyCWTranslatedList`;
DROP PROCEDURE if exists  `universaltranslator`.`cat2CleanListTable`;
DROP PROCEDURE if exists  `universaltranslator`.`cat2Concat2ColsDelimNoSpaces`;
DROP PROCEDURE if exists  `universaltranslator`.`cat2Concat3ColsDelimNoSpaces`;
DROP PROCEDURE if exists  `universaltranslator`.`cat2CopyColumnIn`;
DROP PROCEDURE if exists  `universaltranslator`.`cat2DelTransWhenFieldAIsNull`;
DROP PROCEDURE if exists  `universaltranslator`.`cat2PopulateTranslatedList`;
DROP PROCEDURE if exists  `universaltranslator`.`cat2StripLeadingChars`;
DROP PROCEDURE if exists  `universaltranslator`.`cat2StripLeadingCharsTTI`;
DROP PROCEDURE if exists  `universaltranslator`.`cat2UpdateListValue`;
DROP PROCEDURE if exists  `universaltranslator`.`CheckInvalidDateAndError`;
DROP PROCEDURE if exists  `universaltranslator`.`CheckLengthAndReplace`;
DROP PROCEDURE if exists  `universaltranslator`.`CheckListLengthIfGTError`;
DROP PROCEDURE if exists  `universaltranslator`.`CleanTranslatedListTable`;
DROP PROCEDURE if exists  `universaltranslator`.`closeOutReferral`;
DROP PROCEDURE if exists  `universaltranslator`.`CompareFALengthForNotBlankReplaceWithCon2`;
DROP PROCEDURE if exists  `universaltranslator`.`CompareTwoFieldsAndReject`;
DROP PROCEDURE if exists  `universaltranslator`.`Concat3ColsDelimNoSpaces`;
DROP PROCEDURE if exists  `universaltranslator`.`concat3ColssWithDelimiterNoSpaces`;
DROP PROCEDURE if exists  `universaltranslator`.`concatColumnsToList`;
DROP PROCEDURE if exists  `universaltranslator`.`concatFieldToList`;
DROP PROCEDURE if exists  `universaltranslator`.`copyColumn`;
DROP PROCEDURE if exists  `universaltranslator`.`CopyColumnTTItoTIR`;
DROP PROCEDURE if exists  `universaltranslator`.`countListSize`;
DROP PROCEDURE if exists  `universaltranslator`.`createTempErrorTable`;
DROP PROCEDURE if exists  `universaltranslator`.`dateddmonyyWithDashesToyyyymmdd`;
DROP PROCEDURE if exists  `universaltranslator`.`datedmyyWithSlashesToyyyymmdd`;
DROP PROCEDURE if exists  `universaltranslator`.`datemddyyyyToyyyymmdd`;
DROP PROCEDURE if exists  `universaltranslator`.`datemddyyyyWithSlashesToyyyymmdd`;
DROP PROCEDURE if exists  `universaltranslator`.`datemdyyyyWithSlashesToyyyymmdd`;
DROP PROCEDURE if exists  `universaltranslator`.`datemmddyyWithSlashesToyyyymmdd`;
DROP PROCEDURE if exists  `universaltranslator`.`datemmddyyyytoyyyymmdd`;
DROP PROCEDURE if exists  `universaltranslator`.`datemmddyyyyWithSlashesToyyyymmdd`;
DROP PROCEDURE if exists  `universaltranslator`.`datemmdyyyyWithSlashesToyyyymmdd`;
DROP PROCEDURE if exists  `universaltranslator`.`dateYYYYMMDDHHMMSSMSToYYYYMMDDHHMMSS`;
DROP PROCEDURE if exists  `universaltranslator`.`dateyyyymmddTimeToDateTime`;
DROP PROCEDURE if exists  `universaltranslator`.`dateyyyymmddTommddyyyy`;
DROP PROCEDURE if exists  `universaltranslator`.`dateyyyymmddWithDashesToyyyymmdd`;
DROP PROCEDURE if exists  `universaltranslator`.`deleteTransaction`;
DROP PROCEDURE if exists  `universaltranslator`.`DeleteTransactionWhenFieldIsNull`;
DROP PROCEDURE if exists  `universaltranslator`.`DOBCheck`;
DROP PROCEDURE if exists  `universaltranslator`.`dropValueByPriorityInboundOnly`;
DROP PROCEDURE if exists  `universaltranslator`.`FALessThanNumericCon1UpdateFBwithCon2`;
DROP PROCEDURE if exists  `universaltranslator`.`FieldBGreaterThanEqualFieldAUpdateFieldA`;
DROP PROCEDURE if exists  `universaltranslator`.`futureDateCheck`;
DROP PROCEDURE if exists  `universaltranslator`.`getConfigToFromFieldNo`;
DROP PROCEDURE if exists  `universaltranslator`.`getFinalStatusIds`;
DROP PROCEDURE if exists  `universaltranslator`.`getJSONForConfig`;
DROP PROCEDURE if exists  `universaltranslator`.`GreaterThanEqualFieldAUpdateFieldB`;
DROP PROCEDURE if exists  `universaltranslator`.`if1Con1ElseCon2`;
DROP PROCEDURE if exists  `universaltranslator`.`if1Con1ElseNull`;
DROP PROCEDURE if exists  `universaltranslator`.`ifDateCon1ElseNull`;
DROP PROCEDURE if exists  `universaltranslator`.`IfFALengthNotMatchCon1ReplaceFBWithCon2`;
DROP PROCEDURE if exists  `universaltranslator`.`ifFAStartsWithCon1UpdateFBToCon2`;
DROP PROCEDURE if exists  `universaltranslator`.`IfFieldACon1andTFBlankInsertCon2Error`;
DROP PROCEDURE if exists  `universaltranslator`.`ifFieldANotCon1ThenNull`;
DROP PROCEDURE if exists  `universaltranslator`.`ifFieldANotInListValuesSetToCon2`;
DROP PROCEDURE if exists  `universaltranslator`.`ifFieldANotNumericSetFieldBToCon1`;
DROP PROCEDURE if exists  `universaltranslator`.`IfFieldsBlankThenError`;
DROP PROCEDURE if exists  `universaltranslator`.`IfMatchFieldAAndTFBlankSetTFValue`;
DROP PROCEDURE if exists  `universaltranslator`.`IfMatchSetToValueOfAnotherColumn`;
DROP PROCEDURE if exists  `universaltranslator`.`ifNonDateAndNotBlankReject`;
DROP PROCEDURE if exists  `universaltranslator`.`ifNonDateSetNull`;
DROP PROCEDURE if exists  `universaltranslator`.`ifNotBlankReject`;
DROP PROCEDURE if exists  `universaltranslator`.`ifNumLTThenError`;
DROP PROCEDURE if exists  `universaltranslator`.`IfSFLen0orNullReplaceValueInFA`;
DROP PROCEDURE if exists  `universaltranslator`.`ifSFMatchCon1ThenCon2ElseNull`;
DROP PROCEDURE if exists  `universaltranslator`.`IfSFNullOrEmptySetFieldBToValueFieldA`;
DROP PROCEDURE if exists  `universaltranslator`.`ifSrcFieldBlankAndFACompareTo0ThenFieldBCon2`;
DROP PROCEDURE if exists  `universaltranslator`.`insertValidationErrors`;
DROP PROCEDURE if exists  `universaltranslator`.`insertValidationErrorsOutbound`;
DROP PROCEDURE if exists  `universaltranslator`.`KeepTopRanked`;
DROP PROCEDURE if exists  `universaltranslator`.`lessThanEqualFieldAUpdateFieldB`;
DROP PROCEDURE if exists  `universaltranslator`.`ListToRows`;
DROP PROCEDURE if exists  `universaltranslator`.`MatchFAUpdateSF`;
DROP PROCEDURE if exists  `universaltranslator`.`MatchFieldAUpdateFieldB`;
DROP PROCEDURE if exists  `universaltranslator`.`mergeTransactions`;
DROP PROCEDURE if exists  `universaltranslator`.`mergeValues`;
DROP PROCEDURE if exists  `universaltranslator`.`mmddyyyytoyyyymmdd`;
DROP PROCEDURE if exists  `universaltranslator`.`NJPopulateCounseling`;
DROP PROCEDURE if exists  `universaltranslator`.`NJProviderIdentifier`;
DROP PROCEDURE if exists  `universaltranslator`.`NotInUse_DateToyyyymmdd`;
DROP PROCEDURE if exists  `universaltranslator`.`NumericRange`;
DROP PROCEDURE if exists  `universaltranslator`.`overwriteColumn`;
DROP PROCEDURE if exists  `universaltranslator`.`overwriteColumnWithRandomNumber`;
DROP PROCEDURE if exists  `universaltranslator`.`pastDateCheck`;
DROP PROCEDURE if exists  `universaltranslator`.`populateAuditReport`;
DROP PROCEDURE if exists  `universaltranslator`.`populateDroppedValues`;
DROP PROCEDURE if exists  `universaltranslator`.`populateDroppedValues_20200610`;
DROP PROCEDURE if exists  `universaltranslator`.`populateOutboundAuditReport`;
DROP PROCEDURE if exists  `universaltranslator`.`PopulateTranslatedList`;
DROP PROCEDURE if exists  `universaltranslator`.`populateUniqueKeyAndTTI`;
DROP PROCEDURE if exists  `universaltranslator`.`populateWithBatchUploadId`;
DROP PROCEDURE if exists  `universaltranslator`.`prependStringWithCon2IfLengthMataches`;
DROP PROCEDURE if exists  `universaltranslator`.`regExCheck`;
DROP PROCEDURE if exists  `universaltranslator`.`rejectNonYearMonthTransactions`;
DROP PROCEDURE if exists  `universaltranslator`.`removeDupFromList`;
DROP PROCEDURE if exists  `universaltranslator`.`replaceBlanksWithChars`;
DROP PROCEDURE if exists  `universaltranslator`.`replacechars`;
DROP PROCEDURE if exists  `universaltranslator`.`setFieldToNull`;
DROP PROCEDURE if exists  `universaltranslator`.`setInboundOutBoundTables`;
DROP PROCEDURE if exists  `universaltranslator`.`setSqlForConfig`;
DROP PROCEDURE if exists  `universaltranslator`.`setSqlForOutboundConfig`;
DROP PROCEDURE if exists  `universaltranslator`.`stringToDate`;
DROP PROCEDURE if exists  `universaltranslator`.`StringToDateFor2DigitYears`;
DROP PROCEDURE if exists  `universaltranslator`.`stripCharAtPos`;
DROP PROCEDURE if exists  `universaltranslator`.`stripCharsFromStartOrEnd`;
DROP PROCEDURE if exists  `universaltranslator`.`stripLeadingChars`;
DROP PROCEDURE if exists  `universaltranslator`.`stripPhoneChars`;
DROP PROCEDURE if exists  `universaltranslator`.`stripPhoneCharsOutbound`;
DROP PROCEDURE if exists  `universaltranslator`.`stripTrailingChars`;
DROP PROCEDURE if exists  `universaltranslator`.`substringToAnotherField`;
DROP PROCEDURE if exists  `universaltranslator`.`trimField`;
DROP PROCEDURE if exists  `universaltranslator`.`updateFieldBToDistinctSrcFieldAsList`;
DROP PROCEDURE if exists  `universaltranslator`.`updateFieldBToSrcFieldAsList`;
DROP PROCEDURE if exists  `universaltranslator`.`UpdateFPRace`;
DROP PROCEDURE if exists  `universaltranslator`.`UpdateToMaxMinForCol`;
DROP PROCEDURE if exists  `universaltranslator`.`UpdateTranslatedListValueNotDistinct`;
DROP PROCEDURE if exists  `universaltranslator`.`YYYYMMDDHHMMSSMSToYYYYMMDDHHMMSS`;
DROP PROCEDURE if exists  `universaltranslator`.`yyyymmddstripTime`;
DROP PROCEDURE if exists  `universaltranslator`.`yyyymmddTimeToDateTime`;
DROP PROCEDURE if exists  `universaltranslator`.`yyyymmddToDate`;
DROP PROCEDURE if exists  `universaltranslator`.`yyyymmddTommddyyyy`;
DROP PROCEDURE if exists  `universaltranslator`.`yyyymmddToString`;
DROP PROCEDURE if exists  `universaltranslator`.`ZipCodeCheck`;
DROP PROCEDURE if exists  `universaltranslator`.`ZipCodeCheck_20200422`;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `AlphaNumericCheck`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing,batchId);
SELECT 
    @translatedTable,
    @transactionTable,
    @batchTable,
    @batchIdType,
    @errorTable,
    @translateCol
INTO @translatedTable , @transactionTable , @batchTable , @batchIdType , @errorTable, @translateCol;

call getFinalStatusIds;
SELECT @finalStatusIds INTO @finalStatusIds;

set @whereClause  = concat("  (",srcField," REGEXP '^[a-zA-Z0-9]*$' != 1 or ",srcField," REGEXP '^[a-zA-Z0-9]*$' is null)
            and ",srcField," is not null and  length(",srcField,") > 0 and ");
            
set @whereString = concat(@whereClause, "  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");

			set @stmt = concat("update ",@translatedTable," set forCW = 'MACRO_ERROR' where ",@whereString);

			PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `appendCon2IfCon1Length`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

/** con1 must be numeric **/
				if (con1 REGEXP '^[]?[0-9]*[]{0,1}[0-9]*$' = 0 || length(@con1) = 0 ) then

							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'appendCon2IfCon1Length Macro - Con1 - ",con1," must be an integer. '",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;


leave proc_main;

end if;

set @whereClause = '';
if (con1 = 0) then
	set @whereClause = concat(" or ",srcField," is null");
end if;

set @stmt = concat("update ", @translatedTable," set ",srcField,
" = concat_ws('',",srcField,", '", con2, "') where (length(",srcField,") = ",con1,@whereClause,") and ",
"configId = ",configId," and ",@batchIdType," = ",batchId," and statusId not in (",@finalStatusIds,");");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `appendPrependString`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

/** 
FA - Prepend string
FB - prepend Y/N to Blanks
Con1 = Append String
Con2 - append Y/N to blanks
**/
-- we remove the first F
	set @prependString = substring(fieldA, 2, length(fieldA) -1);
    set @prependBlanks =  substring(fieldB, 2, 1);
    
    set @appendString = con1;
    set @appendBlanks =  con2;
    
    
			set @stmt = concat("update ", @translatedTable," set forcw = case when ",srcField," is null or length(",srcField,") = 0 then  'blank' else 'notblank' end;");

            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
            
            
    
    
	set @wherePrependString = concat(" and ",srcField, " is not null and length(",srcField,") > 0");
	-- first we prepend
	if (@prependBlanks = 'Y') then
		begin
			set @wherePrependString = '';
        end;
    end if;
    
			set @stmt = concat("update ", @translatedTable," set ",srcField,
			" = case when ",srcField," is null then '",@prependString,"' else concat('", @prependString, "', ", srcField, ") end where ",
			"configId = ",configId," and ",@batchIdType," = ",batchId," and statusId not in (",@finalStatusIds,")",@wherePrependString,";");
            
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;


-- then we append
	set @whereAppendString = concat(" and ",srcField, " is not null and length(",srcField,") > 0 and forcw != 'blank' ");
		-- first we prepend
		if (@appendBlanks = 'Y') then
			begin
				set @whereAppendString = '';
			end;
		end if;

		set @stmt = concat("update ", @translatedTable," set ",srcField,
			" = case when ",srcField," is null then '",@appendString,"' else concat(",srcField,", '",@appendString,"') end where ",
			"configId = ",configId," and ",@batchIdType," = ",batchId," and statusId not in (",@finalStatusIds,")",@whereAppendString,";");
         
			PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;

		
			set @stmt = concat("update ", @translatedTable," set forcw = null;");
            
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
            
end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `applyCWTranslatedList`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin 

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @listTable, @translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @listTable, @translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

set @whereString = concat(" and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");


set @fcol = replace(lcase(srcField), 'f', '');
set @stmt = concat("truncate table ", @listTable);

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

		set @stmt = concat("
		SELECT max(CHAR_LENGTH(",srcField,") - CHAR_LENGTH( REPLACE ( ",srcField,", ',', '') )  + 1) from ",@translatedTable, " into @maxListLength");
		
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
         
        if (@maxListLength is null) then
			set @maxListLength = 108;
        end if;
       
		set @stmt = concat("
    insert into ", @listTable," (",@batchIdType,", ",@translateCol,", invalue, fcol)
    SELECT ",@batchIdType,", ",@translateCol,", IFNULL(trim(SUBSTRING_INDEX(SUBSTRING_INDEX(t.",srcField,", ',', n.n), ',', -1)),'') value, ",@fcol,"
	FROM ",@translatedTable ," t CROSS JOIN (
    SELECT distinct a.N + b.N * 10 + 1 n FROM  
   (select id N from ref_numbers where id <=",@maxListLength,") a
   ,(select id N from ref_numbers where id <=",@maxListLength,") b
    ORDER BY n) n  WHERE n.n <= 1 + (LENGTH(t.",srcField,") - LENGTH(REPLACE(t.",srcField,", ',', ''))) ", @whereString);
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

    
    set @stmt = concat("update ",@listTable," set invalue = replace(replace(invalue, '\n',''), '\r', '')");
	 
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    
	set @stmt = concat("update ",@listTable," join (select id, sourcevalue, targetvalue from rel_crosswalkdata where crosswalkid = ", con1 ,") cwdata
	on invalue = sourcevalue set translatedvalue = targetvalue where ",@batchIdType," = ", batchId);
  
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
	if (passClear = 1) then
	
		set @stmt = concat("update ",@listTable, " set translatedvalue = invalue where translatedvalue is null ");
		
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
	end if;
  
	set @selDistinct = '';
    
    if (con2 = 'Y') then
		begin
			set @selDistinct = ' distinct ';
        end;
    end if;
  
    set @stmt = concat("update ",@translatedTable," join  (select ",@translateCol," as matchId, 
    group_concat(",@selDistinct," translatedValue order by id) label from  ",@listTable,"
	where ",@batchIdType," = ",batchid, " and fcol = ",@fCol," group by ",@translateCol," ) cwmatch on ",@translateCol," = matchid set ",srcField," = label ");
	   
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    set @colText = "in";
    if (foroutboundProcessing) then
		set @colText = "out";
    end if;
    
    if (passClear = 2) then

		set @stmt = concat("
			insert into transaction",@colText,"macrodroppedvalues_",batchId," (",@batchIdColumn ,", transaction",@colText,"RecordsId, fieldNo, fieldValue, matchId, configId) 
			select distinct ",batchId,", transaction",@colText,"RecordsId, fcol, invalue,concat(",configId,", '_', fcol, '_', invalue), ",configId," from transactiontranslatedlist",@colText,"_",batchId," where translatedValue is null and length(invalue) > 0;
		");
		
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
	end if;

	set @stmt = concat("
		insert into transaction",@colText,"macrokeptvalues_",batchId," (",@batchIdColumn ,", transaction",@colText,"RecordsId, fieldNo, fieldValue, matchId, configId) 
		select distinct ",batchId,", transaction",@colText,"RecordsId, fcol, invalue, concat(",configId,", '_', fcol, '_', invalue), ",configId," from transactiontranslatedlist",@colText,"_",batchId," where translatedValue is not null;
	");
 
	PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

    set @stmt = concat("delete from ", @listTable, " where ",@batchIdType," = ",batchId," and fcol = ",@fcol);
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `applyCWTranslatedListNoTrackDroppedValues`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin 

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @listTable, @translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @listTable, @translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

set @whereString = concat(" and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");

set @fcol = replace(lcase(srcField), 'f', '');
set @stmt = concat("truncate table ", @listTable);

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

		set @stmt = concat("
		SELECT max(CHAR_LENGTH(",srcField,") - CHAR_LENGTH( REPLACE ( ",srcField,", ',', '') )  + 1) from ",@translatedTable, " into @maxListLength");
		
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
         
        if (@maxListLength is null) then
			set @maxListLength = 108;
        end if;
       
		set @stmt = concat("
    insert into ", @listTable," (",@batchIdType,", ",@translateCol,", invalue, fcol)
    SELECT ",@batchIdType,", ",@translateCol,", IFNULL(trim(SUBSTRING_INDEX(SUBSTRING_INDEX(t.",srcField,", ',', n.n), ',', -1)),'') value, ",@fcol,"
	FROM ",@translatedTable ," t CROSS JOIN (
    SELECT distinct a.N + b.N * 10 + 1 n FROM  
   (select id N from ref_numbers where id <=",@maxListLength,") a
   ,(select id N from ref_numbers where id <=",@maxListLength,") b
    ORDER BY n) n  WHERE n.n <= 1 + (LENGTH(t.",srcField,") - LENGTH(REPLACE(t.",srcField,", ',', ''))) ", @whereString);
    
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

    
    set @stmt = concat("update ",@listTable," set invalue = replace(replace(invalue, '\n',''), '\r', '')");
	
    
     
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    set @stmt = concat("update ",@listTable," join (select id, sourcevalue, targetvalue from rel_crosswalkdata where crosswalkid = ", con1 ,") cwdata
	on invalue = sourcevalue set translatedvalue = targetvalue where ",@batchIdType," = ", batchId);
	
    
  
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
	if (passClear = 1) then
	
		set @stmt = concat("update ",@listTable, " set translatedvalue = invalue where translatedvalue is null ");
		
        
		
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
	
    end if;
  
  
  
	set @selDistinct = '';
    
    if (con2 = 'Y') then
		begin
			set @selDistinct = ' distinct ';
        end;
    end if;
  
    set @stmt = concat("update ",@translatedTable," join  (select ",@translateCol," as matchId, 
    group_concat(",@selDistinct," translatedValue order by id) label from  ",@listTable,"
	where ",@batchIdType," = ",batchid, " and fcol = ",@fCol," group by ",@translateCol," ) cwmatch on ",@translateCol," = matchid set ",srcField," = label ");
	
    
       
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    

    set @stmt = concat("delete from ", @listTable, " where ",@batchIdType," = ",batchId," and fcol = ",@fcol);
    
    
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;


end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `ArithmeticConstant`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		-- multipler
		set fieldA = REPLACE(fieldA,'F','');
       
		-- con1 
        if(con1 is null or con1 = '') then 
			BEGIN
				set con1 = 0;
			END;
		end if;

        -- check to see if con1 is numeric
      if con1 REGEXP '^-?[0-9]+[.]?[0-9]*$|^-?[.][0-9]+$' = 0 or   fieldA REGEXP '^-?[0-9]+[.]?[0-9]*$|^-?[.][0-9]+$' = 0 then 
					begin
			
							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'ArithmeticConstant Con1 - ",con1,"  or FA - ",fieldA," is not a valid value'",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            -- update all transactions to macro_error
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							 
                             PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
           
			leave proc_main;
        end;
      end if;
      
        -- division by 0
      if con2 = '/'  and  fieldA = '0' then
					begin
			
							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'ArithmeticConstant Divide (con2) by 0 (con1) error.'",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            -- update all transactions to macro_error
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
           
			leave proc_main;
        end;
      end if;
      
      -- for con2 we only accept * +  / - 
       -- check to see if con1 is numeric
      if con2 != '/'  and  con2 != '-'  and con2!='*' and con2 != '+' then
					begin
			
							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'ArithmeticConstant con2 - ", con2," is not a valid arithmetic operation.'",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            -- update all transactions to macro_error
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
           
			leave proc_main;
        end;
      end if;
      
		
        -- insert macro error if srcField is not numeric, we ignore blanks
        
        
		set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where ",srcField,"  REGEXP '^-?[0-9]+[.]?[0-9]*$|^-?[.][0-9]+$' = 0
        and ",srcField," is not null and length(",srcField,") > 0 and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
		

		 set @stmt = concat("update ",@translatedTable, " set ",srcField," = replace(format((",srcField," ",con2," ",fieldA,"),",con1,"), ',', '') where 
         forcw is null and ",srcField," is not null and length(",srcField,") > 0
         and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")
		 and ",con1 ," REGEXP  '^-?[0-9]+[.]?[0-9]*$|^-?[.][0-9]+$' = 1  and ",srcField ," REGEXP  '^-?[0-9]+[.]?[0-9]*$|^-?[.][0-9]+$' = 1 ;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `CheckInvalidDateAndError`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
SELECT 
    @translatedTable,
    @transactionTable,
    @batchTable,
    @batchIdType,
    @errorTable,
    @translateCol
INTO @translatedTable , @transactionTable , @batchTable , @batchIdType , @errorTable, @translateCol;

call getFinalStatusIds;
SELECT @finalStatusIds INTO @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


set @errorIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, "  where 
					(str_to_date(",srcField,",'",con1,"') is null or str_to_date(",srcField,",'",con1,"') = '0000-00-00'
                    or right(str_to_date(",srcField,",'",con1,"'), 2) = '00' or left(str_to_date(",srcField,",'",con1,"'), 2) = '00' 
                    or substring(str_to_date(",srcField,",'",con1,"'), 6, 2) = '00' 
                    ) 
                    and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
       
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


if (@errorIds is not null) then

begin

set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;
     


set @stmt = concat("update ",@translatedTable, " set forcw = str_to_date(",srcField,", '",con1,"') where (forcw is null or forcw != 'MACRO_ERROR')
					and ",srcField," is not null and length(",srcField,") > 0 	
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
 

set @errorIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(forcw) is null
					and ",srcField," is not null and length(",srcField,") > 0  and  (forcw is null or forcw != 'MACRO_ERROR')
					and ",srcField," is not null and length(",srcField,") > 0 	
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


if (@errorIds is not null) then

begin

set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;


end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `CheckLengthAndReplace`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);

SELECT 
    @translatedTable,
    @transactionTable,
    @batchTable,
    @batchIdType,
    @errorTable
INTO @translatedTable , @transactionTable , @batchTable , @batchIdType , @errorTable;

call getFinalStatusIds;
SELECT @finalStatusIds INTO @finalStatusIds;

      -- check to see if con1 is numeric
      if con1 REGEXP '^[]?[0-9]*[]{0,1}[0-9]*$' = 0 then 
					begin
						set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'CheckLengthAndReplace Con1 - ",con1,"  must be a numeric value'",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            -- update all transactions to macro_error
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							 
                             PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
           
			leave proc_main;
        end;
      end if;
      
		
        set @con1is0 = '';
        if (con1 = '0') then 
			set @con1is0 = concat(" or ", srcField," is null");
        end if;
        
      	
		set @stmt = concat("update ",@translatedTable, " set ",srcField," =  '", con2, "'",
		"   where (length(",srcField, ") = ",con1," ", @con1is0, ")  and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `CheckListLengthIfGTError`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
SELECT 
    @translatedTable,
    @transactionTable,
    @batchTable,
    @batchIdType,
    @errorTable,
    @translateCol
INTO @translatedTable , @transactionTable , @batchTable , @batchIdType , @errorTable, @translateCol;

call getFinalStatusIds;
SELECT @finalStatusIds INTO @finalStatusIds;

/** con1 must be numeric and greater than 1 **/

				if (con1 REGEXP '^[]?[0-9]*[]{0,1}[0-9]*$' = 0 || length(@con1) = 0 || con1 < 1) then

							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'CheckListLengthIfGTError Macro - Con1 - ",con1," must be an integer greater than 0. '",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;


leave proc_main;

end if;

	set @errorCode='52';

	set @whereString = concat("  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");


	set @requiredField = true;
    set @stmt = concat("update ", @translatedTable, " set statusId = 14 where  LENGTH(",srcField,") - LENGTH(REPLACE( ",srcField,", ',', '')) + 1 > ",con1," and ", 
		@whereString);
		
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
     
     
	set @stmt = concat("select fieldDesc into @fieldName from configurationformfields where configId = ",configId," and fieldNo = replace('",srcField,"', 'F', '') limit 1;");

	PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
     
     set @stmt = concat("insert into ", @errorTable , " (" , @batchIdColumn, ", configId, " , @translateCol, 
    ", fieldNo, errorId, macroId, fieldValue, required, fieldLabel, stackTrace) select ",@batchIdType,", configId, id, replace('",srcField,"', 'F', ''), ", @errorCode, 
    ", ",macroId,",",srcField,", ",@requiredField,", '",@fieldName,"', 'CheckListLengthIfGTError - list length is too long. Expecting ", con1,".'  from ", @translatedTable, " where  LENGTH(",srcField,") - LENGTH(REPLACE( ",srcField,", ',', '')) + 1 > ",con1," and ", 
    @whereString);
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    
    
     
end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `clearSF`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


		set @stmt = concat("update ",@translatedTable, " set ",srcField," = '' where 
        configId = ",configId," and ",@batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `CompareTwoFieldsAndError`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

/** 
this macro compares SF and FA using con1 operator
Conditional: Compare Two Non-Blank Fields and Insert Error when criteria is not met
need to compare nulls and blanks, will treat null as blanks
**/

call setInboundOutBoundTables (foroutboundProcessing,batchId);
SELECT 
    @translatedTable,
    @transactionTable,
    @batchTable,
    @batchIdType,
    @errorTable,
    @translateCol
INTO @translatedTable , @transactionTable , @batchTable , @batchIdType , @errorTable, @translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

	/** allowed comparison >, >=, =, <, <=, != **/
      if con1 != '>'  and  con1 != '>='  and con1!='=' and con1 != '<' and con1 != '<=' and con1 != '!=' and con1 != '<>' then
					begin
			
							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'CompareTwoFieldsAndError con1 - ", con1," is not a valid comparison.'",", ",true);
                            
							PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
           
			leave proc_main;
        end;
      end if;


	-- This macro need to handle blanks and nulls, we treat nulls as blanks
    
    /** MySql doesn't compare integers and decimals well
		we create a temp table and insert those into a table that specifics them as float
    **/
    set @stmt = concat("drop table if exists transactionnumericcompare_", batchId);
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
    
    
    set @stmt = concat("CREATE TABLE transactionnumericcompare_",batchId," (
			  id int(11) NOT NULL AUTO_INCREMENT,
			  transactionId int(11) DEFAULT NULL,
			  compareResult bit(1) NOT NULL DEFAULT b'0',
			  col1Data FLOAT(20,10) DEFAULT NULL,
			  col2Data FLOAT(20,10) DEFAULT NULL,
			  PRIMARY KEY (id),
			  KEY numCompResult (compareResult)
			  ) ENGINE=InnoDB DEFAULT CHARSET=latin1;");
              
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
    
	/** now we insert the numeric values and compare those **/
    set @stmt = concat("insert into transactionnumericcompare_",batchId," 
    (transactionId, col1Data, col2Data)
    select ",@translateCol,", ",srcField,", ",fieldA," from ", @translatedTable, 
    " where ",srcField, "  REGEXP '^[+-]?[0-9]*[.]{0,1}[0-9]*$' = 1
    and ",fieldA, "  REGEXP '^[+-]?[0-9]*[.]{0,1}[0-9]*$' = 1 
    and length(",srcField, ") > 0 and length(",fieldA, ") > 0 ");
    
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
	
	/** this way it will compare better **/
    set @stmt = concat("update ",@translatedTable, " join 
	(select col1data ", con1 ," col2data comparedResults , transactionId from transactionnumericcompare_",batchId,") t2
	on transactionId = ",@translateCol,"
	set forCW = case when comparedResults = true then 'compared' else 'MACRO_ERROR' end ");
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
    
		
		/** we compare and update **/
      /** we compare all the fields that has null, we treat nulls as blanks **/
    
     set @stmt = concat("update  ",@translatedTable, " t1 join 
		(select case when ",srcField, " is null then '' else ", srcField," end " , con1, " case when ",fieldA, " is null then '' else ", fieldA," end comparedResults , ",@translateCol," 
		from  ",@translatedTable, " where forCW is null or forCW != 'compared') t2
		on t1.",@translateCol," = t2.",@translateCol,"
		set forCW = case when comparedResults then '' else 'MACRO_ERROR' end ");
	 
     PREPARE stmt from @stmt;
     EXECUTE stmt;
     DEALLOCATE PREPARE stmt;

	set @stmt = concat("drop table if exists transactionnumericcompare_", batchId);
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
    
end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `CompareTwoFieldsAndUpdateSF`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

/** 
this macro compares SF and FA using con1 operator
and will update to con2

**/

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


	/** allowed comparison >, >=, =, <, <=, != **/
      if con1 != '>'  and  con1 != '>='  and con1!='=' and con1 != '<' and con1 != '<=' and con1 != '!=' and con1 != '<>'then
					begin
			
							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'CompareTwoFieldsAndUpdateSF con1 - ", con1," is not a valid comparison.'",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
           
			leave proc_main;
        end;
      end if;
	
    /** MySql doesn't compare integers and decimals well
		we create a temp table and insert those into a table that specifics them as float
    **/
    set @stmt = concat("drop table if exists transactionnumericcompare_", batchId);
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
    
    
    set @stmt = concat("CREATE TABLE transactionnumericcompare_",batchId," (
			  id int(11) NOT NULL AUTO_INCREMENT,
			  transactionId int(11) DEFAULT NULL,
			  compareResult bit(1) NOT NULL DEFAULT b'0',
			  col1Data FLOAT(20,10) DEFAULT NULL,
			  col2Data FLOAT(20,10) DEFAULT NULL,
			  PRIMARY KEY (id),
			  KEY numCompResult (compareResult)
			  ) ENGINE=InnoDB DEFAULT CHARSET=latin1;");
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
    
	/** now we insert the numeric values and compare those **/
    set @stmt = concat("insert into transactionnumericcompare_",batchId," 
    (transactionId, col1Data, col2Data)
    select ",@translateCol,", ",srcField,", ",fieldA," from ", @translatedTable, 
    " where ",srcField, "  REGEXP '^[+-]?[0-9]*[.]{0,1}[0-9]*$' = 1
    and ",fieldA, "  REGEXP '^[+-]?[0-9]*[.]{0,1}[0-9]*$' = 1 
    and length(",srcField, ") > 0 and length(",fieldA, ") > 0 ");
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
	
	/** this way it will compare better **/
    set @stmt = concat("update ",@translatedTable, " join 
	(select col1data ", con1 ," col2data comparedResults , transactionId from transactionnumericcompare_",batchId,") t2
	on transactionId = ",@translateCol,"
	set forCW = 'compared', ",srcField," = case when comparedResults then '",con2,"' else ",srcField," end ");
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
    
		
	 /** we compare and update 
     we treat nulls as blanks
     **/
     set @stmt = concat("update  ",@translatedTable, " t1 join 
		(select case when ",srcField, " is null then '' else ",srcField, " end " , con1, 
        " case when ",fieldA, " is null then '' else ",fieldA, " end ",
        " comparedResults , ",@translateCol," 
		from  ",@translatedTable, " where forCW is null or forCW != 'compared') t2
		on t1.",@translateCol," = t2.",@translateCol,"
		set ",srcField," = case when comparedResults then '",con2,"' else ",srcField," end ");
	
     PREPARE stmt from @stmt;
     EXECUTE stmt;
     DEALLOCATE PREPARE stmt;
     
     
	set @stmt = concat("drop table if exists transactionnumericcompare_", batchId);
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `concatFieldToList`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

set @fields = concat('F', replace(replace(con2, ' ', ''), ',', ',F'));
set @sql = concat("concat_ws('",con1,"', " , @fields , ")");


		set @stmt = concat("update " ,@translatedTable,  " set ", srcField, " = ", @sql , 
		" where configId = ",configId," and ",@batchIdType," = ",batchId," and statusId not in (",@finalStatusIds,");");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `copyField`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

	set @stmt = concat("update ",@translatedTable, " set ",srcField," = ", fieldB, 
    " where configId = ",configId," and ", @batchIdColumn, " = ",batchId," and statusId not in (",@finalStatusIds,");");	
    
	PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `createTempErrorTable`(in inBatchId int)
proc_main:begin


SET @stmt = CONCAT("drop TABLE if exists transactionoutdetailauditerrorsforinbound_",inBatchId);

			PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;


SET @stmt = CONCAT("
CREATE TABLE transactionoutdetailauditerrorsforinbound_",inBatchId," (
  id int(11) NOT NULL AUTO_INCREMENT,
  batchDownloadId int(11) NOT NULL,
  configId int(11) NOT NULL,
  transactionOutRecordsId int(11) NOT NULL,
  fieldNo int(11) NOT NULL,
  fieldName varchar(45) DEFAULT NULL,
  errorId int(11) NOT NULL,
  errorDetails varchar(200) DEFAULT NULL COMMENT 'This field is used to update cw name, validation type name, macro name',
  errorData text,
  reportField1Data varchar(45) DEFAULT NULL,
  reportField2Data varchar(45) DEFAULT NULL,
  reportField3Data varchar(45) DEFAULT NULL,
  reportField4Data varchar(45) DEFAULT NULL,
  transactionOutErrorId int(11) DEFAULT '0',
  required bit(1) default null,
  PRIMARY KEY (id),
  KEY ttoauditKey",inBatchId,"Error_idx (batchDownloadId)
  ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=latin1;
");

			PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;


end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `dateddmonyyWithDashesToyyyymmdd`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


		set @mysqlDateFormat = concat('%Y-%m-%d');
		set @inboundDateFormat = concat('%d-%b-%y');
        set @outboundDateFormat = concat('%Y%m%d');
		
         
        set @errorIds = '';
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where left(right(",srcField,", 3), 1) != '-' 
					and ",srcField," is not null and length(",srcField,") > 0 and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin

				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;
        


		set @errorIds = "";
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(",srcField,", '",@inboundDateFormat,"') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin
				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
		end;
		end if;


		
		set @stmt = concat("update ",@translatedTable, " set forcw = str_to_date(",srcField,", '",@inboundDateFormat,"') where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
                    
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
      

		
		set @errorIds = "";
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(forcw) is null
					and ",srcField," is not null and length(",srcField,") > 0  and forcw != 'MACRO_ERROR'  and forcw is not null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
       
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin	
				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
				 
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;
        
        
		set @goodIds = "";

		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where  ",srcField," is not null and length(",srcField,") > 0  
					and (forcw != 'MACRO_ERROR' or forcw is null)
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @goodIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		
		if (@goodIds is not null) then

		begin


			/** fix two digit years **/
			select year(curdate()) into @currYear;

			set @stmt = concat("update ",@translatedTable, " set forcw =  DATE_ADD(forcw, INTERVAL -100 Year) where id in (",@goodIds,") 
			and year(forcw) > ",@currYear,"");
			
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;  
		
		set @stmt = concat("update ",@translatedTable, " set ",srcField," = date_format(forcw, '",@outboundDateFormat,"') where id in (",@goodIds,") ");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
			end;
		end if;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `datedmyyWithSlashesToyyyymmdd`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


		set @mysqlDateFormat = concat('%Y-%m-%d');
		set @inboundDateFormat = concat('%e/%c/%y');
        set @outboundDateFormat = concat('%Y%m%d');
		
         
        set @errorIds = '';
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where left(right(",srcField,", 3), 1) != '/' 
					and ",srcField," is not null and length(",srcField,") > 0 and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin

				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;
        


		set @errorIds = "";
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(",srcField,", '",@inboundDateFormat,"') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin
				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
		end;
		end if;


		
		set @stmt = concat("update ",@translatedTable, " set forcw = str_to_date(",srcField,", '",@inboundDateFormat,"') where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
                    
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
      

		
		set @errorIds = "";
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(forcw) is null
					and ",srcField," is not null and length(",srcField,") > 0  and forcw != 'MACRO_ERROR'  and forcw is not null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
       
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin	
				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
				 
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;
        
		set @goodIds = "";

		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where  ",srcField," is not null and length(",srcField,") > 0  
					and (forcw != 'MACRO_ERROR' or forcw is null)
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @goodIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		
		if (@goodIds is not null) then

		begin

			/** fix two digit years **/
			select year(curdate()) into @currYear;

			set @stmt = concat("update ",@translatedTable, " set forcw =  DATE_ADD(forcw, INTERVAL -100 Year) where id in (",@goodIds,") 
			and year(forcw) > ",@currYear,"");
			
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;  
		
		set @stmt = concat("update ",@translatedTable, " set ",srcField," = date_format(forcw, '",@outboundDateFormat,"') where id in (",@goodIds,") ");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
			end;
		end if;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `datemddyyyyToyyyymmdd`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		set @mysqlDateFormat = concat('%Y-%m-%d');
		set @inboundDateFormat = concat('%Y-%m-%d');
        set @outboundDateFormat = concat('%Y%m%d');

                set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where length(",srcField,") !=7 and length(",srcField,") !=8
                and ",srcField," is not null and length(",srcField,") > 0");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
		
				/**
					manually add slashes to make it mysql date format since mysql has trouble understanding dates without date separator
					if 7 digits we insert one-two-four
                    if 8 digits we insert two-two-four
                
                **/
                
				set @stmt = concat("update ",@translatedTable, " set forcw = concat(right(",srcField,", 4), '',  '-0', left(",srcField,", 1), '-', substring(",srcField,", 2,2)) 
                where length(",srcField,") =7 and forcw != 'MACRO_ERROR' or forcw is null
                and ",srcField," is not null and length(",srcField,") > 0");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
                
                
                set @stmt = concat("update ",@translatedTable, " set forcw = concat(right(",srcField,", 4), '-',left(",srcField,", 2) , '-', substring(",srcField,", 2,2))
                where length(",srcField,") =8 and forcw != 'MACRO_ERROR' or forcw is null
                and ",srcField," is not null and length(",srcField,") > 0");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
		
				--  check inbound date formats and log
				set @errorIds = "";
				set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(forcw, '",@inboundDateFormat,"') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin
				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
		end;
		end if;

		
		-- recheck to log invalid dates such as 1997-02-29
		set @errorIds = "";
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(forcw) is null
					and ",srcField," is not null and length(",srcField,") > 0 and forcw != 'MACRO_ERROR' and forcw is not null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
       
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin	
				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
				 
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;
        
        
		set @goodIds = "";

		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where  ",srcField," is not null and length(",srcField,") > 0  
					and (forcw != 'MACRO_ERROR' or forcw is null)
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @goodIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		-- recheck to log invalid dates such as 1997-02-29
		if (@goodIds is not null) then

		begin

		-- now we reformat to mddyyyy with con1
		set @stmt = concat("update ",@translatedTable, " set ",srcField," = date_format(forcw, '",@outboundDateFormat,"') where id in (",@goodIds,") ");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `datemddyyyyWithSlashesToyyyymmdd`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		set @mysqlDateFormat = concat('%Y-%m-%d');
		set @inboundDateFormat = concat('%c/%d/%Y');
        set @outboundDateFormat = concat('%Y%m%d');
		
         -- check to make sure it is two digit years
        set @errorIds = '';
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where left(right(",srcField,", 5), 1) != '/' 
					and ",srcField," is not null and length(",srcField,") > 0 and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin

				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
		
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;
        

--  check inbound date formats and log
		set @errorIds = "";
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(",srcField,", '",@inboundDateFormat,"') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin
				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
		end;
		end if;


		-- update it to valid mysql date fomat
		set @stmt = concat("update ",@translatedTable, " set forcw = str_to_date(",srcField,", '",@inboundDateFormat,"') where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
                    
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
      

		-- recheck to log invalid dates such as 1997-02-29
		set @errorIds = "";
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(forcw) is null
					and ",srcField," is not null and length(",srcField,") > 0  and forcw != 'MACRO_ERROR'  and forcw is not null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
       
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin	
				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
				 
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;
        
        
		set @goodIds = "";

		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where  ",srcField," is not null and length(",srcField,") > 0  
					and (forcw != 'MACRO_ERROR' or forcw is null)
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @goodIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		-- recheck to log invalid dates such as 1997-02-29
		if (@goodIds is not null) then

		begin

		-- now we reformat to mmddyyyy with con1
		set @stmt = concat("update ",@translatedTable, " set ",srcField," = date_format(forcw, '",@outboundDateFormat,"') where id in (",@goodIds,") ");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `datemdyyyyWithSlashesToyyyymmdd`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;




set @errorIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(",srcField,", '%c/%e/%Y') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

if (@errorIds is not null) then

begin

set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;


set @stmt = concat("update ",@translatedTable, " set ",srcField," = str_to_date(",srcField,", '%c/%e/%Y') where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 	
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
      

set @errorIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(",srcField,") is null
					and ",srcField," is not null and length(",srcField,") > 0  and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


if (@errorIds is not null) then

begin

set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;

set @errorIds = '';



set @stmt = concat("update ",@translatedTable, " set ",srcField," =  replace(",srcField,", '-', '')
where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") 
");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `datemmddyyWithSlashesToyyyymmdd`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		set @mysqlDateFormat = concat('%Y-%m-%d');
		set @inboundDateFormat = concat('%m/%d/%y');
        set @outboundDateFormat = concat('%Y%m%d');
		
        set @errorIds = '';
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where left(right(",srcField,", 3), 1) != '/' 
					and ",srcField," is not null and length(",srcField,") > 0 and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin

				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
		
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;
        

		set @errorIds = "";
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(",srcField,", '",@inboundDateFormat,"') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin
				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
		end;
		end if;

		set @stmt = concat("update ",@translatedTable, " set forcw = str_to_date(",srcField,", '",@inboundDateFormat,"') where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
                    
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
      

		
		set @errorIds = "";
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(forcw) is null
					and ",srcField," is not null and length(",srcField,") > 0  and forcw != 'MACRO_ERROR'  and forcw is not null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
       
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin	
				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
				 
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;
        
        
		set @goodIds = "";

		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where  ",srcField," is not null and length(",srcField,") > 0  
					and (forcw != 'MACRO_ERROR' or forcw is null)
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @goodIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		
		if (@goodIds is not null) then

		begin

		/** fix two digit years **/
			select year(curdate()) into @currYear;

			set @stmt = concat("update ",@translatedTable, " set forcw =  DATE_ADD(forcw, INTERVAL -100 Year) where id in (",@goodIds,") 
			and year(forcw) > ",@currYear,"");
			
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt; 
        
        
		set @stmt = concat("update ",@translatedTable, " set ",srcField," = date_format(forcw, '",@outboundDateFormat,"') where id in (",@goodIds,") ");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;
        
end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `datemmddyyyytoyyyymmdd`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

set @errorIds = "";

set @inboundDateFormat = concat("%m",con1,"%d",con1,"%Y");
set @outboundDateFormat = concat("%Y",con2,"%m",con2,"%d");

--  check inbound date formats and log
set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(",srcField,", '",@inboundDateFormat,"') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

if (@errorIds is not null) then

begin
set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
end;
end if;

if (length(con1) > 0) then 
begin
-- we expect 4 digit years
set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 	
                    and substring(",srcField,",6,",length(con1),") != '",con1,"'
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
end;
end if;

-- update it to valid mysql date fomat
set @stmt = concat("update ",@translatedTable, " set ",srcField," = str_to_date(",srcField,", '",@inboundDateFormat,"') where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 	
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
        
       PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
      

set @errorIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(",srcField,") is null
					and ",srcField," is not null and length(",srcField,") > 0  and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

-- recheck to log invalid dates such as 1997-02-29
if (@errorIds is not null) then

begin

set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;

set @goodIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where  ",srcField," is not null and length(",srcField,") > 0  and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @goodIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

-- recheck to log invalid dates such as 1997-02-29
if (@goodIds is not null) then
begin
-- now we reformat to mmddyyyy with con1
set @stmt = concat("update ",@translatedTable, " set ",srcField," = date_format(",srcField,", '",@outboundDateFormat,"') where id in (",@goodIds,") ");
		
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `datemmddyyyyWithSlashesToyyyymmdd`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;




set @errorIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(",srcField,", '%m/%d/%Y') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

if (@errorIds is not null) then

begin

set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;


set @stmt = concat("update ",@translatedTable, " set ",srcField," = str_to_date(",srcField,", '%m/%d/%Y') where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 	
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
      

set @errorIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(",srcField,") is null
					and ",srcField," is not null and length(",srcField,") > 0  and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


if (@errorIds is not null) then

begin

set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;

set @errorIds = '';



set @stmt = concat("update ",@translatedTable, " set ",srcField," =  replace(",srcField,", '-', '')
where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") 
");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `datemmdyyyyWithSlashesToyyyymmdd`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		set @mysqlDateFormat = concat('%Y-%m-%d');
		set @inboundDateFormat = concat('%m/%e/%Y');
        set @outboundDateFormat = concat('%Y%m%d');
		
         -- check to make sure it is two digit years
        set @errorIds = '';
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where left(right(",srcField,", 5), 1) != '/' 
					and ",srcField," is not null and length(",srcField,") > 0 and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin

				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
		
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;
        
--  check inbound date formats and log
		set @errorIds = "";
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(",srcField,", '",@inboundDateFormat,"') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin
				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
		end;
		end if;


		-- update it to valid mysql date fomat
		set @stmt = concat("update ",@translatedTable, " set forcw = str_to_date(",srcField,", '",@inboundDateFormat,"') where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
                    
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
      

		-- recheck to log invalid dates such as 1997-02-29
		set @errorIds = "";
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(forcw) is null
					and ",srcField," is not null and length(",srcField,") > 0  and forcw != 'MACRO_ERROR'  and forcw is not null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
       
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		if (@errorIds is not null) then

		begin	
				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
				 
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;
        
        
		set @goodIds = "";

		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where  ",srcField," is not null and length(",srcField,") > 0  
					and (forcw != 'MACRO_ERROR' or forcw is null)
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @goodIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		-- recheck to log invalid dates such as 1997-02-29
		if (@goodIds is not null) then

		begin

		-- now we reformat to mmddyyyy with con1
		set @stmt = concat("update ",@translatedTable, " set ",srcField," = date_format(forcw, '",@outboundDateFormat,"') where id in (",@goodIds,") ");
				
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
		end;
		end if;


end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `dateyyyymmddTommddyyyy`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

set @errorIds = "";

set @inboundDateFormat = concat("%Y",con1,"%m",con1,"%d");
set @outboundDateFormat = concat("%m",con2,"%d",con2,"%Y");


--  check inbound date formats and log
set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(",srcField,", '",@inboundDateFormat,"') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

if (@errorIds is not null) then

begin
set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
end;
end if;

if (length(con1) > 0) then 
begin
-- we expect 4 digit years
set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 	
                    and substring(",srcField,",5,",length(con1),") != '",con1,"'
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
end;
end if;

-- update it to valid mysql date fomat
set @stmt = concat("update ",@translatedTable, " set ",srcField," = str_to_date(",srcField,", '",@inboundDateFormat,"') where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 	
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
        
       PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
      

set @errorIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(",srcField,") is null
					and ",srcField," is not null and length(",srcField,") > 0  and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

-- recheck to log invalid dates such as 1997-02-29
if (@errorIds is not null) then

begin

set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;


set @goodIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where  ",srcField," is not null and length(",srcField,") > 0  and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @goodIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

-- recheck to log invalid dates such as 1997-02-29
if (@goodIds is not null) then
begin
-- now we reformat to mmddyyyy with con1
set @stmt = concat("update ",@translatedTable, " set ",srcField," = date_format(",srcField,", '",@outboundDateFormat,"') where id in (",@goodIds,") ");
		
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `dateyyyymmddWithDashesToyyyymmdd`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;




set @errorIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(",srcField,", '%Y-%m-%d') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

if (@errorIds is not null) then

begin

set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;


set @stmt = concat("update ",@translatedTable, " set ",srcField," = str_to_date(",srcField,", '%Y-%m-%d') where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 	
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
      

set @errorIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(",srcField,") is null
					and ",srcField," is not null and length(",srcField,") > 0  and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


if (@errorIds is not null) then

begin

set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;

set @errorIds = '';


set @stmt = concat("update ",@translatedTable, " set ",srcField," =  replace(",srcField,", '-', '')
where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") 
");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `errorNonYearMonthTransactions`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin



call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @translateCol;


call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

set @whereClause = concat(" and  configId = ",configId," and ", @batchIdColumn," = ",batchId," and statusId not in (",@finalStatusIds ,") ");

set @totalCount1 = 0;
set @yearMonthToUse1 = 0;

set @stmt = concat("select count(*) totalCount, 
DATE_FORMAT(",srcField,",'%Y%m') monthYearForFile from ",@translatedTable," where ",srcField," is not null ", @whereClause,"
group by 
DATE_FORMAT(",srcField,",'%Y%m')
order by totalCount desc limit 0, 1 into @totalCount1, @yearMonthToUse1
;");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

set @totalCount2 = 0;
set @yearMonthToUse2 = 0;

set @stmt = concat("select count(*) totalCount, 
DATE_FORMAT(",srcField,",'%Y%m') monthYearForFile from ",@translatedTable," where ",srcField," is not null ", @whereClause,"
group by 
DATE_FORMAT(",srcField,",'%Y%m')
order by totalCount desc limit 1, 1 into @totalCount2, @yearMonthToUse2
;");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


set @stmt = concat("select fieldDesc from configurationformfields where configId = ",configId," 
and fieldNo = replace('",srcField,"', 'F', '') 
into @fieldLabel;");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;



if (@totalCount1 = @totalCount2) then
 
	BEGIN
			set @stmt = concat("insert into ", @errorTable , " (" , @batchIdColumn, ", configId, " , @translateCol, 
			", fieldNo, errorId, macroId, stackTrace, required, fieldLabel, fieldValue) select ",batchId,", ",configId,", ",@translateCol, ", replace('",srcField,"', 'F', ''), ", 8, 
			", ",macroId, ", 'Macro errorNonYearMonthTransactions - Could not determine which date to use:  "  "Year Month - ",@yearMonthToUse1, " and ",@yearMonthToUse2," have the same numbers of transactions - ",@totalCount1, "'",
            ", true, '",@fieldLabel,"', ",srcField," from ", @translatedTable, " where ",
			srcField," is not null and length(",srcField,") > 0 ", @whereClause, ";");
            
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
        set @stmt = concat("update ",@translatedTable, " set statusId = 14 where ",
			srcField," is not null and length(",srcField,") > 0 ", @whereClause, ";");
            
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
        
	END;
end if;
			if (@totalCount1 > @totalCount2) then
				BEGIN
                
					
					set @stmt = concat("insert into ", @errorTable , " (" , @batchIdColumn, ", configId, " , @translateCol, 
					", fieldNo, errorId, macroId, stacktrace, required,fieldLabel, fieldValue) select ",batchId,", ",configId,", ", @translateCol, ", replace('",srcField,"', 'F', ''), 60,",
                    macroId,", concat('Year and month of ', DATE_FORMAT(",srcField,",'%Y%m'), ' for ',",srcField,", ' does not match year and month ',",@yearMonthToUse1,",' used for processing.')
                    , true, '",@fieldLabel,"', ",srcField,"  from ", @translatedTable, " where ",
					srcField," is not null and length(",srcField,") > 0 ",
                    " and DATE_FORMAT(",srcField,",'%Y%m') != ", @yearMonthToUse1, " ", 
                    @whereClause, ";");
					
                    PREPARE stmt from @stmt;
					EXECUTE stmt;
					DEALLOCATE PREPARE stmt;
                    
                    set @stmt = concat("update ",@translatedTable, " set statusId = 14 where ",
					srcField," is not null and length(",srcField,") > 0 ",
                    " and DATE_FORMAT(",srcField,",'%Y%m') != ", @yearMonthToUse1, " ", 
                    @whereClause, ";");
                    
					PREPARE stmt from @stmt;
					EXECUTE stmt;
					DEALLOCATE PREPARE stmt;
                
                END;
		end if;


end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `futureDateCheck`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

set @stmt = concat("select group_concat(id) from " , @translatedTable, " where
 ((Date(",srcField,") is null and length(",srcField,") > 0)
 or (curdate() >= ", srcField , " = 0))
 and  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

if (@errorIds is not null) then
	begin
		set @stmt = concat("update " , @translatedTable, "  set forCW = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
	end;
end if;

set @errorIds = '';


end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `getConfigToFromFieldNo`(in cInId int, in cOutId int)
proc_main:begin

drop TEMPORARY TABLE if exists fieldAndNos;

CREATE TEMPORARY TABLE fieldAndNos as (select id, cOutId as configIdOut, cInId as configIdIn, 
fieldNo as fieldNoIn, fieldNo as fieldNoOut, saveToTableName, saveToTableCol from configurationFormFields where configId = cOutId order by fieldNoOut);

update fieldAndNos set fieldNoIn = 0;

BEGIN
 
    DECLARE v_finished INTEGER DEFAULT 0;
	DECLARE v_saveToTableName varchar(100) DEFAULT "";
	DECLARE v_saveToTableCol varchar(100) DEFAULT "";
	DECLARE v_fieldNoIn int DEFAULT 0;
	DECLARE v_fieldNoOut int DEFAULT 0;
	DECLARE v_newFieldNo int DEFAULT 0;
	DECLARE v_id int default 0;

 
    
    DEClARE fieldNo_cursor CURSOR FOR 
        SELECT id, fieldNoIn, fieldNoOut, saveToTableName, saveToTableCol from fieldAndNos order by fieldNoOut;

    
    DECLARE CONTINUE HANDLER 
        FOR NOT FOUND SET v_finished = 1;
	
    OPEN fieldNo_cursor;
	
	get_fieldNo: LOOP
		
		
        
		FETCH fieldNo_cursor INTO v_id, v_fieldNoIn, v_fieldNoOut, v_saveToTableName, v_saveToTableCol;
 
        IF v_finished = 1 THEN 
            LEAVE get_fieldNo;
        END IF;
	
	
        
	if  (v_id > 1) then
		set v_newFieldNo = 0;
		
		select count(fieldNo) into v_newFieldNo from configurationFormFields where configId = cInId 
		and saveToTableName = v_saveToTableName and saveToTableCol = v_saveToTableCol order by fieldNo limit 1;
		
		if (v_newFieldNo > 0) then
			select fieldNo into v_newFieldNo from configurationFormFields where configId = cInId 
			and saveToTableName = v_saveToTableName and saveToTableCol = v_saveToTableCol order by fieldNo limit 1;
			update fieldAndNos set fieldNoIn = v_newFieldNo where id = v_id;
		end if; 
		
		
		
	end if;
	
    END LOOP get_fieldNo;
 
    CLOSE fieldNo_cursor;

	
END;

select * from fieldAndNos order by fieldNoOut;
end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `getFinalStatusIds`()
proc_main:begin

set @finalStatusIds =  '11,12,13,16,18,20,40';


end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `getJSONForConfig`(in inConfigId int, 
in inBatchDLId int, in inFilePathAndName varchar(500), in inJSONWrapperElement varchar(55))
proc_main:begin

SET @@group_concat_max_len = 999999999;


set @whereClause = '';

set @cleanStmt = concat('delete from transactionoutjsontable_',inBatchDLId,' where configId = ', inConfigId);

PREPARE stmt from @cleanStmt;
EXECUTE stmt;

select group_concat(concat('''"', fieldlabel, '":'', ', concat('case when trim(F', fieldNo), ') is null then ''"",'' else concat(''"'', trim(replace(replace(replace(F',fieldNo, ',"\r",""),"\n",""),"\"""," ")), ''",'') end')) 
from configurationformfields where configId = inConfigId and usefield = 1 order by fieldNo into @selectValues;

set @stmt = concat("insert into transactionoutjsontable_",inBatchDLId," (batchDownloadId, configId, transactionOutRecordsId, jsonString) 
select batchId, configId, transactionOutRecordsId, replace(replace(concat('{', ",@selectValues,", '}'), ',},', '},'), ',}', '},')  
from transactiontranslatedout_",inBatchDLId," where configId = ", inConfigId, @whereClause);
PREPARE stmt from @stmt;
EXECUTE stmt;

if(inJSONWrapperElement != '') then
	
	set @stmt = concat("update transactionoutjsontable_",inBatchDLId," join (
	select min(id) theId from transactionoutjsontable_",inBatchDLId," where configId = ", inConfigId, @whereClause, ") getId
	on transactionoutjsontable_",inBatchDLId,".id = getId.theId
	set jsonString = concat('{\"",inJSONWrapperElement,"\":[' , jsonString) 
	where configId = ", inConfigId, @whereClause, "");

end if;

PREPARE stmt from @stmt;
EXECUTE stmt;

if(inJSONWrapperElement != '') then

	set @stmt = concat("update transactionoutjsontable_",inBatchDLId," join (
	select max(id) theId from transactionoutjsontable_",inBatchDLId," where configId = ", inConfigId, @whereClause, ") getId
	on transactionoutjsontable_",inBatchDLId,".id = getId.theId
	set jsonString = concat(replace(jsonString, '},','}'), ']}') 
	where configId = ", inConfigId, @whereClause, "");

end if;

PREPARE stmt from @stmt;
EXECUTE stmt;


set @stmt = concat("select jsonString from transactionoutjsontable_",inBatchDLId," where configId = ", inConfigId, @whereClause, 
" order by Id INTO OUTFILE '", inFilePathAndName, "';");

PREPARE stmt from @stmt;
EXECUTE stmt;


PREPARE stmt from @cleanStmt;
EXECUTE stmt;

 
end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `IfFACon1AndSFBlankSetSFToCon2`(in configId int,
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255),
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

	call setInboundOutBoundTables (foroutboundProcessing,batchId);
	select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
	into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

	call getFinalStatusIds;
	select @finalStatusIds into @finalStatusIds;

	set @stmt = concat("update ",@translatedTable, " set ",srcField," = '",con2, "' where " ,fieldA, " = '",con1, "' and length(",srcField,") = 0 and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");

	PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `IfFieldACon1andSFBlankInsertError`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

	call setInboundOutBoundTables (foroutboundProcessing,batchId);
	SELECT 
		@translatedTable,
		@transactionTable,
		@batchTable,
		@batchIdType,
		@errorTable,
		@translateCol
	INTO @translatedTable , @transactionTable , @batchTable , @batchIdType , @errorTable, @translateCol;

	call getFinalStatusIds;
	SELECT @finalStatusIds INTO @finalStatusIds;

		set @whereString = concat("  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");

		set @stmt = concat("select fieldDesc from configurationformfields where configId = ",configId," and fieldNo = replace('",srcField,"', 'F', '') into @fieldDesc;");
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

		
		set @stmt = concat("insert into ", @errorTable , " (" , @batchIdColumn, ", configId, " , @translateCol, 
		", fieldNo, errorId, macroId, fieldValue, required, stackTrace, fieldLabel) select ",@batchIdType,", configId, id, replace('",srcField,"', 'F', ''), ", 58, 
	   ", ",macroId,",case when ",srcField," is null then '' else ",srcField," end, true, 'A value is required if \"",@fieldDesc,"\" is value \"",con1, "\"', '",@fieldDesc,"' from ", @translatedTable, 
       " where ",fieldA,"  = '",con1,"' and (",srcField," is null 
       or length(REPLACE(REPLACE(", srcField, ", ""\n"", """"), ""\r"", """")) = 0) and ", 
		@whereString);
		
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
    
		set @stmt = concat("update ", @translatedTable, " set statusId = 14 
        where  ",fieldA,"  = '",con1,"' and (",srcField," is null 
        or length(REPLACE(REPLACE(", srcField, ", ""\n"", """"), ""\r"", """")) = 0) and ", 
		@whereString);
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `IfFieldsBlankThenError`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
SELECT 
    @translatedTable,
    @transactionTable,
    @batchTable,
    @batchIdType,
    @errorTable,
    @translateCol
INTO @translatedTable , @transactionTable , @batchTable , @batchIdType , @errorTable, @translateCol;

call getFinalStatusIds;
SELECT @finalStatusIds INTO @finalStatusIds;

set @errorCode='51';

	set @whereString = concat("  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");


	set @sqlConstraintS = concat(" (",srcField," is null or length(",srcField,") = 0)");
    set @sqlConstraintA = "";
    set @sqlConstraintB = "";
    set @fieldAName = '';
    set @fieldBName = '';
    
	set @stmt = concat("select fieldDesc into @fieldName from configurationformfields where configId = ",configId," and fieldNo = replace('",srcField,"', 'F', '') limit 1;");

	PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    
    if (fieldA != 'F') then 
		 set @sqlConstraintA = concat(" and  (",fieldA," is null or length(",fieldA,") = 0)");
         set @stmt = concat("select concat(', ', fieldDesc) into @fieldAName from configurationformfields where configId = ",configId," and fieldNo = replace('",fieldA,"', 'F', '') limit 1;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
         
    end if;
    
    if (fieldB != 'F') then 
		 set @sqlConstraintB = concat(" and  (",fieldB," is null or length(",fieldB,") = 0)");
         set @stmt = concat("select concat(', ', fieldDesc) into @fieldBName from configurationformfields where configId = ",configId," and fieldNo = replace('",fieldB,"', 'F', '') limit 1;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
         
    end if;
    
    set @stmt = concat("insert into ", @errorTable , " (" , @batchIdColumn, ", configId, " , @translateCol, 
    ", fieldNo, errorId, macroId, fieldValue, required, fieldLabel, stackTrace) select ",@batchIdType,", configId, id, replace('",srcField,"', 'F', ''), ", @errorCode, 
    ", ",macroId,",'', true, '",@fieldName,"', 'IfFieldsBlankThenError - Field(s) ",@fieldName, @fieldAName, @fieldBName," cannot all be blank.'  
    from ", @translatedTable, "  where",@sqlConstraintS,@sqlConstraintA, @sqlConstraintB, "  and ", 
    @whereString);
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    set @stmt = concat("update ",@translatedTable," set statusId = 14  where",@sqlConstraintS,@sqlConstraintA, @sqlConstraintB, "  and ", 
    @whereString);
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
     
     
end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `IfLengthNotCon1ReplaceWithCon2`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

/** con1 must be numeric **/
				if (con1 REGEXP '^[]?[0-9]*[]{0,1}[0-9]*$' = 0 || length(@con1) = 0 ) then

							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'IfLengthNotCon1ReplaceWithCon2 Macro - Con1 - ",con1," must be an integer. '",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;


leave proc_main;

end if;

set @whereClause = '';
if (con1 != 0) then
	set @whereClause = concat(" or ", srcField," is null");
end if;

set @stmt = concat(
"update ", @translatedTable," set ",srcField, " = '", con2,"' where (length(",srcField,") != ",con1, @whereClause, ") and 
configId = ",configId," and ",@batchIdType," = ",batchId," and statusId not in (",@finalStatusIds,");");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `ifNotBlankError`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

	call setInboundOutBoundTables (foroutboundProcessing,batchId);
	select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn
	into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn;

	call getFinalStatusIds;
	select @finalStatusIds into @finalStatusIds;

    set @stmt = concat("update  ", @translatedTable , " set forcw = 'MACRO_ERROR' where ",
    srcField," is not null and length(",srcField,") > 0 ",
    " and  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");

	PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `ifNotNumericSetToCon1`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


	set @whereclause = concat(" and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");

	set @dropTable = "batchuploaddroppedvalues";
	set @colDirection = "in";

	if (foroutboundProcessing) then

		set @dropTable = "batchdownloaddroppedvalues";
		set @colDirection = "out";
		
	end if;

	-- track values being replaced
	set @stmt = concat("select fieldDesc into @fieldName from configurationformfields where configId = ",configId," and fieldNo = replace('",srcField,"', 'F', '') limit 1;");

	PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

	set @stmt1 = concat("
    insert into ",@dropTable,"
    (transaction",@colDirection,"RecordsId, fieldNo, ",@batchIdType ,", configId, fieldName, fieldValue) 
     select transaction",@colDirection,"RecordsId, replace('",srcField,"', 'F', ''), ",@batchIdType,", configId, '",@fieldName,"', ",srcField,"
     from ",@translatedTable, " where  ",srcField ," REGEXP  '^-?[0-9]+[.]?[0-9]*$|^-?[.][0-9]+$' = 0 
     and ",srcField," is not null and length(",srcField,") > 0 ");
		
	set @stmt = concat(@stmt1, @whereclause, ";");
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
    

	set @stmt1 = concat("update ",@translatedTable, " set ",srcField, " = '", con1 , "' where  
    ",srcField ," REGEXP  '^-?[0-9]+[.]?[0-9]*$|^-?[.][0-9]+$' = 0 
    and ",srcField," is not null and length(",srcField,") > 0 ");
	
    set @stmt = concat(@stmt1, @whereclause, ";");
     
	PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `IfSFBlankSetToFA`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


	set @stmt = concat("update ",@translatedTable, " set ",srcField," = ",fieldA, " 
     where (length(",srcField, ") = 0 or ", srcField ," is null) and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") ");
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;


end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `IfSFMatchCon1SetFAtoFB`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

	call setInboundOutBoundTables (foroutboundProcessing,batchId);
	select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
	into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

	call getFinalStatusIds;
	select @finalStatusIds into @finalStatusIds;

	set @stmt = concat("update ",@translatedTable, " set ",fieldA," = ",fieldB, " 
     where " ,srcField, " = '",con1, "' and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");

	PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;


end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `ifSFMatchCon1ThenCon2ElseClear`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set ",srcField, " = case when ", srcField, " = '",con1,"' then '", con2 , "' else '' end",
		" where  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");
		
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `ifSFNotCon1ThenClear`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

	set @stmt = concat("update ",@translatedTable, " set ",srcField, " = '' ",
				" where  ",srcField," != '",con1,"' and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `ifStartsWithCon1UpdateToCon2`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


	set @stmt = concat("update ",@translatedTable, " set ",srcField, " = '", con2, "'    where left(",srcField,", ", length(con1), ") = '",con1,"' ",
				" and  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    if (length(con1) = 0) then
		set @stmt = concat("update ",@translatedTable, " set ",srcField," = '",con2,"' where (",srcField," is null or ",srcField," = '')
		and  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (", @finalStatusIds, ");");

	PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt; 

end if;
    

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `ifValueNotInListValuesSetToCon2`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

/** cwId con1 must be numeric **/
if (con1 REGEXP '^[]?[0-9]*[]{0,1}[0-9]*$' = 0 || length(@con1) = 0 || con1 < 1) then

							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'ifValueNotInListValuesSetToCon2 Macro - Con1 - ",con1," must be an integer greater than 0. '",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;


leave proc_main;

end if;


set @leaveBlanks = "";


set @dropTable = "batchuploaddroppedvalues";
set @colDirection = "in";

if (foroutboundProcessing) then

	set @dropTable = "batchdownloaddroppedvalues";
	set @colDirection = "out";
    
end if;

	set @stmt = concat("select fieldDesc into @fieldName from configurationformfields where configId = ",configId," and fieldNo = replace('",srcField,"', 'F', '') limit 1;");

	PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

	set @stmt1 = concat("
    insert into ",@dropTable,"
    (transaction",@colDirection,"RecordsId, fieldNo, ",@batchIdType ,", configId, fieldName, fieldValue) 
     select transaction",@colDirection,"RecordsId, replace('",srcField,"', 'F', ''), ",@batchIdType,", configId, '",@fieldName,"', ",srcField,"
     from ",@translatedTable," where   ",srcField," is not null and length(",srcField,") != 0 and 
    ",srcField ," not in (select sourcevalue from rel_crosswalkdata where crosswalkId = ",con1,")  ",@leaveBlanks,"
    and  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");
    
	set @stmt = concat("update ",@translatedTable, " set ", srcField, " = '",con2,"' where   ",srcField," is not null and length(",srcField,") != 0 and 
    ",srcField ," not in (select sourcevalue from rel_crosswalkdata where crosswalkId = ",con1,")  ",@leaveBlanks,"
    and  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");
	
	
	PREPARE stmt1 from @stmt1;
	EXECUTE stmt1;
    DEALLOCATE PREPARE stmt1;
   
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;


end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `insertValidationErrors`(in vtType int, in fieldNo int,
in batchUploadId int, in configId int, in transactionId int, in isFieldRequired boolean)
BEGIN

DECLARE regEx varchar(100) DEFAULT '';

CASE vtType
	WHEN 2 THEN 
		set regEx = '^[A-Z0-9._%-]+@[A-Z0-9.-]+\.[A-Z]{2,4}$';
    WHEN 3 THEN 
		BEGIN 
			CALL `stripPhoneChars`(vtType, fieldNo, batchUploadId, configId, transactionId);
			set regEx ='^[0-9]{7,11}$';
		END;
	WHEN 4 THEN
		
        set regEx = '^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])';
	WHEN 5 THEN 
		set regEx = '^-?[0-9]+[.]?[0-9]*$|^-?[.][0-9]+$';
	WHEN 6 THEN
		set regEx = '^(?:http(s)?:\/\/)?[\w.-]+(?:\.[\w\.-]+)+[\w\-\._~:/?#[\]@!\$&\'\(\)\*\+,;=.]+$';
     WHEN 7 THEN
        set regEx = '^[0-9]{4}(0[1-9]|1[0-2])(0[1-9]|[1-2][0-9]|3[0-1])';       
    ELSE
        BEGIN
        END;
	END 
	CASE;

IF (transactionId = 0) THEN
set @stmt = concat(
'insert into transactioninerrors_',batchUploadId,' (batchUploadId, transactionInRecordsId, fieldNo, required, fieldValue, errorid, configId,
validationTypeId) SELECT ', batchUploadId, ', transactionInRecordsId, ',fieldNo,',',isFieldRequired,concat(',F',fieldNo),',2, ',configId, ',' , vtType,'  
 FROM transactiontranslatedin_',batchUploadId,' WHERE trim(F' ,fieldNo, ') not REGEXP  "', regEx, '" and F',fieldNo, ' is not null 
and length(F', fieldNo, ') != 0
and length(trim(F', fieldNo, ')) != 0
and length(REPLACE(REPLACE(F', fieldNo,' , "\n", ""), "\r", "") != 0)  
and  configId = ', configId,' and statusId not in (11,12,13,16,20);'
);



BEGIN 
		PREPARE stmt from @stmt;
		EXECUTE stmt;
END; 
END IF;


END$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `insertValidationErrorsOutbound`(in vtType int, in fieldNo int,
in batchDownloadId int, in configId int, in transactionId int, in isFieldRequired boolean)
BEGIN

DECLARE regEx varchar(100) DEFAULT '';

CASE vtType
	WHEN 2 THEN 
		set regEx = '^[A-Z0-9._%-]+@[A-Z0-9.-]+\.[A-Z]{2,4}$';
    WHEN 3 THEN 
		BEGIN 
			CALL `stripPhoneCharsOutbound`(vtType, fieldNo, batchDownloadId, configId, transactionId);
			set regEx ='^[0-9]{7,11}$';
		END;
	WHEN 4 THEN
		
         set regEx = '^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])';
	WHEN 5 THEN 
		set regEx = '^-?[0-9]+[.]?[0-9]*$|^-?[.][0-9]+$';
	WHEN 6 THEN
		set regEx = '^(?:http(s)?:\/\/)?[\w.-]+(?:\.[\w\.-]+)+[\w\-\._~:/?#[\]@!\$&\'\(\)\*\+,;=.]+$';
    WHEN 7 THEN
         set regEx = '^[0-9]{4}(0[1-9]|1[0-2])(0[1-9]|[1-2][0-9]|3[0-1])';    
    ELSE
        BEGIN
        END;
	END 
	CASE; 

IF (transactionId = 0) THEN
set @stmt = concat(
'insert into transactionouterrors_',batchDownloadId,' (batchDownloadId, transactionOutRecordsId, fieldNo, required, fieldValue, errorid, configId,
validationTypeId) SELECT ', batchDownloadId, ', transactionOutRecordsId, ',fieldNo,',',isFieldRequired,concat(',F',fieldNo),',2, ',configId, ',' , vtType,'  
 FROM transactiontranslatedout_',batchDownloadId,' WHERE trim(F' ,fieldNo, ') not REGEXP  "', regEx, '" and F',fieldNo, ' is not null 
and length(F', fieldNo, ') != 0
and length(trim(F', fieldNo, ')) != 0
and length(REPLACE(REPLACE(F', fieldNo,' , "\n", ""), "\r", "") != 0)  
and  configId = ', configId,' and statusId not in (11,12,13,16,18,20);'
);

BEGIN 
		PREPARE stmt from @stmt;
		EXECUTE stmt;
END; 
END IF;

IF (transactionId != 0) THEN

set @stmt= concat(
'insert into transactionouterrors_',batchDownloadId,' (batchDownloadId, transactionOutRecordsId, fieldNo, errorid, configId, 
validationTypeId) SELECT ', batchDownloadId, ', transactionOutRecordsId, ',fieldNo,',2, ', configId, ',', vtType,'  
 FROM transactiontranslatedout_',batchDownloadId,' WHERE trim(F' ,fieldNo, ') not REGEXP  "', regEx, '" and F',fieldNo, ' is not null 
and length(F', fieldNO, ') != 0
and length(trim(F', fieldNO, ')) != 0
and length(REPLACE(REPLACE(F', fieldNO,', "\n", ""), "\r", "") != 0) and configId = ', configId, ' and transactionTargetId 
 = ', transactionId, ';'
);

BEGIN 
		PREPARE stmt from @stmt;
		EXECUTE stmt;


END; 
END IF;

 
END$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `KeepTopRanked`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin 


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @listTable, @translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @listTable, @translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

/** make sure con1 is numeric **/
/** con1 must be numeric and greater than 1 **/

				if (con1 REGEXP '^[]?[0-9]*[]{0,1}[0-9]*$' = 0 || length(@con1) = 0 || con1 < 1) then

							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'KeepTopRanked Macro - Crosswalk Id - ",con1," must be an integer greater than 0. '",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;


leave proc_main;

end if;

set @stmt = concat("
		SELECT max(CHAR_LENGTH(",srcField,") - CHAR_LENGTH( REPLACE ( ",srcField,", ',', '') )  + 1) from ",@translatedTable, " into @maxListLength");
		
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
         
        if (@maxListLength is null) then
			set @maxListLength = 108;
        end if;


set @whereString = concat(" and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");

set @fcol = replace(lcase(srcField), 'f', '');
set @stmt = concat("truncate table ", @listTable);

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

	set @stmt = concat("
    insert into ", @listTable," (",@batchIdType,", ",@translateCol,", invalue, fcol)
    SELECT ",@batchIdType,", ",@translateCol,", trim(SUBSTRING_INDEX(SUBSTRING_INDEX(t.",srcField,", ',', n.n), ',', -1)) value, ",@fcol,"
    FROM ",@translatedTable ," t CROSS JOIN (
    SELECT a.N + b.N * 10 + 1 n FROM  
   (select id N from ref_numbers where id <= ",@maxListLength,") a
   ,(select id N from ref_numbers where id <= ",@maxListLength,") b
    ORDER BY n) n  WHERE n.n <= 1 + (LENGTH(t.",srcField,") - LENGTH(REPLACE(t.",srcField,", ',', ''))) ", @whereString);
    

    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
     
    -- we delete the single values from top rank look up 
     set @stmt = concat("
		delete t1 from  ", @listTable," t1 join (
	   select t1.",@translateCol," from ", @listTable," t1 join (
	   select count(",@translateCol,") recordCount, ",@translateCol,"
	   from ", @listTable," group by ",@translateCol,"
	   order by recordCount) t2 on 
	   t1.",@translateCol," = t2.",@translateCol,"
	   where recordCount = 1) t2 
	   on t1.",@translateCol," = t2.",@translateCol,";");
   
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
     
	set @stmt = concat("update ",@listTable," set invalue = replace(replace(invalue, '\n',''), '\r', '')");
	 
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    -- we need to keep all the values that are not part of top ranked cw
	set @stmt = concat("update ",@listTable," join (select id, sourcevalue, targetvalue from rel_crosswalkdata where crosswalkid = ", con1 ,") cwdata
	on invalue = sourcevalue set translatedvalue = targetvalue where ",@batchIdType," = ", batchId);
  
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    set @stmt = concat("ALTER TABLE ",@listTable," ADD COLUMN topRankedValue TEXT NULL AFTER fCol;");
  
	PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
	set @selDistinct = ' distinct ';
    
    set @stmt = concat("update ",@listTable," join  (
		SELECT tt.",@translateCol," as matchId,  invalue label
		FROM ",@listTable," tt
		INNER JOIN
		(SELECT ",@translateCol,", min(CONVERT(translatedValue,UNSIGNED INTEGER) ) AS topRanked
		FROM ",@listTable," 
		where ",@batchIdType," = ",batchid," and fcol = ",@fCol," 
		GROUP BY ",@translateCol," order by ",@translateCol,") groupedtt 
		ON tt.",@translateCol," = groupedtt.",@translateCol," 
		AND tt.translatedValue = groupedtt.topRanked
		where ",@batchIdType," = ",batchid," and fcol = ",@fCol," 
		order by tt.",@translateCol,"
	   ) cwmatch on ",@translateCol," = matchid set  toprankedvalue = label 
	   where label is not null
	   ");
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    set @stmt = concat("update ",@listTable," set toprankedvalue = invalue where translatedValue is null;");
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    set @stmt = concat("update ",@listTable," set toprankedvalue = null where invalue != toprankedvalue;");
	
	PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
   
    -- update the translated with topranked value order by the original list order
    
    set @stmt = concat("
		   update ",@translatedTable ," table1 join (
		   select ",@translateCol," , 
		   group_concat(toprankedvalue order by id) label
		   from ",@listTable,"
		   where topRankedValue is not null 
		   group by ",@translateCol," 
		   order by ",@translateCol," ) table2
		   on table1.",@translateCol,"  = table2.",@translateCol," 
		   set table1.",srcField," = table2.label;");
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    /** track dropped values , we only drop values that are part of the cw **/
    set @colText = "in";
    if (foroutboundProcessing) then
		set @colText = "out";
    end if;
    
	
    set @stmt = concat("
			insert into transaction",@colText,"macrodroppedvalues_",batchId," (",@batchIdColumn ,", transaction",@colText,"RecordsId, fieldNo, fieldValue, matchId, configId) 
			select distinct ",batchId,", transaction",@colText,"RecordsId, fcol, invalue,concat('keepTopRanked_',",configId,", '_', fcol, '_', invalue), ",configId," from transactiontranslatedlist",@colText,"_",batchId," 
            where toprankedvalue is null;
	");
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
    
    
    set @stmt = concat("truncate table ", @listTable);
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    set @stmt = concat("ALTER TABLE ",@listTable," DROP COLUMN topRankedValue;");
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `MatchFAtoCon1UpdateSFtoCon2`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


set @stmt = concat("update ",@translatedTable, " set ",srcField," = '",con2,"' where trim(REPLACE(CONVERT(",fieldA," USING ASCII), '?','')) = '",con1,"'
and  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (", @finalStatusIds, ");");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt; 

if (length(con1) = 0) then
	set @stmt = concat("update ",@translatedTable, " set ",srcField," = '",con2,"' where (",fieldA," is null or ",fieldA," = '')
	and  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (", @finalStatusIds, ");");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt; 

end if;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `mergeTransactions`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


set @con1 = concat('F', con1);
set @con2 = concat('F', con2);


set @stmt = concat("update ",@translatedTable," set forcw = concat_ws('', ",fieldA,", '_', ",fieldB,", '_', ",@con1,");");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;  


set @stmt = concat("update ",@translatedTable," tt 
join  (select group_concat(",@con2,") mser, forcw from ",@translatedTable," group by forcw)  ms on ms.forcw = tt.forcw set ",@con2," =ms.mser;");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt; 


set @stmt = concat("delete table1 from    ",@translatedTable," table1  left join (SELECT id as idsToKeep FROM ",@translatedTable," tt
						INNER JOIN (SELECT forcw, min(id) AS keepId FROM ",@translatedTable,"  GROUP BY forcw) groupedtt 
						ON tt.forcw = groupedtt.forcw  AND tt.id = groupedtt.keepId ) keepIds
                        on keepIds.idsToKeep = table1.id where idsToKeep is null;
                        ");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt; 


end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `mergeValues`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

set @con1 = concat('F', con1);
set @con2 = concat('F', con2);


set @stmt = concat("update ",@translatedTable," set forcw = concat_ws('', ",fieldA,", '_', ",fieldB,", '_', ",@con1,");");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;  


set @stmt = concat("update ",@translatedTable," tt 
join  (select group_concat(",@con2,") mser, forcw from ",@translatedTable," group by forcw)  ms on ms.forcw = tt.forcw set ",@con2," =ms.mser;");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt; 


end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `NumericRange`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
SELECT 
    @translatedTable,
    @transactionTable,
    @batchTable,
    @batchIdType,
    @errorTable,
    @translateCol
INTO @translatedTable , @transactionTable , @batchTable , @batchIdType , @errorTable, @translateCol;

call getFinalStatusIds;
SELECT @finalStatusIds INTO @finalStatusIds;

set @startRange = con1;
set @endRange = con2;


/** make sure start range, end range and con1 ( ) are all numeric **/
		if ( 
		@startRange REGEXP '^[+-]?[0-9]*[.]{0,1}[0-9]*$' = 0 ||
		@endRange REGEXP '^[+-]?[0-9]*[.]{0,1}[0-9]*$' = 0 ||
		length(@startRange) = 0 || length(@endRange) = 0
		) then

							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'NumericRange Macro - One of these is not a valid value.  Start Range - ",@startRange," or End Range - ",@endRange,". '",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;


leave proc_main;

end if;



	set @whereStmt =  concat("and ",srcField ," is not null and length(",srcField,") > 0 and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");
	

	-- error out all non numeric values transactions
    set @stmt = concat("update  ", @translatedTable , " set forcw = 'MACRO_ERROR' where ",srcField," REGEXP '^[+-]?[0-9]*[.]{0,1}[0-9]*$' = 0 "
    , @whereStmt);
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;
      
    /**
    now we compare if value is between startRange and endRange, we insert error if it is not **/
    set @stmt = concat("update  ", @translatedTable , " set forcw ='MACRO_ERROR'
    where ",srcField," not between ",@startRange," and ", @endRange,
    " and (forcw is null or forcw != 'MACRO_ERROR') ", @whereStmt);
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;

    
    
end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `overwriteSF`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

	call setInboundOutBoundTables (foroutboundProcessing,batchId);
	select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
	into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

	call getFinalStatusIds;
	select @finalStatusIds into @finalStatusIds;

	 set @stmt = concat("update ",@translatedTable, " set ",srcField," = '",con1, "' 
     where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");

	PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `overwriteSFWithRandomNumber`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

begin
	set @_rc = cast(FLOOR(1000000000 + (RAND() * 8999999999)) AS char);            
end; 

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

	set @stmt = concat("update ",@translatedTable, " set ",srcField," = '",@_rc, "' 
    where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");
	 
	PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `pastDateCheck`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;


call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


-- check to make sure con1 is a numeric value
 if con1 REGEXP '^-?[0-9]+[.]?[0-9]*$|^-?[.][0-9]+$' = 0 then 
					begin
			
							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, fieldValue, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'pastDateCheck Con1 - \"",con1,"\"  must be numeric value'",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							 
                             PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
           
			leave proc_main;
        end;
      end if;


	-- we expect 4 digit years
	set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 	
                    and substring(",srcField,",5,1) != '-'
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


set @errorIds = '';

set @stmt = concat("select group_concat(id) from " , @translatedTable, " where
length(",srcField,") > 0 and  ",srcField," is not null  
 and (",srcField," >= curdate() - interval ",con1," month  = 0  or  Date(",srcField,") is null)
 and  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

if (@errorIds is not null) then

	begin

		set @stmt = concat("update " , @translatedTable, "  set forCW = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
	end;
end if;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `populateAuditReport`(in inConfigId int, in inBatchId int)
proc_main:begin


SET @stmt = CONCAT('truncate table  transactionindetailauditerrors_',inBatchId);
PREPARE stmt from @stmt;
EXECUTE stmt;

SELECT concat('F',rptField1),concat('F',rptField2),concat('F',rptField3),concat('F',rptField4) INTO @rptField1, @rptField2,@rptField3,@rptField4 
FROM configurationmessagespecs where configId = inConfigId LIMIT 1;

if(@rptField1 = 'F0') then 
	set @rptField1 = "F1";
end if;

if(@rptField2 = 'F0') then 
	set @rptField2 = "F2";
end if;

if(@rptField3 = 'F0') then 
	set @rptField3 = "F3";
end if;

if(@rptField4 = 'F0') then 
	set @rptField4 = "F4";
end if;


SET @stmt = CONCAT('insert into transactionindetailauditerrors_',inBatchId,' 
(required, batchUploadId, configId, transactionInRecordsId, fieldNo, errorId, transactionInErrorId,errorData, reportField1Data, reportField2Data, reportField3Data, reportField4Data)
select a.required, a.batchUploadId,a.configId,a.transactionInRecordsId,a.fieldno,a.errorId,a.id,a.fieldValue,b.',@rptField1,',b.',@rptField2,',b.',@rptField3,',b.',@rptField4,'
from transactioninerrors_',inBatchId,' a inner join 
transactioninrecords_',inBatchId,' b on a.transactionInRecordsId = b.id
where a.configId = ',inConfigId);

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


SET @stmt = CONCAT('UPDATE transactionIndetailauditerrors_',inBatchId,' JOIN (select distinct fieldNo matchid, macro_Name as label 
from macro_names, transactioninerrors_',inBatchId,' where macro_Names.id = transactioninerrors_',inBatchId,'.macroId) tbl_concat
     ON transactionIndetailauditerrors_',inBatchId,'.fieldNo = tbl_concat.matchid
SET transactionIndetailauditerrors_',inBatchId,'.errorDetails = tbl_concat.label WHERE errorId = 4');


PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


SET @stmt = CONCAT('UPDATE transactionindetailauditerrors_',inBatchId,'
  JOIN (select distinct fieldNo matchid, name as label 
from crosswalks, transactioninerrors_',inBatchId,' where crosswalks.id = transactioninerrors_',inBatchId,'.cwId) tbl_concat
     ON transactionIndetailauditerrors_',inBatchId,'.fieldNo = tbl_concat.matchid
SET transactionIndetailauditerrors_',inBatchId,'.errorDetails = tbl_concat.label WHERE errorId = 3');


PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

SET @stmt = CONCAT('UPDATE transactionIndetailauditerrors_',inBatchId,'
  JOIN (select distinct fieldNo matchid, validationType as label 
from ref_validationtypes, transactioninerrors_',inBatchId,' where ref_validationtypes.id = transactioninerrors_',inBatchId,'.validationTypeId) tbl_concat
     ON transactionIndetailauditerrors_',inBatchId,'.fieldNo = tbl_concat.matchid
SET transactionIndetailauditerrors_',inBatchId,'.errorDetails = tbl_concat.label WHERE errorId = 2');


PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


SET @stmt = CONCAT('UPDATE transactionIndetailauditerrors_',inBatchId,'
  JOIN (select distinct fieldNo as matchid, fieldDesc as label from configurationformfields where configId = ',inConfigId,') tbl_concat
     ON transactionIndetailauditerrors_',inBatchId,'.fieldNo = tbl_concat.matchid
SET transactionIndetailauditerrors_',inBatchId,'.fieldName = tbl_concat.label');


PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


SET @stmt = CONCAT('insert into transactionindetailauditerrors_',inBatchId,' 
(batchUploadId, configId, transactionInRecordsId, fieldNo, errorId, transactionInErrorId,errorData, required)
select batchUploadId,configId,0,fieldno,errorId,id,stackTrace, required from transactioninerrors_',inBatchId,' 
where errorId = 5 and configId = ',inConfigId);

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


SET @stmt = CONCAT("select group_concat(distinct concat('F', fieldNo)) from transactionindetailauditerrors_",inBatchId," 
where batchUPloadId = ",inBatchId,"  and errorData is null and configId = ",inConfigId," into @fieldNos;
");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


if (@fieldNos is not null) then

	begin
    
    SET @stmt = CONCAT("
		select distinct group_concat(distinct concat('when fieldNo = ', fieldNo , ' then ', concat('F', fieldNo)) separator ' ' ) from transactionindetailauditerrors_",inBatchId,"
        where batchUPloadId = ",inBatchId," and errorData is null and configId = ",inConfigId," into @updateStmts;
	 ");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
    
   if (@updateStmts is not null) then 
    begin
   
	   SET @stmt = CONCAT("
			update transactionindetailauditerrors_",inBatchId," tiae join (
			select id, ", @fieldNos," from transactioninrecords_",inBatchId,") tir
			on tiae.transactionInRecordsId = tir.id
			set errordata = case ",@updateStmts," end
			where batchUPloadId = ",inBatchId,"  and errorData is null  and configId = ",inConfigId," ;
		");
			
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
	end;
    end if;

	end;

end if;


SET @stmt = CONCAT('INSERT INTO batchuploadauditerrors (batchuploadId, configId, fieldNo, fieldName, errorId, errorDetails, errorData, reportField1Data, reportField2Data, reportField3Data, reportField4Data, rownumber, required) 
select batchUploadId, configId, table1.fieldNo, fieldName, errorId, errorDetails, errorData, reportField1Data, reportField2Data, reportField3Data, reportField4Data, transactionInRecordsId, required 
from transactionIndetailauditerrors_',inBatchId, " table1");


PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


SET @stmt = CONCAT("update batchuploadauditerrors table1 join (
select ",@rptField1," fieldData, transactionInRecordsId from transactiontranslatedin_",inBatchId,") table2
on table1.rownumber = table2.transactionInRecordsId
set translatedReportField1Data = fieldData
where table1.batchUploadId = ",inBatchId,";");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;



end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `populateDroppedValues`(in inConfigId int, in inBatchId int, in foroutboundProcessing boolean)
proc_main:begin

set @dvTableName = "batchuploaddroppedvalues";
set @recordName = "transactioninrecords";
set @batchIdCol = "batchUploadId";
set @colDirection = "in";

if (foroutboundProcessing)  then
		set @dvTableName = "batchdownloaddroppedvalues";
		set @recordName = "transactionoutrecords";
        set @batchIdCol = "batchDownloadId";
        set @colDirection = "out";
end if;

SET @stmt = CONCAT("
delete dropv from transaction",@colDirection,"macrodroppedvalues_",inBatchId," dropv join (
select matchid from transaction",@colDirection,"macrokeptvalues_",inBatchId,") keptv
on keptv.matchId = dropv.matchId;
");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


SET @stmt = CONCAT("
insert into ",@dvTableName ," (",@batchIdCol,", transaction",@colDirection,"recordsId, fieldNo, configId, fieldName, fieldValue)
select distinct ",inBatchId,", t1.transaction",@colDirection,"recordsId, t1.fieldNo, t1.configId, fieldDesc, 
t1.fieldValue from transaction",@colDirection,"macrodroppedvalues_",inBatchId," t1 
join (select * from configurationformfields) t2
on t1.configId = t2.configId
and t1.fieldNo = t2.fieldno;
");



PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


if (foroutboundProcessing) then
	begin
		
         select batchuploadid into @batchUploadId from batchdownloads where id = inBatchId;
        delete from   batchdownloaddroppedvalues where batchuploadId = @batchUploadId;
    
        
        SET @stmt = CONCAT("
			update  batchdownloaddroppedvalues t1 join (select id transactionOutRecordsId, transactionInRecordsId from transactionoutrecords_",inBatchId," 
            ) t2
			on t1.transactionOutRecordsId = t2.transactionOutRecordsId
			set t1.batchuploadId = ",@batchUploadId,",
            t1.transactionInRecordsId = t2.transactionInRecordsId
            where t1.batchdownloadId = ",inBatchId,";
		");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

        
	end;
end if;

SELECT concat('F',rptField1),concat('F',rptField2),concat('F',rptField3),concat('F',rptField4) INTO @rptField1, @rptField2,@rptField3,@rptField4 
FROM configurationmessagespecs where configId = inConfigId LIMIT 1;

if(@rptField1 = 'F0') then 
	set @rptField1 = "F1";
end if;

if(@rptField2 = 'F0') then 
	set @rptField2 = "F2";
end if;

if(@rptField3 = 'F0') then 
	set @rptField3 = "F3";
end if;

if(@rptField4 = 'F0') then 
	set @rptField4 = "F4";
end if;


SET @stmt = CONCAT("
update  ",@dvTableName," t1 join 
(Select transaction",@colDirection,"RecordsId, t1.",@rptField1," rptField1, t1.",@rptField2," rptField2, t1.",@rptField3," rptField3, t1.",@rptField4," rptField4
 from transaction",@colDirection,"records_",inBatchId," t1 join
(select transaction",@colDirection,"RecordsId from transactiontranslated",@colDirection,"_",inBatchId,") t2
on t1.id = t2.transaction",@colDirection,"RecordsId) t2
on t1.",@recordName ,"Id = t2.",@recordName,"Id 
set reportField1Data = rptField1,
reportField2Data = rptField2,
reportField3Data = rptField3,
reportField4Data = rptField4,
translatedReportField1Data = rptField1 
where t1.",@batchIdCol," = ",inBatchId," and configId = ",inConfigId,";
");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


SET @stmt = CONCAT("
update  ",@dvTableName," t1 join 
(Select transaction",@colDirection,"RecordsId, ",@rptField1," rptField1
from transactiontranslated",@colDirection,"_",inBatchId,") t2
on t1.",@recordName ,"Id = t2.",@recordName,"Id 
set translatedReportField1Data = rptField1 
where t1.",@batchIdCol," = ",inBatchId," and configId = ",inConfigId,";
");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

/** populate inbound **/
SELECT populateInboundAuditReport INTO @populateInboundAuditReport FROM configurationtransportdetails where configId = inConfigId LIMIT 1;

if (@populateInboundAuditReport) then

	-- we insert outbound entries into inbound DV table
	begin
			
				SET @stmt = CONCAT("
					INSERT INTO batchuploaddroppedvalues 
					(transactionInRecordsId, fieldNo, batchUploadId, configId, fieldName, fieldValue, reportField1Data, reportField2Data, 
					reportField3Data, reportField4Data, translatedReportField1Data, fromOutboundConfig) 
					select transactionOutRecordsId, fieldNo, batchUploadId, configId, fieldName, fieldValue, reportField1Data, reportField2Data, 
					reportField3Data, reportField4Data, translatedReportField1Data, True from batchdownloaddroppedvalues where batchDownloadId = ",inBatchId,";
					");
				
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
    
    end;

end if;


end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `PopulateFPRaceIdAndFields`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @listTable, @translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @listTable, @translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

-- defaulting con1 to Y
set con1 = 'Y';
			
            set @whereString = concat("  where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
			
            
            -- we need to keep original value, store it in forcw first
            set @stmt = concat("
				update ",@translatedTable, " set forcw = ",srcField,";
			");
            
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt; 
            
			set @stmt = concat("
				select length(concat_ws('', F17,F18,F19,F20,F21,F22,F23,F30)) fieldLen from ",@translatedTable, @whereString, " order by fieldLen desc limit 1 into @fieldLen;
			");
            
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
         
    
        if (@fieldLen = 0) then
    
    
		begin
				set @stmt = concat("update ",@translatedTable," set F17 = case when concat(',', ",srcField,", ',') like '%,1,%' then '",con1,"' else '' end",@whereString,";");
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
				
				set @stmt = concat("update ",@translatedTable," set F18 = case when concat(',', ",srcField,", ',') like '%,2,%' then '",con1,"' else '' end",@whereString,";");
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
                
				set @stmt = concat("update ",@translatedTable," set F19 = case when concat(',', ",srcField,", ',') like '%,3,%' then '",con1,"' else '' end",@whereString,";");
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
                
                set @stmt = concat("update ",@translatedTable," set F20 = case when concat(',', ",srcField,", ',') like '%,4,%' then '",con1,"' else '' end",@whereString,";");
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
                
                set @stmt = concat("update ",@translatedTable," set F21 = case when concat(',', ",srcField,", ',') like '%,5,%' then '",con1,"'  else '' end",@whereString,";");
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
                
                set @stmt = concat("update ",@translatedTable," set F22 = case when concat(',', ",srcField,", ',') like '%,7,%' then '",con1,"'  else '' end",@whereString,";");
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
                
                set @stmt = concat("update ",@translatedTable," set F23 = case when concat(',', ",srcField,", ',') like '%,6,%' then '",con1,"' else '' end",@whereString,";");
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
                
                set @stmt = concat("update ",@translatedTable," set F30 = case when concat(',', ",srcField,", ',') like '%,8,%' then'",con1,"'  else '' end ",@whereString,";");
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
	
    end;
    
    end if;
				
                set @stmt = concat("
				update ",@translatedTable," set ",srcField," =  case 
				when ( length(concat_ws('', F17,F18,F19,F20,F21,F23)) > 1)  and  (length(concat_ws('', F22, F30)) = 0) then 6 
				when (F22 = '",con1,"' and length(concat_ws('', F17,F18,F19,F20,F21, F23, F30)) = 0) then 7
				when (F30 ='",con1,"' and length(concat_ws('', F17,F18,F19,F20, F21, F23, F22)) = 0) then 8
				when (F17 = '",con1,"' and length(concat_ws('', F22,F30)) = 0) then 1  when (F18 = '",con1,"' and length(concat_ws('', F22,F30)) = 0) then 2 
				when (F19 = '",con1,"' and length(concat_ws('', F22,F30)) = 0) then 3 when (F20 = '",con1,"' and length(concat_ws('', F22,F30)) = 0)then 4 
				when (F21 = '",con1,"' and length(concat_ws('', F22,F30)) = 0)then 5 when (F23 = '",con1,"' and length(concat_ws('', F22,F30)) = 0)  then 6
				else '' end ",@whereString,"
			");
            
            
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
            
			   
				-- put back forcw value so it can be passed
                -- track the ids that are changed
                
                set @errorIds = '';
                
                set @stmt = concat("
				select  group_concat(id) from ",@translatedTable, "
                where length(forcw) > 0 and (",srcField," is null or length(",srcField,") = 0)
				into @errorIds");
                
                PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt; 
                
                if (@errorIds is not null) then 
                
					begin
						set @stmt = concat("
						update ",@translatedTable, " set ",srcField," = forcw
						where id in (",@errorIds,")");
				
						PREPARE stmt from @stmt;
						EXECUTE stmt;
						DEALLOCATE PREPARE stmt; 
						
						set @stmt = concat("
						update ",@translatedTable, " set forcw = 'MACRO_ERROR'
						where id in (",@errorIds,")");
			
						PREPARE stmt from @stmt;
						EXECUTE stmt;
						DEALLOCATE PREPARE stmt; 
					
					end;
                end if;
                
                
end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `populateOutboundAuditReport`(in inConfigId int, in inBatchId int, in inBatchUpoadId int, in inBatchUploadConfigId int)
proc_main:begin

SET @stmt = CONCAT('delete from transactionoutdetailauditerrors_',inBatchId,' where configId = ',inConfigId);

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

SELECT concat('F',rptField1),concat('F',rptField2),concat('F',rptField3),concat('F',rptField4) INTO @rptField1, @rptField2,@rptField3,@rptField4 
FROM configurationmessagespecs where configId = inConfigId LIMIT 1;

SELECT populateInboundAuditReport INTO @populateInboundAuditReport
FROM configurationtransportdetails where configId = inConfigId LIMIT 1;


if(@rptField1 = 'F0') then 
	set @rptField1 = "F1";
end if;

if(@rptField2 = 'F0') then 
	set @rptField2 = "F2";
end if;

if(@rptField3 = 'F0') then 
	set @rptField3 = "F3";
end if;

if(@rptField4 = 'F0') then 
	set @rptField4 = "F4";
end if;


SET @stmt = CONCAT('insert into transactionoutdetailauditerrors_',inBatchId,' 
(required, batchDownloadId, configId, transactionOutRecordsId, fieldNo, errorId, transactionOutErrorId,errorData, reportField1Data, reportField2Data, reportField3Data, reportField4Data)
select a.required, a.batchDownloadId,a.configId,a.transactionOutRecordsId,a.fieldno,a.errorId,a.id,a.fieldValue,b.',@rptField1,',b.',@rptField2,',b.',@rptField3,',b.',@rptField4,'
from transactionouterrors_',inBatchId,' a inner join 
transactionoutrecords_',inBatchId,' b on a.transactionOutRecordsId = b.id
where a.configId = ',inConfigId);

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


SET @stmt = CONCAT("UPDATE transactionouterrors_",inBatchId," JOIN (select distinct id as matchId, macro_Name as label 
from macro_names) tbl_concat
 ON transactionouterrors_",inBatchId,".macroId = tbl_concat.matchid
SET transactionouterrors_",inBatchId,".stackTrace = concat(label, ' - ' , stackTrace) WHERE errorId = 5");


PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


SET @stmt = CONCAT('UPDATE transactionoutdetailauditerrors_',inBatchId,' JOIN (select distinct fieldNo matchid, macro_Name as label 
from macro_names, transactionouterrors_',inBatchId,' where macro_Names.id = transactionouterrors_',inBatchId,'.macroId) tbl_concat
 ON transactionoutdetailauditerrors_',inBatchId,'.fieldNo = tbl_concat.matchid
SET transactionoutdetailauditerrors_',inBatchId,'.errorDetails = tbl_concat.label WHERE errorId = 4');

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

SET @stmt = CONCAT('UPDATE transactionoutdetailauditerrors_',inBatchId,'
 JOIN (select distinct fieldNo matchid, name as label 
from crosswalks, transactionouterrors_',inBatchId,' where crosswalks.id = transactionouterrors_',inBatchId,'.cwId) tbl_concat
 ON transactionoutdetailauditerrors_',inBatchId,'.fieldNo = tbl_concat.matchid
SET transactionoutdetailauditerrors_',inBatchId,'.errorDetails = tbl_concat.label WHERE errorId = 3');

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

SET @stmt = CONCAT('UPDATE transactionoutdetailauditerrors_',inBatchId,'
 JOIN (select distinct fieldNo matchid, validationType as label 
from ref_validationtypes, transactionouterrors_',inBatchId,' where ref_validationtypes.id = transactionouterrors_',inBatchId,'.validationTypeId) tbl_concat
 ON transactionoutdetailauditerrors_',inBatchId,'.fieldNo = tbl_concat.matchid
SET transactionoutdetailauditerrors_',inBatchId,'.errorDetails = tbl_concat.label WHERE errorId = 2');


PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

SET @stmt = CONCAT('UPDATE transactionoutdetailauditerrors_',inBatchId,'
 JOIN (select distinct fieldNo as matchid, fieldDesc as label from configurationformfields where configId = ',inConfigId,') tbl_concat
 ON transactionoutdetailauditerrors_',inBatchId,'.fieldNo = tbl_concat.matchid
SET transactionoutdetailauditerrors_',inBatchId,'.fieldName = tbl_concat.label');

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;



SET @stmt = CONCAT('insert into transactionoutdetailauditerrors_',inBatchId,' 
(required, batchDownloadId, configId, transactionOutRecordsId, fieldNo, errorId, transactionOutErrorId,errorData)
select required, batchDownloadId,configId,0,fieldno,errorId,id,stackTrace
from transactionouterrors_',inBatchId,' 
where errorId = 5 and configId = ',inConfigId);

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


SET @stmt = CONCAT("select group_concat(distinct concat('F', fieldNo)) from transactionoutdetailauditerrors_",inBatchId," 
where batchDownloadId = ",inBatchId," and errorData is null and configId = ",inConfigId," into @fieldNos;
");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;




if (@fieldNos is not null) then

	begin

 SET @stmt = CONCAT("
 select distinct group_concat(distinct concat('when fieldNo = ', fieldNo , ' then ', concat('F', fieldNo)) separator ' ' ) from transactionoutdetailauditerrors_",inBatchId,"
 where batchDownloadId = ",inBatchId," and errorData is null and configId = ",inConfigId," into @updateStmts;
 ");


 PREPARE stmt from @stmt;
 EXECUTE stmt;
 DEALLOCATE PREPARE stmt;


 if (@updateStmts is not null) then 
 begin

 SET @stmt = CONCAT("
 update transactionoutdetailauditerrors_",inBatchId," tiae join (
 select distinct id, ", @fieldNos," from transactionoutrecords_",inBatchId,") tir
 on tiae.transactionoutRecordsId = tir.id
 set errordata = case ",@updateStmts," end
 where batchDownloadId = ",inBatchId," and errorData is null and configId = ",inConfigId," ;
 ");


 PREPARE stmt from @stmt;
 EXECUTE stmt;
 DEALLOCATE PREPARE stmt;
	end;
 end if;

	end;

end if;

delete from batchdownloadauditerrors where batchdownloadId = inBatchid and configId = inConfigId;


SET @stmt = CONCAT('INSERT INTO batchdownloadauditerrors (batchDownloadId, configId, fieldNo, fieldName, errorId, errorDetails, errorData, reportField1Data, reportField2Data, reportField3Data, reportField4Data, rownumber) 
select batchDownloadId, configId, fieldNo, fieldName, errorId, errorDetails, errorData, reportField1Data, reportField2Data, reportField3Data, reportField4Data, transactionOutRecordsId 
from transactionoutdetailauditerrors_',inBatchId);

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

-- update report field
SET @stmt = CONCAT("update batchdownloadauditerrors table1 join (
select ",@rptField1," fielddata, transactionOutRecordsId from transactiontranslatedout_",inBatchId,") table2
on table1.rownumber = table2.transactionOutRecordsId
set translatedReportField1Data = fieldData
where table1.batchdownloadId = ",inBatchId,";");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;



if (@populateInboundAuditReport) then

 begin


 call createTempErrorTable(inBatchId);

 SET @stmt = CONCAT("
 insert into transactionoutdetailauditerrorsforinbound_",inBatchId," 
 select * from transactionoutdetailauditerrors_",inBatchId,";
 ");

 PREPARE stmt from @stmt;
 EXECUTE stmt;
 DEALLOCATE PREPARE stmt;


 SET @stmt = CONCAT("
 ALTER TABLE transactionoutdetailauditerrorsforinbound_",inBatchId," 
 ADD COLUMN transactionInRecordsId INT NULL AFTER transactionOutErrorId,
 ADD COLUMN inFieldNo INT NULL AFTER transactionInRecordsId;
 ");

 PREPARE stmt from @stmt;
 EXECUTE stmt;
 DEALLOCATE PREPARE stmt; 


 SET @stmt = CONCAT("
 update transactionoutdetailauditerrorsforinbound_",inBatchId," auditTable join (
 select distinct populateErrorFieldNo, mt.* from configurationconnectionfieldmappings join 
 ( select auditId, transactionInRecordsId, fieldno from transactionoutrecords_",inBatchId," tir 
 join ( select id as auditId, transactionoutrecordsId, fieldNo from transactionoutdetailauditerrorsforinbound_",inBatchId,") errorTable 
 on tir.id = errorTable.transactionoutrecordsId) mt on mt.fieldNo = configurationconnectionfieldmappings.fieldNo 
 where sourceConfigId = ",inBatchUploadConfigId,") infoTable
 on infotable.auditid = auditTable.id
 set auditTable.transactionInRecordsId = infoTable.transactionInRecordsId, inFieldNo = populateErrorFieldNo;
 ");

 PREPARE stmt from @stmt;
 EXECUTE stmt;
 DEALLOCATE PREPARE stmt; 



 SET @stmt = CONCAT("
 select group_concat(distinct concat('F', inFieldNo)) from transactionoutdetailauditerrorsforinbound_",inBatchId," where infieldNo != 0 into @inboundFields;
 ");


 PREPARE stmt from @stmt;
 EXECUTE stmt;
 DEALLOCATE PREPARE stmt; 


 if (@inboundFields is not null) then 

 begin

 SET @stmt = CONCAT("
 select group_concat(distinct concat('when infieldNo = ', inFieldNo , ' then ', concat('F', inFieldNo)) separator ' ' ) 
 from transactionoutdetailauditerrorsforinbound_",inBatchId," where infieldNo != 0 into @inUpdateFields;
 ");


 PREPARE stmt from @stmt;
 EXECUTE stmt;
 DEALLOCATE PREPARE stmt; 


 SELECT concat('F',rptField1),concat('F',rptField2),concat('F',rptField3),concat('F',rptField4) INTO @rptInField1, @rptInField2,@rptInField3,@rptInField4 
 FROM configurationmessagespecs where configId = inBatchUploadConfigId LIMIT 1;


 if (@rptInField1 = 'F0') then 
 set @rptInField1 = "F1";
 end if;

 if (@rptInField2 = 'F0') then 
 set @rptInField2 = "F2";
 end if;

 if (@rptInField3 = 'F0') then 
 set @rptInField3 = "F3";
 end if;

 if(@rptInField4 = 'F0') then 
 set @rptInField4 = "F4";
 end if;


 SET @stmt = CONCAT("
 update transactionoutdetailauditerrorsforinbound_",inBatchId," tir join (
 select distinct ",@rptInField1," reportField1Data, ",@rptInField2," reportField2Data, ",@rptInField3," reportField3Data, ",@rptInField4," reportField4Data, 
 transactionInRecordsId, ",@inboundFields," from transactioninrecords_",inBatchUpoadId," tir join 
 (select distinct transactionInRecordsId from transactionoutdetailauditerrorsforinbound_",inBatchId,") auditTable
 on transactionInRecordsId = tir.id) infotable
 on infotable.transactionInRecordsId = tir.transactionInRecordsId
 set errorData = case 
 ",@inUpdateFields,"
 end, 
 tir.reportField1Data = infotable.reportField1Data, tir.reportField2Data = infotable.reportField2Data,
 tir.reportField3Data = infotable.reportField3Data, tir.reportField4Data = infotable.reportField4Data
 ");


 PREPARE stmt from @stmt;
 EXECUTE stmt;
 DEALLOCATE PREPARE stmt; 

 -- SET @stmt = CONCAT("
 -- delete from batchuploadauditerrors where fromOutboundConfig = true and batchUploadId = ",inBatchUpoadId," and configId = ",inBatchUploadConfigId,"
 -- ");

 -- PREPARE stmt from @stmt;
 -- EXECUTE stmt;
 -- DEALLOCATE PREPARE stmt;


 -- SET @stmt = CONCAT("insert into batchuploadauditerrors (batchUploadId, configId, fieldNo, fieldName, errorId, errorDetails, errorData, reportField1Data, 
 -- reportField2Data, reportField3Data, reportField4Data, rownumber, fromOutboundConfig, required)
 -- select ",inBatchUpoadId,", ",inBatchUploadConfigId,", case when inFieldNo is null then 0 else inFieldNo end, fieldName, errorId, errorDetails, errorData, reportField1Data, 
 -- reportField2Data, reportField3Data, reportField4Data, transactionInRecordsId, true, required from 
 -- transactionoutdetailauditerrorsforinbound_",inBatchId, " table1");

 -- PREPARE stmt from @stmt;
 -- EXECUTE stmt;
 -- DEALLOCATE PREPARE stmt; 

 end;
 end if;

 SET @stmt = CONCAT("
 delete from batchuploadauditerrors where fromOutboundConfig = true and batchUploadId = ",inBatchUpoadId," and configId = ",inBatchUploadConfigId,"
 ");

 PREPARE stmt from @stmt;
 EXECUTE stmt;
 DEALLOCATE PREPARE stmt;


 SET @stmt = CONCAT("insert into batchuploadauditerrors (batchUploadId, configId, fieldNo, fieldName, errorId, errorDetails, errorData, reportField1Data, 
 reportField2Data, reportField3Data, reportField4Data, rownumber, fromOutboundConfig, required)
 select ",inBatchUpoadId,", case when inFieldNo is null then configId when inFieldNo = 0 then configId else ",inBatchUploadConfigId," end, case when inFieldNo is null then fieldNo when inFieldNo = 0 then fieldNo else inFieldNo end, fieldName, errorId, errorDetails, errorData, reportField1Data, 
 reportField2Data, reportField3Data, reportField4Data, case when transactionInRecordsId is null then 0 else transactionInRecordsId end, true, required from 
 transactionoutdetailauditerrorsforinbound_",inBatchId, " table1");

 PREPARE stmt from @stmt;
 EXECUTE stmt;
 DEALLOCATE PREPARE stmt; 
 
  -- update translatedReportField1Data
           SET @stmt = CONCAT("update batchuploadauditerrors table1 join (
			select ",@rptInField1 ," fieldData, transactionInRecordsId from transactiontranslatedin_",inBatchUpoadId,") table2
			on table1.rownumber = table2.transactionInRecordsId
			set translatedReportField1Data = fieldData
			where table1.batchUploadId = ",inBatchUpoadId," and fromOutboundConfig = true;");

			PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
 

 SET @stmt = CONCAT("drop table if exists transactionoutdetailauditerrorsforinbound_",inBatchId,"; ");

 PREPARE stmt from @stmt;
 EXECUTE stmt;
 DEALLOCATE PREPARE stmt; 

 end;
end if;


end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `prependCon2IfCon1Length`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

/** con1 must be numeric **/
				if (con1 REGEXP '^[]?[0-9]*[]{0,1}[0-9]*$' = 0 || length(@con1) = 0 ) then

							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'prependCon2IfCon1Length Macro - Con1 - ",con1," must be an integer. '",", ",true);
                            
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							 
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;


leave proc_main;

end if;

set @whereClause = '';
if (con1 = 0) then
	set @whereClause = concat(" or ",srcField," is null");
end if;

set @stmt = concat("update ", @translatedTable," set ",srcField,
" = concat_ws('','", con2, "', ",srcField , ") where (length(",srcField,") = ",con1,@whereClause,") and ",
"configId = ",configId," and ",@batchIdType," = ",batchId," and statusId not in (",@finalStatusIds,");");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `regExCheck`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
SELECT 
    @translatedTable,
    @transactionTable,
    @batchTable,
    @batchIdType,
    @errorTable,
    @translateCol
INTO @translatedTable , @transactionTable , @batchTable , @batchIdType , @errorTable, @translateCol;

call getFinalStatusIds;
SELECT @finalStatusIds INTO @finalStatusIds;

set @whereClause  = concat("  (",srcField," REGEXP '",con1,"' != 1 or ",srcField," REGEXP '",con1,"' is null)
            and ",srcField," is not null and  length(",srcField,") > 0 and ");
            
set @whereString = concat(@whereClause, "  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");

			set @stmt = concat("update  ", @translatedTable , " set forcw = 'MACRO_ERROR'  where ",@whereString);

			PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `removeDupFromList`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin 


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @listTable, @translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @listTable, @translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


if (transactionId = 0) then
	set @whereString = concat(" and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");
end if;

if (transactionId != 0) then
	set @whereString = concat(" and ",	@transactionTable,"Id = ", transactionId,";");
end if;


set @fcol = replace(lcase(srcField), 'f', '');
set @stmt = concat("delete from ", @listTable," where fcol = ",@fcol," and ",@batchIdType," = ", batchId ,";");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;



	set @stmt = concat("
    insert into ", @listTable," (",@batchIdType,", ",@translateCol,", invalue, fcol)
    SELECT ",@batchIdType,", ",@translateCol,", trim(SUBSTRING_INDEX(SUBSTRING_INDEX(t.",srcField,", ',', n.n), ',', -1)) value, ",@fcol,"
    FROM ",@translatedTable ," t CROSS JOIN (
    SELECT a.N + b.N * 10 + 1 n FROM  
   (select id N from ref_numbers where id <=50) a
   ,(select id N from ref_numbers where id <=50) b
    ORDER BY n) n  WHERE n.n <= 1 + (LENGTH(t.",srcField,") - LENGTH(REPLACE(t.",srcField,", ',', ''))) ", @whereString);
    

    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
     
    
    
    set @stmt2 = "";
	set @stmt1 = concat("update ",@listTable,"  set translatedvalue = invalue where ",@batchIdType," = ", batchId);
    if (transactionId != 0) then
		set @stmt2 = concat(" and ", @translateCol , " = ", transactionId);
	END if;
	
    set @stmt = concat(@stmt1, @stmt2);
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    
  
	set @selDistinct = ' distinct ';

    set @stmt1 = concat("update ",@translatedTable," join  (select ",@translateCol," as matchId, 
    group_concat(",@selDistinct," translatedValue order by translatedValue) label from  ",@listTable,"
	where ",@batchIdType," = ",batchid, " and fcol = ",@fCol," group by ",@translateCol," ) cwmatch on ",@translateCol," = matchid set ",srcField," = label ");
	
    set @stmt2="";
	
    if (passClear = 1) then
		set @stmt2= " where label is not null";
	end if;
	
    set @stmt = concat(@stmt1, @stmt2);
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    

    set @stmt = concat("delete from ", @listTable, " where ",@batchIdType," = ",batchId," and fcol = ",@fcol);
	
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;


select '';
end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `replaceBlanksWithChars`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

	set @stmt = concat("update ",@translatedTable, " set ",srcField," = '" ,con1,  "' where (",srcField, " is null  
	or length(REPLACE(REPLACE(", srcField, ", ""\n"", """"), ""\r"", """")) = 0) and 
	configId = ",configId," and ",@batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");

	PREPARE stmt from @stmt;
	EXECUTE stmt;
	DEALLOCATE PREPARE stmt;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `replaceCon1CharswithCon2`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

			if (length(con1) = 0) then
							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'replaceCon1CharswithCon2 Con1 - ",con1,"  cannot be blank'",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            -- update all transactions to macro_error
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							 
                             PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
				leave proc_main;
            end if;



            set @stmt = concat("update ", @translatedTable, " set ",srcField," = replace_ci(",srcField,", '",con1,"','",con2,"') 
			where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");
				
			PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
            
end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `setInboundOutBoundTables`(in foroutboundProcessing boolean, in batchId int)
proc_main:begin


set @translatedTable = CONCAT('transactiontranslatedin_',batchId);
set @transactionTable = CONCAT('transactioninrecords_',batchId);
set @batchTable = "batchUploads";
set @batchIdType = "batchUploadId";
set @errorTable = CONCAT('transactioninerrors_',batchId);
set @batchIdColumn = "batchUploadId";
set @listTable = CONCAT('transactiontranslatedlistin_',batchId);
set @translateCol = "transactioninrecordsid";

if (foroutboundProcessing) THEN
	BEGIN 
	set @translatedTable = CONCAT('transactiontranslatedout_',batchId);
	set @transactionTable = CONCAT('transactionoutrecords_',batchId);
	set @batchTable = "batchDownloads";
	set @batchIdType = "batchDownloadId";
	set @errorTable = CONCAT('transactionouterrors_',batchId);
	set @batchIdColumn = "batchDownloadId";
	set @listTable = CONCAT('transactiontranslatedlistout_',batchId);
	set @translateCol = "transactionoutrecordsid";
	END; 
END IF;
end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `setSqlForConfig`(in inConfigId int, in batchUploadId int)
proc_main:begin
SET SESSION group_concat_max_len = 100000;
drop TEMPORARY TABLE if exists temp1;
CREATE TEMPORARY TABLE temp1
as (select min(fieldNo) as fieldNo, saveToTableName, savetotablecol, configId, batchUploadId
from configurationFormFields where configId = inConfigId
and saveToTableName != ''
group by savetotablecol, saveToTableName);
SELECT  batchUploadId, saveToTableName, 
group_concat(distinct savetotablecol ORDER BY fieldNo SEPARATOR ',') as savetotablecol,
group_concat( concat('F',fieldNo) ORDER BY fieldNo SEPARATOR ',') as singleValueFields, 
group_concat( concat('strSplit(F',fieldNo, ', ''^^^^^'',@valPos)') ORDER BY fieldNo SEPARATOR ',') as splitFields, 
group_concat( concat('F',fieldNo, ' like ''%^^^^^%''') ORDER BY fieldNo SEPARATOR ' or ') as checkForDelim,
configId
FROM temp1 
where configId = inConfigId
GROUP BY saveToTableName
ORDER BY saveToTableName;
end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `setSqlForOutboundConfig`(in inConfigId int, in batchDownloadId int)
proc_main:begin
SET SESSION group_concat_max_len = 10000;
drop TEMPORARY TABLE if exists tempOut;
CREATE TEMPORARY TABLE tempOut
as (select min(fieldNo) as fieldNo, saveToTableName, savetotablecol, configId, batchDownloadId
from configurationFormFields where configId = inConfigId
and saveToTableName != ''
group by savetotablecol, saveToTableName);
select batchDownloadId, 
group_concat(fieldNo ORDER BY fieldNo SEPARATOR ',')as fieldNos, 
group_concat(savetotablecol ORDER BY fieldNo SEPARATOR ',') as saveToCols
, saveToTableName, group_concat(
concat(
'group_concat(COALESCE(',savetotablecol, ', null) order by ', saveToTableName, '.id separator ''^^^^^'' ) as ', savetotablecol
) 
ORDER BY fieldNo SEPARATOR ', ')  as selectFields, 
group_concat(concat('tto.f', fieldNo, ' = selectTbl.' , savetotablecol)  ORDER BY fieldNo SEPARATOR ', ')  as updateFields,
configId
FROM tempOut
where configId = inConfigId
GROUP BY saveToTableName
ORDER BY saveToTableName;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `stringToDate`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


		set @mysqlDateFormat = concat('%Y-%m-%d');

		set @inboundDateFormat = con1;
        
		if (length(con2) > 0) then
			set @outboundDateFormat = concat(con2);
		else 
			set @outboundDateFormat = concat('%Y-%m-%d');
		end if;



		set @errorIds = "";
		set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(",srcField,", '",@inboundDateFormat,"') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

	if (@errorIds is not null) then

		begin
				set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
						
				PREPARE stmt from @stmt;
				EXECUTE stmt;
				DEALLOCATE PREPARE stmt;
		end;
	end if;

	set @stmt = concat("update ",@translatedTable, " set ",srcField," = str_to_date(",srcField,", '",@inboundDateFormat,"') where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 	
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
            
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
      


	set @errorIds = "";
	set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(",srcField,") is null
					and ",srcField," is not null and length(",srcField,") > 0  and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
       
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

if (@errorIds is not null) then

begin	
		set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");
		
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;

	
set @goodIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where  ",srcField," is not null and length(",srcField,") > 0  and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @goodIds");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
		
		if (@goodIds is not null) then

			begin
					-- fix two digit years
					-- check to make sure %y is in the inbound to handle
                    select year(curdate()) into @currYear;
                    
					if  (@inboundDateFormat like BINARY '%\%y%' && @outboundDateFormat not like BINARY '%\%y%') then 
					
					select year(curdate()) into @currYear;

					set @stmt = concat("update ",@translatedTable, " set ",srcField," =  DATE_ADD(",srcField,", INTERVAL -100 Year) where id in (",@goodIds,") 
					and year(",srcField,") > ",@currYear,"");
					
					PREPARE stmt from @stmt;
					EXECUTE stmt;
					DEALLOCATE PREPARE stmt;
                    
                    -- translate to final format
                    set @stmt = concat("update ",@translatedTable, " set ",srcField," = date_format(",srcField,", '",@outboundDateFormat,"') where id in (",@goodIds,") ");
					
					PREPARE stmt from @stmt;
					EXECUTE stmt;
					DEALLOCATE PREPARE stmt;
		end if;
                    
			end;
		end if;
        
        

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `stripCharAtPos`(in configId int, 
in batchId int, in srcField varchar(10), in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;


-- check to see if con1 is numeric
      if con1 REGEXP '^[]?[0-9]*[]{0,1}[0-9]*$' = 0 then 
					begin
						set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'stripCharAtPos Con1 - ",con1,"  must be a numeric value'",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            -- update all transactions to macro_error
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							 
                             PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
           
			leave proc_main;
        end;
      end if;

set @readField = srcField;
set @strCompare = '';

if (length(trim(con2)) != 0) then
	begin 
		set @strCompare = concat(" and substring(", @readField, ",", con1, ", 1) = '", con2, "'");
	end;
end if; 


set @stmt = concat("update ",@translatedTable, " set ",srcField," = concat(substring(", @readField,", 1, (", con1, "-1)), 
substring(", @readField, ", (", con1, " + 1),length(", @readField,")- ", con1,")) where length(", @readField,") >= " ,con1 , 
@strCompare, "  and  configId = ",configId," and ",@batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `stripCharsFromStartOrEnd`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin


call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

/** con1 must be numeric **/
				if (con1 REGEXP '^[]?[0-9]*[]{0,1}[0-9]*$' = 0 || length(@con1) = 0 ) then

							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'stripCharsFromStartOrEnd Macro - Con1 - ",con1," must be an integer. '",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;


leave proc_main;

end if;

if (length(con2) = 0) then

	set con2 = 2;

end if;

if (con2 != 1 && con2 != 2 && length(con2) != 1) then

							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, stackTrace, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'stripCharsFromStartOrEnd Macro - Con2 - ",con2," should be 1 or 2. '",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
leave proc_main;

end if;

		set @stripSQL = concat("substring(",srcField,", ",con1+1,", length(",srcField,"))");
		if (con2 = 2) then 
		set @stripSQL = concat("substring(",srcField,", 1, length(",srcField,")-",con1,")");
		end if;

		set @stmt = concat("update ",@translatedTable, " set ",srcField," = " ,@stripSQL,  " where 
		configId = ",configId," and ",@batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `stripLeadingChars`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

set @stmt = concat("update ", @translatedTable," updateTable join 
(select id, TRIM(LEADING '",con1,"' FROM ",srcField,") as updateTo from ", @translatedTable," where 
left(",srcField,", length('",con1,"')) = '",con1,"' and  configId = ",configId," and ",@batchIdType," = ",batchId," and statusId not in (",@finalStatusIds,")) tti
on tti.id = updateTable.id
set updateTable.",srcField," = updateTo  
where  configId = ",configId," and ",@batchIdType," = ",batchId," and statusId not in (",@finalStatusIds,");
");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `stripPhoneChars`(in vtType int, in fieldNo int,
in batchUploadId int, in configId int, in transactionId int)
BEGIN
	DECLARE varToReplace varchar(100) DEFAULT '.';
	DECLARE part1 varchar(255) DEFAULT '.';
	DECLARE part2 varchar(25) DEFAULT '.';
    DECLARE part3 varchar(253) DEFAULT '.';
	
	BEGIN
		set part1 = concat("update transactiontranslatedin_",batchUploadId," SET F", fieldNo, " = replace(F", fieldNo, ", '");
		set part3 = concat(" where configId = ",configId," and batchUploadId = ", batchUploadId , " and statusId not in (11,12,13,16,20);");
	END;

	set part2 = "', '')";
    
	set @stmt = concat(part1, varToReplace, part2, part3);
  	PREPARE stmt from @stmt;
	EXECUTE stmt;

	set varToReplace = '-';
	set @stmt = concat(part1, varToReplace, part2, part3);
	PREPARE stmt from @stmt;
	EXECUTE stmt;

	set varToReplace = ')';
	set @stmt = concat(part1, varToReplace, part2, part3);
	PREPARE stmt from @stmt;
	EXECUTE stmt;

	set varToReplace = '(';
	set @stmt = concat(part1, varToReplace, part2, part3);
	PREPARE stmt from @stmt;
	EXECUTE stmt;

	set varToReplace = ' ';
	set @stmt = concat(part1, varToReplace, part2, part3);
	PREPARE stmt from @stmt;
	EXECUTE stmt;

 END$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `stripPhoneCharsOutbound`(in vtType int, in fieldNo int,
in batchUploadId int, in configId int, in transactionId int)
BEGIN
	DECLARE varToReplace varchar(100) DEFAULT '.';
	DECLARE part1 varchar(255) DEFAULT '.';
	DECLARE part2 varchar(25) DEFAULT '.';
    DECLARE part3 varchar(253) DEFAULT '.';
	
	if (transactionId = 0) then
	BEGIN
		set part1 = concat("update transactiontranslatedout_",batchUploadId," SET F", fieldNo, " = replace(F", fieldNo, ", '");
		set part3 = concat(" where configId = ",configId," and batchDownloadId = ", batchUploadId , " and statusId not in (11,12,13,16, 20);");
	END;
	END if;

	if (transactionId != 0) then
	BEGIN
	  set part1 = concat("update transactiontranslatedout_",batchUploadId," SET transactiontranslatedOut.F"
	  , fieldNo, " = replace(F", fieldNo, ", '");
      set part3 = concat(" where transactionOutRecordsId = ", transactionId);
	END;
	END if;
	
	set part2 = "', '')";
    
	set @stmt = concat(part1, varToReplace, part2, part3);
  	PREPARE stmt from @stmt;
	EXECUTE stmt;

	set varToReplace = '-';
	set @stmt = concat(part1, varToReplace, part2, part3);
	PREPARE stmt from @stmt;
	EXECUTE stmt;

	set varToReplace = ')';
	set @stmt = concat(part1, varToReplace, part2, part3);
	PREPARE stmt from @stmt;
	EXECUTE stmt;

	set varToReplace = '(';
	set @stmt = concat(part1, varToReplace, part2, part3);
	PREPARE stmt from @stmt;
	EXECUTE stmt;

	set varToReplace = ' ';
	set @stmt = concat(part1, varToReplace, part2, part3);
	PREPARE stmt from @stmt;
	EXECUTE stmt;

 END$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `stripTrailingChars`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

set @stmt = concat("update ", @translatedTable," set ",srcField,
" = TRIM(TRAILING '",con1,"' FROM ",srcField,") where configId = ",configId, 
" and ",@batchIdType," = ",batchId," and statusId not in (",@finalStatusIds,");");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `substringToAnotherField`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

	call setInboundOutBoundTables (foroutboundProcessing,batchId);
	SELECT 
		@translatedTable,
		@transactionTable,
		@batchTable,
		@batchIdType,
		@errorTable
	INTO @translatedTable , @transactionTable , @batchTable , @batchIdType , @errorTable;

	call getFinalStatusIds;
	SELECT @finalStatusIds INTO @finalStatusIds;

	-- check to make sure con1 and con2 are numeric
    
	if con1 REGEXP '^[]?[0-9]*[]{0,1}[0-9]*$' = 0 or   con2 REGEXP '^[]?[0-9]*[]{0,1}[0-9]*$' = 0 then 
					begin
			
							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, fieldValue, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'substringToAnotherField macro Either - Con1 - \"",con1,"\"  or Con2 - \"",con2,"\" is not a numeric value'",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							 
							PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
           
			leave proc_main;
        end;
      end if;
		
        /** 
			we only update if there are enough characters. 
			for example, abcd, extract position 2 (con1), 3 characters, cd is only 2 so it won't be updated.
        **/
        
		set @stmt = concat("update ",@translatedTable, " set ",fieldA," =  ",
		" substring(" , srcField, ", ", con1,",", con2,")  
        where  (length(substring(" , srcField, ", ", con1,",", con2,")) >= ",con2,") = true and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");
		
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `yearDiffinsertError`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

-- check to make sure con1 is a numeric value
 if con1 REGEXP '^-?[0-9]+[.]?[0-9]*$|^-?[.][0-9]+$' = 0 then 
					begin
						set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, fieldValue, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'DOBCheck Con1 - \"",con1,"\"  must be numeric value'",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							 
                             PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
           
			leave proc_main;
        end;
      end if;


-- we expect 4 digit years
set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where forcw is null
					and (
                    (length(",srcField,") = 0 and  length(",fieldA,") > 0)
                    or 
                    (length(",fieldA,") = 0 and  length(",srcField,") > 0)
                    or 
                    (",fieldA," is null and  length(",srcField,") > 0)
                    or 
					(",srcField," is null and  length(",fieldA,") > 0)
                    or  ( length(",srcField,") > 0 and substring(",srcField,",5,1) != '-' )
                    or (length(",fieldA,") > 0 and substring(",fieldA,",5,1) != '-')
                    )
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
        
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

-- now we find the ones that are not valid
set @stmt = concat("select group_concat(id) from " , @translatedTable, " where
 ((Date(",srcField,") is null and length(",srcField,") > 0)  or  (Date(",fieldA,") is null and length(",fieldA,") > 0 ))
 or (YEAR(",fieldA,") - YEAR(",srcField,") < ",con1,") 
 or (
 YEAR(",fieldA,") - YEAR(",srcField,") - (DATE_FORMAT(",fieldA,", '%m%d') < DATE_FORMAT(",srcField,", '%m%d')) < ",con1,"
 )
 and  configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

if (@errorIds is not null) then

	begin

		set @stmt = concat("update " , @translatedTable, "  set forCW = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
	end;
end if;

set @errorIds = '';


end proc_main$$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=`root`@`localhost` PROCEDURE `ZipCodeCheck`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
SELECT 
    @translatedTable,
    @transactionTable,
    @batchTable,
    @batchIdType,
    @errorTable,
    @translateCol
INTO @translatedTable , @transactionTable , @batchTable , @batchIdType , @errorTable, @translateCol;

call getFinalStatusIds;
SELECT @finalStatusIds INTO @finalStatusIds;

				
                set @proceed = true;
                
                
                if (length(con1) > 0) then
					begin
						
                        if con1 REGEXP '^[0-9]{5}$' = 0 then 
                        
							set @proceed = false;
                            
							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, fieldValue, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'Default zip code ",con1," is not a valid value'",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            
                            leave proc_main;
						end if;
					end;
                end if;

				if (@proceed) then 
								begin
								
								set @whereStmt =  concat(" and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");
								set @whereClause = concat("  (",srcField," REGEXP '^[0-9]{5}$' != 1) 
								and ",srcField," is not null and length(",srcField,") > 0 ");
							    set @whereString = concat(@whereClause , @whereStmt);

								set @stmt = concat("update  ", @translatedTable , " set forcw = ",srcField);
								PREPARE stmt from @stmt;
								EXECUTE stmt;
								DEALLOCATE PREPARE stmt;

								set @stmt = concat("update  ", @translatedTable , " set ",srcField," = replace(",srcField,", '-', '') where (length(", srcField,") != 0 or ",srcField," is not null )", @whereStmt);
								PREPARE stmt from @stmt;
								EXECUTE stmt;
								DEALLOCATE PREPARE stmt;
								
								
								
								set @stmt = concat("update  ", @translatedTable , " set ",srcField," = 
								case 
								when (length(",srcField,") = 4 or length(",srcField,") = 8) then concat('0', ",srcField,") 
								when (length(",srcField,") = 3 or length(",srcField,") = 7)  then concat('00', ",srcField,") 
								when (length(",srcField,") = 2  or length(",srcField,") = 6)  then concat('000', ",srcField,") 
								when length(",srcField,") = 1 then concat('0000', ",srcField,") 
								else ",srcField," end where length(",srcField,") != 5 ", @whereStmt);
								
								PREPARE stmt from @stmt;
								EXECUTE stmt;
								DEALLOCATE PREPARE stmt;
							   
								set @stmt = concat("update  ", @translatedTable , " set ",srcField," = left(",srcField,", 5) where length(", srcField,") > 5", @whereStmt);
								 
								PREPARE stmt from @stmt;
								EXECUTE stmt;
								DEALLOCATE PREPARE stmt;
                                
								
								set @stmt = concat("update  ", @translatedTable , " set forcw = 'MACRO_ERROR' where  ", @whereString);
                               
								PREPARE stmt from @stmt;
								EXECUTE stmt;
								DEALLOCATE PREPARE stmt;
							   
								if (length(con1) > 0) then
												
													set @stmt = concat("update  ", @translatedTable , " set forcw='BlankVar', ",srcField," = '",con1,"' where (length(", srcField,") = 0 or ",srcField," is null )  ", @whereStmt);
													
                                                    PREPARE stmt from @stmt;
													EXECUTE stmt;
													DEALLOCATE PREPARE stmt;
								end if;
							   
				

			end;
	end if;
				
end proc_main$$
DELIMITER ;





/** 2020 1105 **/
ALTER TABLE `universaltranslatorca`.`batchuploaddroppedvalues` 
CHANGE COLUMN `translatedReportField1Data` `translatedReportField1Data` VARCHAR(45) NULL DEFAULT 0 ;




