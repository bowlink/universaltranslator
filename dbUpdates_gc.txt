ALTER TABLE `universaltranslatorca`.`sqlstmts` 
ADD COLUMN `dateCreated` DATETIME NULL DEFAULT current_timestamp AFTER `sqlstmt`;

USE `universaltranslatorca`;
DROP procedure IF EXISTS `populateAuditReport`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `populateAuditReport`(in inConfigId int, in inBatchId int)
proc_main:begin


SET @stmt = CONCAT('truncate table  transactionindetailauditerrors_',inBatchId);
PREPARE stmt from @stmt;
EXECUTE stmt;

SELECT concat('F',rptField1),concat('F',rptField2),concat('F',rptField3),concat('F',rptField4) INTO @rptField1, @rptField2,@rptField3,@rptField4 
FROM configurationmessagespecs where configId = inConfigId LIMIT 1;

if(@rptField1 = 'F0') then 
	set @rptField1 = "F1";
end if;

if(@rptField2 = 'F0') then 
	set @rptField2 = "F2";
end if;

if(@rptField3 = 'F0') then 
	set @rptField3 = "F3";
end if;

if(@rptField4 = 'F0') then 
	set @rptField4 = "F4";
end if;


SET @stmt = CONCAT('insert into transactionindetailauditerrors_',inBatchId,' 
(required, batchUploadId, configId, transactionInRecordsId, fieldNo, errorId, transactionInErrorId,errorData, reportField1Data, reportField2Data, reportField3Data, reportField4Data)
select a.required, a.batchUploadId,a.configId,a.transactionInRecordsId,a.fieldno,a.errorId,a.id,a.fieldValue,b.',@rptField1,',b.',@rptField2,',b.',@rptField3,',b.',@rptField4,'
from transactioninerrors_',inBatchId,' a inner join 
transactioninrecords_',inBatchId,' b on a.transactionInRecordsId = b.id
where a.configId = ',inConfigId);

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


SET @stmt = CONCAT('UPDATE transactionIndetailauditerrors_',inBatchId,' JOIN (select distinct fieldNo matchid, macro_Name as label 
from macro_names, transactioninerrors_',inBatchId,' where macro_Names.id = transactioninerrors_',inBatchId,'.macroId) tbl_concat
     ON transactionIndetailauditerrors_',inBatchId,'.fieldNo = tbl_concat.matchid
SET transactionIndetailauditerrors_',inBatchId,'.errorDetails = tbl_concat.label WHERE errorId = 4');


PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


SET @stmt = CONCAT('UPDATE transactionindetailauditerrors_',inBatchId,'
  JOIN (select distinct fieldNo matchid, name as label 
from crosswalks, transactioninerrors_',inBatchId,' where crosswalks.id = transactioninerrors_',inBatchId,'.cwId) tbl_concat
     ON transactionIndetailauditerrors_',inBatchId,'.fieldNo = tbl_concat.matchid
SET transactionIndetailauditerrors_',inBatchId,'.errorDetails = tbl_concat.label WHERE errorId = 3');


PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

SET @stmt = CONCAT('UPDATE transactionIndetailauditerrors_',inBatchId,'
  JOIN (select distinct fieldNo matchid, validationType as label 
from ref_validationtypes, transactioninerrors_',inBatchId,' where ref_validationtypes.id = transactioninerrors_',inBatchId,'.validationTypeId) tbl_concat
     ON transactionIndetailauditerrors_',inBatchId,'.fieldNo = tbl_concat.matchid
SET transactionIndetailauditerrors_',inBatchId,'.errorDetails = tbl_concat.label WHERE errorId = 2');


PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


SET @stmt = CONCAT('UPDATE transactionIndetailauditerrors_',inBatchId,'
  JOIN (select distinct fieldNo as matchid, fieldDesc as label from configurationformfields where configId = ',inConfigId,') tbl_concat
     ON transactionIndetailauditerrors_',inBatchId,'.fieldNo = tbl_concat.matchid
SET transactionIndetailauditerrors_',inBatchId,'.fieldName = tbl_concat.label');


PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


SET @stmt = CONCAT('insert into transactionindetailauditerrors_',inBatchId,' 
(batchUploadId, configId, transactionInRecordsId, fieldNo, errorId, transactionInErrorId,errorData, required)
select batchUploadId,configId,0,fieldno,errorId,id,stackTrace, required from transactioninerrors_',inBatchId,' 
where errorId = 5 and configId = ',inConfigId);

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


SET @stmt = CONCAT("select group_concat(distinct concat('F', fieldNo)) from transactionindetailauditerrors_",inBatchId," 
where batchUPloadId = ",inBatchId,"  and errorData is null and configId = ",inConfigId," into @fieldNos;
");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


if (@fieldNos is not null) then

	begin
    
    SET @stmt = CONCAT("
		select distinct group_concat(distinct concat('when fieldNo = ', fieldNo , ' then ', concat('F', fieldNo)) separator ' ' ) from transactionindetailauditerrors_",inBatchId,"
        where batchUPloadId = ",inBatchId," and errorData is null and configId = ",inConfigId," into @updateStmts;
	 ");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
    
   if (@updateStmts is not null) then 
    begin
   
	   SET @stmt = CONCAT("
			update transactionindetailauditerrors_",inBatchId," tiae join (
			select id, ", @fieldNos," from transactioninrecords_",inBatchId,") tir
			on tiae.transactionInRecordsId = tir.id
			set errordata = case ",@updateStmts," end
			where batchUPloadId = ",inBatchId,"  and errorData is null  and configId = ",inConfigId," ;
		");
			
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
	end;
    end if;

	end;

end if;


SET @stmt = CONCAT('INSERT INTO batchuploadauditerrors (batchuploadId, configId, fieldNo, fieldName, errorId, errorDetails, errorData, reportField1Data, reportField2Data, reportField3Data, reportField4Data, rownumber, required) 
select batchUploadId, configId, table1.fieldNo, fieldName, errorId, errorDetails, errorData, reportField1Data, reportField2Data, reportField3Data, reportField4Data, transactionInRecordsId, required 
from transactionIndetailauditerrors_',inBatchId, " table1");


PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


end proc_main$$

DELIMITER ;

USE `universaltranslatorca`;
DROP procedure IF EXISTS `populateOutboundAuditReport`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `populateOutboundAuditReport`(in inConfigId int, in inBatchId int, in inBatchUpoadId int, in inBatchUploadConfigId int)
proc_main:begin


SET @stmt = CONCAT('delete from transactionoutdetailauditerrors_',inBatchId,' where configId = ',inConfigId);

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

SELECT concat('F',rptField1),concat('F',rptField2),concat('F',rptField3),concat('F',rptField4) INTO @rptField1, @rptField2,@rptField3,@rptField4 
FROM configurationmessagespecs where configId = inConfigId LIMIT 1;

SELECT populateInboundAuditReport INTO @populateInboundAuditReport
FROM configurationtransportdetails where configId = inConfigId LIMIT 1;


if(@rptField1 = 'F0') then 
	set @rptField1 = "F1";
end if;

if(@rptField2 = 'F0') then 
	set @rptField2 = "F2";
end if;

if(@rptField3 = 'F0') then 
	set @rptField3 = "F3";
end if;

if(@rptField4 = 'F0') then 
	set @rptField4 = "F4";
end if;


SET @stmt = CONCAT('insert into transactionoutdetailauditerrors_',inBatchId,' 
(required, batchDownloadId, configId, transactionOutRecordsId, fieldNo, errorId, transactionOutErrorId,errorData, reportField1Data, reportField2Data, reportField3Data, reportField4Data)
select a.required, a.batchDownloadId,a.configId,a.transactionOutRecordsId,a.fieldno,a.errorId,a.id,a.fieldValue,b.',@rptField1,',b.',@rptField2,',b.',@rptField3,',b.',@rptField4,'
from transactionouterrors_',inBatchId,' a inner join 
transactionoutrecords_',inBatchId,' b on a.transactionOutRecordsId = b.id
where a.configId = ',inConfigId);

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


SET @stmt = CONCAT("UPDATE transactionouterrors_",inBatchId," JOIN (select distinct id as matchId, macro_Name as label 
from macro_names) tbl_concat
     ON transactionouterrors_",inBatchId,".macroId = tbl_concat.matchid
SET transactionouterrors_",inBatchId,".stackTrace = concat(label, ' - ' , stackTrace)  WHERE errorId = 5");


PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


SET @stmt = CONCAT('UPDATE transactionoutdetailauditerrors_',inBatchId,' JOIN (select distinct fieldNo matchid, macro_Name as label 
from macro_names, transactionouterrors_',inBatchId,' where macro_Names.id = transactionouterrors_',inBatchId,'.macroId) tbl_concat
     ON transactionoutdetailauditerrors_',inBatchId,'.fieldNo = tbl_concat.matchid
SET transactionoutdetailauditerrors_',inBatchId,'.errorDetails = tbl_concat.label WHERE errorId = 4');

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

SET @stmt = CONCAT('UPDATE transactionoutdetailauditerrors_',inBatchId,'
  JOIN (select distinct fieldNo matchid, name as label 
from crosswalks, transactionouterrors_',inBatchId,' where crosswalks.id = transactionouterrors_',inBatchId,'.cwId) tbl_concat
     ON transactionoutdetailauditerrors_',inBatchId,'.fieldNo = tbl_concat.matchid
SET transactionoutdetailauditerrors_',inBatchId,'.errorDetails = tbl_concat.label WHERE errorId = 3');

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

SET @stmt = CONCAT('UPDATE transactionoutdetailauditerrors_',inBatchId,'
  JOIN (select distinct fieldNo matchid, validationType as label 
from ref_validationtypes, transactionouterrors_',inBatchId,' where ref_validationtypes.id = transactionouterrors_',inBatchId,'.validationTypeId) tbl_concat
     ON transactionoutdetailauditerrors_',inBatchId,'.fieldNo = tbl_concat.matchid
SET transactionoutdetailauditerrors_',inBatchId,'.errorDetails = tbl_concat.label WHERE errorId = 2');


PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

SET @stmt = CONCAT('UPDATE transactionoutdetailauditerrors_',inBatchId,'
  JOIN (select distinct fieldNo as matchid, fieldDesc as label from configurationformfields where configId = ',inConfigId,') tbl_concat
     ON transactionoutdetailauditerrors_',inBatchId,'.fieldNo = tbl_concat.matchid
SET transactionoutdetailauditerrors_',inBatchId,'.fieldName = tbl_concat.label');

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;



SET @stmt = CONCAT('insert into transactionoutdetailauditerrors_',inBatchId,' 
(required, batchDownloadId, configId, transactionOutRecordsId, fieldNo, errorId, transactionOutErrorId,errorData)
select required, batchDownloadId,configId,0,fieldno,errorId,id,stackTrace
from transactionouterrors_',inBatchId,' 
where errorId = 5 and configId = ',inConfigId);

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


SET @stmt = CONCAT("select group_concat(distinct concat('F', fieldNo)) from transactionoutdetailauditerrors_",inBatchId," 
where batchDownloadId = ",inBatchId,"  and errorData is null and configId = ",inConfigId," into @fieldNos;
");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;




if (@fieldNos is not null) then
	
	begin
    
    SET @stmt = CONCAT("
		select distinct group_concat(distinct concat('when fieldNo = ', fieldNo , ' then ', concat('F', fieldNo)) separator ' ' ) from transactionoutdetailauditerrors_",inBatchId,"
        where batchDownloadId = ",inBatchId," and errorData is null and configId = ",inConfigId," into @updateStmts;
	 ");
		

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
       
        
   if (@updateStmts is not null) then 
    begin
   
	   SET @stmt = CONCAT("
			update transactionoutdetailauditerrors_",inBatchId," tiae join (
			select distinct id, ", @fieldNos," from transactionoutrecords_",inBatchId,") tir
			on tiae.transactionoutRecordsId = tir.id
			set errordata = case ",@updateStmts," end
			where batchDownloadId = ",inBatchId,"  and errorData is null  and configId = ",inConfigId," ;
		");
			
           
			PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
	end;
    end if;
    
	end;

end if;

delete from batchdownloadauditerrors where batchdownloadId = inBatchid and configId = inConfigId;


SET @stmt = CONCAT('INSERT INTO batchdownloadauditerrors (batchDownloadId, configId, fieldNo, fieldName, errorId, errorDetails, errorData, reportField1Data, reportField2Data, reportField3Data, reportField4Data, rownumber) 
select batchDownloadId, configId, fieldNo, fieldName, errorId, errorDetails, errorData, reportField1Data, reportField2Data, reportField3Data, reportField4Data, transactionOutRecordsId 
from transactionoutdetailauditerrors_',inBatchId);

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


if (@populateInboundAuditReport) then
	
    begin
    
    
    call  createTempErrorTable(inBatchId);
	
    SET @stmt = CONCAT("
			insert into transactionoutdetailauditerrorsforinbound_",inBatchId," 
			select * from transactionoutdetailauditerrors_",inBatchId,";
			");
          	
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
            
	        
			SET @stmt = CONCAT("
				ALTER TABLE transactionoutdetailauditerrorsforinbound_",inBatchId,"  
				ADD COLUMN transactionInRecordsId INT NULL AFTER transactionOutErrorId,
				ADD COLUMN inFieldNo  INT NULL  AFTER transactionInRecordsId;
			");
            
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;      

			
            SET @stmt = CONCAT("
				update transactionoutdetailauditerrorsforinbound_",inBatchId," auditTable join (
				select distinct populateErrorFieldNo, mt.* from configurationconnectionfieldmappings  join 
				( select auditId, transactionInRecordsId, fieldno  from transactionoutrecords_",inBatchId," tir 
				join ( select id as auditId, transactionoutrecordsId, fieldNo from transactionoutdetailauditerrorsforinbound_",inBatchId,") errorTable 
				on tir.id = errorTable.transactionoutrecordsId) mt on mt.fieldNo = configurationconnectionfieldmappings.fieldNo 
                where sourceConfigId = ",inBatchUploadConfigId,") infoTable
				on infotable.auditid = auditTable.id
				set auditTable.transactionInRecordsId = infoTable.transactionInRecordsId, inFieldNo = populateErrorFieldNo;
			");
            
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;      
            
    
		
		SET @stmt = CONCAT("
				select group_concat(distinct concat('F', inFieldNo)) from transactionoutdetailauditerrorsforinbound_",inBatchId,"  where infieldNo != 0  into @inboundFields;
			 ");
             
            
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;  
           
            
		if (@inboundFields is not null) then 
        
			begin
			
            SET @stmt = CONCAT("
					select group_concat(distinct concat('when infieldNo = ', inFieldNo , ' then ',  concat('F', inFieldNo)) separator ' ' ) 
                    from transactionoutdetailauditerrorsforinbound_",inBatchId," where infieldNo != 0 into @inUpdateFields;
				");
                
                 
			PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;  
            
            
            SELECT concat('F',rptField1),concat('F',rptField2),concat('F',rptField3),concat('F',rptField4) INTO @rptInField1, @rptInField2,@rptInField3,@rptInField4 
			FROM configurationmessagespecs where configId = inBatchUploadConfigId LIMIT 1;
			
            
            	if (@rptInField1 = 'F0') then 
					set @rptInField1 = "F1";
				end if;

				if (@rptInField2 = 'F0') then 
					set @rptInField2 = "F2";
				end if;

				if (@rptInField3 = 'F0') then 
					set @rptInField3 = "F3";
				end if;

				if(@rptInField4 = 'F0') then 
					set @rptInField4 = "F4";
				end if;
            

			SET @stmt = CONCAT("
				update  transactionoutdetailauditerrorsforinbound_",inBatchId," tir join (
				select distinct ",@rptInField1," reportField1Data, ",@rptInField2," reportField2Data, ",@rptInField3," reportField3Data, ",@rptInField4," reportField4Data, 
                transactionInRecordsId, ",@inboundFields," from transactioninrecords_",inBatchUpoadId," tir join 
				(select distinct transactionInRecordsId from transactionoutdetailauditerrorsforinbound_",inBatchId,") auditTable
				on transactionInRecordsId = tir.id) infotable
				on infotable.transactionInRecordsId = tir.transactionInRecordsId
				set errorData = case 
				",@inUpdateFields,"
                end, 
                tir.reportField1Data = infotable.reportField1Data, tir.reportField2Data = infotable.reportField2Data,
                tir.reportField3Data = infotable.reportField3Data, tir.reportField4Data = infotable.reportField4Data
            ");
            
             
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;  
			
            SET @stmt = CONCAT("
				delete from batchuploadauditerrors where fromOutboundConfig = true and batchUploadId = ",inBatchUpoadId," and configId = ",inBatchUploadConfigId,"
			");
            
            PREPARE stmt from @stmt;
			EXECUTE stmt;
			DEALLOCATE PREPARE stmt;
            
 
            
            
             SET @stmt = CONCAT("insert into batchuploadauditerrors (batchUploadId, configId, fieldNo, fieldName, errorId, errorDetails, errorData, reportField1Data, 
							reportField2Data, reportField3Data, reportField4Data, rownumber, fromOutboundConfig, required)
							select ",inBatchUpoadId,", ",inBatchUploadConfigId,", case when inFieldNo is null then 0 else inFieldNo end, fieldName,  errorId, errorDetails, errorData, reportField1Data, 
							reportField2Data, reportField3Data, reportField4Data, transactionInRecordsId, true, required from 
							transactionoutdetailauditerrorsforinbound_",inBatchId, " table1");
            
             
			PREPARE stmt from @stmt;
			EXECUTE stmt;
            DEALLOCATE PREPARE stmt; 
            
            end;
    end if;
    
		
			SET @stmt = CONCAT("drop table if exists transactionoutdetailauditerrorsforinbound_",inBatchId,"; ");
    
			PREPARE stmt from @stmt;
			EXECUTE stmt;
            DEALLOCATE PREPARE stmt; 
          
    end;
end if;

select '';

end proc_main$$

DELIMITER ;

/** Macro changes 20200823 **/
UPDATE `universaltranslatorca`.`macro_names` SET `Con2_Question`='' WHERE `ID`='113';

USE `universaltranslatorca`;
DROP procedure IF EXISTS `ZipCodeCheck`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `ZipCodeCheck`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
SELECT 
    @translatedTable,
    @transactionTable,
    @batchTable,
    @batchIdType,
    @errorTable,
    @translateCol
INTO @translatedTable , @transactionTable , @batchTable , @batchIdType , @errorTable, @translateCol;

call getFinalStatusIds;
SELECT @finalStatusIds INTO @finalStatusIds;

				
                set @proceed = true;
                
                -- check con1
                if (length(con1) > 0) then
					begin
						
                        if con1 REGEXP '^[0-9]{5}$' = 0 then 
                        
							set @proceed = false;
                            
							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, fieldValue, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'Default zip code ",con1," is not a valid value'",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            -- update all transactions to macro_error
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            
                            leave proc_main;
						end if;
					end;
                end if;

				

				if (@proceed) then 
								begin
								
								set @whereStmt =  concat(" and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");
								set @whereString = concat(@whereClause , @whereStmt);
								set @whereClause = concat("  (",srcField," REGEXP '^[0-9]{5}$' != 1) 
								and ",srcField," is not null and length(",srcField,") > 0 ");
							   

								set @stmt = concat("update  ", @translatedTable , " set forcw = ",srcField);
								PREPARE stmt from @stmt;
								EXECUTE stmt;
								DEALLOCATE PREPARE stmt;

								set @stmt = concat("update  ", @translatedTable , " set ",srcField," = replace(",srcField,", '-', '') where (length(", srcField,") != 0 or ",srcField," is not null )", @whereStmt);
								PREPARE stmt from @stmt;
								EXECUTE stmt;
								DEALLOCATE PREPARE stmt;
								
								-- prepend regardless
								
								set @stmt = concat("update  ", @translatedTable , " set ",srcField," = 
								case 
								when (length(",srcField,") = 4 or length(",srcField,") = 8) then concat('0', ",srcField,") 
								when (length(",srcField,") = 3 or length(",srcField,") = 7)  then concat('00', ",srcField,") 
								when (length(",srcField,") = 2  or length(",srcField,") = 6)  then concat('000', ",srcField,") 
								when length(",srcField,") = 1 then concat('0000', ",srcField,") 
								else ",srcField," end where length(",srcField,") != 5 ", @whereStmt);
								
								PREPARE stmt from @stmt;
								EXECUTE stmt;
								DEALLOCATE PREPARE stmt;
							   
								set @stmt = concat("update  ", @translatedTable , " set ",srcField," = left(",srcField,", 5) where length(", srcField,") > 5", @whereStmt);
								 
								PREPARE stmt from @stmt;
								EXECUTE stmt;
								DEALLOCATE PREPARE stmt;
                                
								-- insert errors 
								set @stmt = concat("update  ", @translatedTable , " set forcw = 'MACRO_ERROR' where  ", @whereString);
                               
								PREPARE stmt from @stmt;
								EXECUTE stmt;
								
							   -- we default blank values regardless of required
								if (length(con1) > 0) then
												
													set @stmt = concat("update  ", @translatedTable , " set forcw='BlankVar', ",srcField," = '",con1,"' where (length(", srcField,") = 0 or ",srcField," is null )  ", @whereStmt);
													
                                                    PREPARE stmt from @stmt;
													EXECUTE stmt;
													DEALLOCATE PREPARE stmt;
								end if;
							   
				-- we pass / clear

				if (passClear = 2) THEN
							BEGIN
							set @dvTableName = "batchuploaddroppedvalues";
							set @colDirection = "in";

							if (foroutboundProcessing)  then
									set @dvTableName = "batchdownloaddroppedvalues";
									set @colDirection = "out";
							end if;
							
							SET @stmt = CONCAT("
								select fieldDesc from configurationformfields where fieldNo = replace('",srcField,"', 'F', '') and configId = ",configId," into @fieldName;
							");
						 
							PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            
                           SET @stmt = CONCAT("
							insert into ",@dvTableName ," (",@batchIdType,", transaction",@colDirection,"recordsId, fieldNo, configId, fieldName, fieldValue)
							select ",batchId,", transaction",@colDirection,"RecordsId, replace('",srcField,"', 'F', ''), ",configId,", '", @fieldName, "' , ",srcField," 
							from ", @translatedTable, " where forCW != 'BlankVar'  and ",@whereString
							);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
						
							set @stmt = concat("update ",@translatedTable, " set ", srcField ," = null  where " , @whereString);

							PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
						
				END;
				END IF;

			end;
	end if;
				
end proc_main$$

DELIMITER ;

USE `universaltranslatorca`;
DROP procedure IF EXISTS `applyCWTranslatedList`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `applyCWTranslatedList`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin 

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @listTable, @translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn, @listTable, @translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

if (transactionId = 0) then
	set @whereString = concat(" and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,");");
end if;

if (transactionId != 0) then
	set @whereString = concat(" and ",	@transactionTable,".id = ", transactionId,";");
end if;

set @fcol = replace(lcase(srcField), 'f', '');
set @stmt = concat("delete from ", @listTable," where fcol = ",@fcol," and ",@batchIdType," = ", batchId ,";");

PREPARE stmt from @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;


		

		set @stmt = concat("
		SELECT max(CHAR_LENGTH(",srcField,") - CHAR_LENGTH( REPLACE ( ",srcField,", ',', '') )  + 1) from ",@translatedTable, " into @maxListLength");
		
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
         
        if (@maxListLength is null) then
			set @maxListLength = 108;
        end if;
       
		set @stmt = concat("
    insert into ", @listTable," (",@batchIdType,", ",@translateCol,", invalue, fcol)
    SELECT ",@batchIdType,", ",@translateCol,", IFNULL(trim(SUBSTRING_INDEX(SUBSTRING_INDEX(t.",srcField,", ',', n.n), ',', -1)),'') value, ",@fcol,"
	FROM ",@translatedTable ," t CROSS JOIN (
    SELECT distinct a.N + b.N * 10 + 1 n FROM  
   (select id N from ref_numbers where id <=",@maxListLength,") a
   ,(select id N from ref_numbers where id <=",@maxListLength,") b
    ORDER BY n) n  WHERE n.n <= 1 + (LENGTH(t.",srcField,") - LENGTH(REPLACE(t.",srcField,", ',', ''))) ", @whereString);
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

    
    set @stmt = concat("update ",@listTable," set invalue = replace(replace(invalue, '\n',''), '\r', '')");
	 
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    
    set @stmt2 = "";
	set @stmt1 = concat("update ",@listTable," join (select id, sourcevalue, targetvalue from rel_crosswalkdata where crosswalkid = ", con1 ,") cwdata
	on invalue = sourcevalue set translatedvalue = targetvalue where ",@batchIdType," = ", batchId);
 
	set @stmt = concat(@stmt1, @stmt2);
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
	if (passClear = 1) then
	
	set @stmt1 = concat("update ",@listTable, " set translatedvalue = invalue where translatedvalue is null ");

	set @stmt = concat(@stmt1, @stmt2);
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
	end if;
  
  
  
	set @selDistinct = '';
    
    if (con2 = 'Y') then
		begin
			set @selDistinct = ' distinct ';
        end;
    end if;
  
    set @stmt = concat("update ",@translatedTable," join  (select ",@translateCol," as matchId, 
    group_concat(",@selDistinct," translatedValue order by id) label from  ",@listTable,"
	where ",@batchIdType," = ",batchid, " and fcol = ",@fCol," group by ",@translateCol," ) cwmatch on ",@translateCol," = matchid set ",srcField," = label ");
	   
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    
	
    set @colText = "in";
    if (foroutboundProcessing) then
		set @colText = "out";
    end if;
    
    if (passClear = 2) then

		set @stmt = concat("
			insert into transaction",@colText,"macrodroppedvalues_",batchId," (",@batchIdColumn ,", transaction",@colText,"RecordsId, fieldNo, fieldValue, matchId, configId) 
			select distinct ",batchId,", transaction",@colText,"RecordsId, fcol, invalue,concat(",configId,", '_', fcol, '_', invalue), ",configId," from transactiontranslatedlist",@colText,"_",batchId," where translatedValue is null and length(invalue) > 0;
		");
		
		
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
	end if;

	set @stmt = concat("
		insert into transaction",@colText,"macrokeptvalues_",batchId," (",@batchIdColumn ,", transaction",@colText,"RecordsId, fieldNo, fieldValue, matchId, configId) 
		select distinct ",batchId,", transaction",@colText,"RecordsId, fcol, invalue, concat(",configId,", '_', fcol, '_', invalue), ",configId," from transactiontranslatedlist",@colText,"_",batchId," where translatedValue is not null;
	");
 
	PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

    set @stmt = concat("delete from ", @listTable, " where ",@batchIdType," = ",batchId," and fcol = ",@fcol);
    
    PREPARE stmt from @stmt;
	EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

end proc_main$$

DELIMITER ;


USE `universaltranslatorca`;
DROP procedure IF EXISTS `ArithmeticConstant`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `ArithmeticConstant`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		-- decimal
		set fieldA = REPLACE(fieldA,'F','');
       
       if(fieldA is null or fieldA = '') then 
			BEGIN
				set fieldA = 0;
			END;
		end if;

        -- check to see if con1 is numeric
      if con1 REGEXP '^-?[0-9]+[.]?[0-9]*$|^-?[.][0-9]+$' = 0 or   fieldA REGEXP '^-?[0-9]+[.]?[0-9]*$|^-?[.][0-9]+$' = 0 then 
					begin
			
							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, fieldValue, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'ArithmeticConstant Con1 - ",con1,"  or FA - ",fieldA," is not a valid value'",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            -- update all transactions to macro_error
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							 
                             PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
           
			leave proc_main;
        end;
      end if;
      
        -- check to see if con1 is numeric
      if con2 = '/'  and  con1 = '0' then
					begin
			
							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, fieldValue, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'ArithmeticConstant Divide (con2) by 0 (con1) error.'",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            -- update all transactions to macro_error
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
           
			leave proc_main;
        end;
      end if;
      
      -- for con2 we only accept * +  / - 
       -- check to see if con1 is numeric
      if con2 != '/'  and  con2 != '-'  and con2!='*' and con2 != '+' then
					begin
			
							set @stmt = concat("insert into ", @errorTable , 
                            " (" , @batchIdColumn, ", configId, " , @translateCol, ", fieldNo, errorId, macroId, fieldValue, required) 
                            select ",batchId,", ",configId,", 0, replace('",srcField,"', 'F', ''), '", 5, 
							"', ",macroId,", ","'ArithmeticConstant con2 - ", con2," is not a valid arithmetic operation.'",", ",true);
                            
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
                            
                            -- update all transactions to macro_error
							set @stmt = concat("update ",@translatedTable, " set forCW = 'MACRO_ERROR'  where  configId = ",configId," and ", @batchIdType," = ",batchId,";");
							
                            PREPARE stmt from @stmt;
							EXECUTE stmt;
							DEALLOCATE PREPARE stmt;
           
			leave proc_main;
        end;
      end if;
      
		
        -- insert macro error if srcField is not numeric
        
        
		set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where ",srcField,"  REGEXP '^-?[0-9]+[.]?[0-9]*$|^-?[.][0-9]+$' = 0
        and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
		

		 set @stmt = concat("update ",@translatedTable, " set ",srcField," = ROUND((",srcField," ",con2," ",con1,"),",fieldA,") where 
         forcw is null and 
         configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")
		 and ",con1 ," REGEXP  '^-?[0-9]+[.]?[0-9]*$|^-?[.][0-9]+$' = 1  and ",srcField ," REGEXP  '^-?[0-9]+[.]?[0-9]*$|^-?[.][0-9]+$' = 1 ;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

end proc_main$$

DELIMITER ;


USE `universaltranslatorca`;
DROP procedure IF EXISTS `datemmddyyyytoyyyymmdd`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `datemmddyyyytoyyyymmdd`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

-- insert errors for non %m%d%Y dates
-- have to do it in two steps

set @errorIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(",srcField,", '%m%d%Y') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

if (@errorIds is not null) then

begin

set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;

-- now we convert to MySQL Date
set @stmt = concat("update ",@translatedTable, " set ",srcField," = str_to_date(",srcField,", '%m%d%Y') where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 	
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
      
-- we double check the data values
set @errorIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(",srcField,") is null
					and ",srcField," is not null and length(",srcField,") > 0  and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


if (@errorIds is not null) then

begin

set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;

set @errorIds = '';


-- now we remove the -
set @stmt = concat("update ",@translatedTable, " set ",srcField," =  replace(",srcField,", '-', '')
where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") 
");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

-- pass / clear
if (passClear = 2) THEN
	BEGIN
		set @stmt = concat("update ",@translatedTable, " set ",srcField,"  = null  where forCW= 'MACRO_ERROR';");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
    

	END;
END IF;



end proc_main$$

DELIMITER ;


USE `universaltranslatorca`;
DROP procedure IF EXISTS `datemmddyyyyWithSlashesToyyyymmdd`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `datemmddyyyyWithSlashesToyyyymmdd`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

-- insert errors for non %m%d%Y dates
-- have to do it in two steps

set @errorIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(",srcField,", '%m/%d/%Y') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

if (@errorIds is not null) then

begin

set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;

-- now we convert to MySQL Date
set @stmt = concat("update ",@translatedTable, " set ",srcField," = str_to_date(",srcField,", '%m/%d/%Y') where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 	
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
      
-- we double check the data values
set @errorIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(",srcField,") is null
					and ",srcField," is not null and length(",srcField,") > 0  and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


if (@errorIds is not null) then

begin

set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;

set @errorIds = '';


-- now we remove the -
set @stmt = concat("update ",@translatedTable, " set ",srcField," =  replace(",srcField,", '-', '')
where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") 
");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

-- pass / clear
if (passClear = 2) THEN
	BEGIN
		set @stmt = concat("update ",@translatedTable, " set ",srcField,"  = null  where forCW= 'MACRO_ERROR';");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
    
	END;
END IF;


end proc_main$$

DELIMITER ;


USE `universaltranslatorca`;
DROP procedure IF EXISTS `datemdyyyyWithSlashesToyyyymmdd`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `datemdyyyyWithSlashesToyyyymmdd`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

-- insert errors for non %m%d%Y dates
-- have to do it in two steps

set @errorIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(",srcField,", '%c/%e/%Y') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

if (@errorIds is not null) then

begin

set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;

-- now we convert to MySQL Date
set @stmt = concat("update ",@translatedTable, " set ",srcField," = str_to_date(",srcField,", '%c/%e/%Y') where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 	
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
      
-- we double check the data values
set @errorIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(",srcField,") is null
					and ",srcField," is not null and length(",srcField,") > 0  and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


if (@errorIds is not null) then

begin

set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;

set @errorIds = '';


-- now we remove the -
set @stmt = concat("update ",@translatedTable, " set ",srcField," =  replace(",srcField,", '-', '')
where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") 
");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

-- pass / clear
if (passClear = 2) THEN
	BEGIN
		set @stmt = concat("update ",@translatedTable, " set ",srcField,"  = null  where forCW= 'MACRO_ERROR';");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
    

	END;
END IF;



end proc_main$$

DELIMITER ;

USE `universaltranslatorca`;
DROP procedure IF EXISTS `dateyyyymmddWithDashesToyyyymmdd`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `dateyyyymmddWithDashesToyyyymmdd`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

-- insert errors for non %m%d%Y dates
-- have to do it in two steps

set @errorIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(",srcField,", '%Y-%m-%d') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

if (@errorIds is not null) then

begin

set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;

-- now we convert to MySQL Date
set @stmt = concat("update ",@translatedTable, " set ",srcField," = str_to_date(",srcField,", '%Y-%m-%d') where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 	
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
      
-- we double check the data values
set @errorIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(",srcField,") is null
					and ",srcField," is not null and length(",srcField,") > 0  and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


if (@errorIds is not null) then

begin

set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;

set @errorIds = '';

-- now we remove the -
set @stmt = concat("update ",@translatedTable, " set ",srcField," =  replace(",srcField,", '-', '')
where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") 
");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

-- pass / clear
if (passClear = 2) THEN
	BEGIN
		set @stmt = concat("update ",@translatedTable, " set ",srcField,"  = null  where forCW= 'MACRO_ERROR';");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
    

	END;
END IF;



end proc_main$$

DELIMITER ;

USE `universaltranslatorca`;
DROP procedure IF EXISTS `datedmyyWithSlashesToyyyymmdd`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `datedmyyWithSlashesToyyyymmdd`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(10), 
in con2 varchar(10), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
select @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol
into @translatedTable, @transactionTable, @batchTable, @batchIdType , @errorTable, @batchIdColumn,@translateCol;

call getFinalStatusIds;
select @finalStatusIds into @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

-- insert errors for non %m%d%Y dates
-- have to do it in two steps

set @errorIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where str_to_date(",srcField,", '%e/%c/%y') is null
					and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

if (@errorIds is not null) then

begin

set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;


-- reject anything that is not two digit years
set @errorIds = '';
set @stmt = concat("select group_concat(id) from ",@translatedTable, " where left(right(F1, 3), 1) != '/' 
					and ",srcField," is not null and length(",srcField,") > 0 and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

if (@errorIds is not null) then

begin

set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;


-- now we convert to MySQL Date
set @stmt = concat("update ",@translatedTable, " set ",srcField," = str_to_date(",srcField,",  '%e/%c/%y') where forcw is null
					and ",srcField," is not null and length(",srcField,") > 0 	
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
       
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
        
        
-- MySQL converts two digit year to 20 instead of 19, we need to handle
BEGIN
		set @stmt = concat("update ",@translatedTable," set  ", srcField ," = replace(",srcField, ", '206','196')   where  forcw is null and configId = ",configId," and ", @batchIdType, " = ",batchId," and statusId not in (",@finalStatusIds,");");
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;   
        
        set @stmt = concat("update ",@translatedTable," set  ", srcField ," = replace(",srcField, ", '205','195')   where  forcw is null and configId = ",configId," and ", @batchIdType, " = ",batchId," and statusId not in (",@finalStatusIds,");");
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;   
        
        set @stmt = concat("update ",@translatedTable," set  ", srcField ," = replace(",srcField, ", '204','194')   where forcw is null and  configId = ",configId," and ", @batchIdType, " = ",batchId," and statusId not in (",@finalStatusIds,");");
        PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;   
        
       set @stmt = concat("update ",@translatedTable," set  ", srcField ," = replace(",srcField, ", '203','193')   where forcw is null and  configId = ",configId," and ", @batchIdType, " = ",batchId," and statusId not in (",@finalStatusIds,");");
	   PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;    
    END;


      
-- we double check the data values
set @errorIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(",srcField,") is null
					and ",srcField," is not null and length(",srcField,") > 0  and forcw is null
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


if (@errorIds is not null) then

begin

set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;

set @errorIds = '';

-- now we remove the -
set @stmt = concat("update ",@translatedTable, " set ",srcField," =  replace(",srcField,", '-', '')
where configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") 
");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

-- pass / clear
if (passClear = 2) THEN
	BEGIN
		set @stmt = concat("update ",@translatedTable, " set ",srcField,"  = null  where forCW= 'MACRO_ERROR';");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
    

	END;
END IF;

end proc_main$$

DELIMITER ;


USE `universaltranslatorca`;
DROP procedure IF EXISTS `CheckInvalidDateAndError`;

DELIMITER $$
USE `universaltranslatorca`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `CheckInvalidDateAndError`(in configId int, 
in batchId int, in srcField varchar(10),
in fieldA varchar(10), in fieldB varchar(10), in con1 varchar(255), 
in con2 varchar(255), in macroId int, in foroutboundProcessing boolean, in passClear int, in transactionId int)
proc_main:begin

call setInboundOutBoundTables (foroutboundProcessing,batchId);
SELECT 
    @translatedTable,
    @transactionTable,
    @batchTable,
    @batchIdType,
    @errorTable,
    @translateCol
INTO @translatedTable , @transactionTable , @batchTable , @batchIdType , @errorTable, @translateCol;

call getFinalStatusIds;
SELECT @finalStatusIds INTO @finalStatusIds;

		set @stmt = concat("update ",@translatedTable, " set forcw = null;");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


set @errorIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, "  where 
					(str_to_date(",srcField,",'",con1,"') is null or str_to_date(",srcField,",'",con1,"') = '0000-00-00'
                    or right(str_to_date(",srcField,",'",con1,"'), 2) = '00' or left(str_to_date(",srcField,",'",con1,"'), 2) = '00' 
                    or substring(str_to_date(",srcField,",'",con1,"'), 6, 2) = '00' 
                    ) 
                    and ",srcField," is not null and length(",srcField,") > 0
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
       
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


if (@errorIds is not null) then

begin

set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;
     

-- now we convert to MySQL Date
set @stmt = concat("update ",@translatedTable, " set forcw = str_to_date(",srcField,", '",con1,"') where (forcw is null or forcw != 'MACRO_ERROR')
					and ",srcField," is not null and length(",srcField,") > 0 	
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,")");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
 
-- we double check the data values
set @errorIds = "";

set @stmt = concat("select group_concat(id) from ",@translatedTable, " where date(forcw) is null
					and ",srcField," is not null and length(",srcField,") > 0  and  (forcw is null or forcw != 'MACRO_ERROR')
					and ",srcField," is not null and length(",srcField,") > 0 	
					and configId = ",configId," and ", @batchIdType," = ",batchId," and statusId not in (",@finalStatusIds ,") into @errorIds");
        
		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;


if (@errorIds is not null) then

begin

set @stmt = concat("update ",@translatedTable, " set forcw = 'MACRO_ERROR' where id in (",@errorIds,")");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;
        
end;
end if;

-- pass / clear
if (passClear = 2) THEN
	BEGIN
		set @stmt = concat("update ",@translatedTable, " set ",srcField,"  = null  where forCW= 'MACRO_ERROR';");

		PREPARE stmt from @stmt;
		EXECUTE stmt;
		DEALLOCATE PREPARE stmt;

	END;
END IF;


end proc_main$$

DELIMITER ;





